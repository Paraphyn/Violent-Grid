<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hardcore Shooter by Paraphyn</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a2e;
            font-family: Roboto, sans-serif;
            overflow: hidden;
            position: relative;
            z-index: 1;
        }
        
        canvas {
            display: block;
            background: #000000;
            position: relative;
            z-index: 10;
            cursor: none;
        }

        .red-gradient-border {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 90;
            background: radial-gradient(
                circle at center,
                rgba(255, 0, 0, 0) calc(100% - 220px),
                rgba(255, 45, 45, 0.054) calc(100% - 140px),
                rgba(255, 30, 30, 0.105) calc(100% - 70px),
                rgba(255, 20, 20, 0.165) 100%
            );
            box-shadow: inset 0 0 90px rgba(255, 10, 10, 0.12);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.35s ease;
        }

        .red-gradient-border.active {
            opacity: 1;
            visibility: visible;
        }
        
        .ui {
            position: absolute;
            color: white;
            font-weight: normal;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
            z-index: 100;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        .ui.hidden {
            opacity: 0;
            visibility: hidden;
        }
        
        body * {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-touch-callout: none;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            background: #000000 !important;
        }
        
        .debug, .overlay, .watermark, .info, pre, code {
            display: none !important;
            visibility: hidden !important;
        }
        
        body::before, body::after {
            display: none !important;
        }
        
        script {
            display: none !important;
        }
        
        .enemies { top: 20px; left: 20px; font-size: 20px; }
        .timer { top: 20px; left: 50%; transform: translateX(-50%); font-size: 50px; }
        .next-wave { top: 110px; left: 50%; transform: translateX(-50%); font-size: 20px; color: #00ffff; }
        .next-wave.boss-warning { color: #ff3333; font-weight: bold; text-shadow: 0 0 10px rgba(255, 0, 0, 0.7), 0 0 20px rgba(255, 0, 0, 0.5); animation: bossBlink 1.2s ease-in-out infinite; }
        @keyframes bossBlink { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
        .boss-name-label {
            top: 136px;
            left: 50%;
            transform: translate(-50%, 20px);
            font-size: 30px;
            font-weight: 1000;
            color: #ff2a2a;
            text-shadow: 0 0 12px rgba(255, 80, 80, 0.95), 0 0 28px rgba(255, 0, 0, 0.7), 0 0 45px rgba(255, 0, 0, 0.5);
            letter-spacing: 2px;
            display: none;
            opacity: 0;
        }
        .boss-name-label.boss-name-show {
            display: block;
            animation: bossNameReveal 0.6s ease-out forwards;
        }
        @keyframes bossNameReveal {
            0% { opacity: 0; transform: translate(-50%, 24px); }
            60% { opacity: 1; transform: translate(-50%, -4px); }
            100% { opacity: 1; transform: translate(-50%, 0); }
        }
        .score { top: 50px; left: 20px; font-size: 20px; }
        .score-addition { color: #00ff00; }
        .wave { top: 80px; left: 20px; font-size: 20px; }
        .controls {
            bottom: 20px;
            left: 20px;
            font-size: 18px;
            opacity: 0.6;
            transition: opacity 2s ease;
        }
        .controls.controls-hidden {
            opacity: 0;
        }
        /* DEV: FPS indicator */
        .fps { bottom: 20px; right: 20px; font-size: 18px; color: #00ff00; }

        
        
        /* XP Bar */
        .xp-bar { top: 80px; left: 50%; transform: translateX(-50%); width: 300px; height: 16px; border: 2px solid #ffffff; position: relative; overflow: hidden; }
        .xp-bar-fill { height: 100%; width: 0%; background: #00ff00; }
        .xp-gain-overlay { position: absolute; top: 0; height: 100%; background: rgba(255,255,255,0.85); pointer-events: none; opacity: 0; }
        .xp-label { top: 80px; left: calc(50% - 180px - 10px); font-size: 20px; }
        .xp-level { top: 80px; left: calc(50% + 180px - 10px); font-size: 20px; }
        
        /* Lobby Screen Styles */
        /* Theme spacing variables (editable via controls) */
        :root {
            --theme-gap: 16px;          /* space between theme items */
            --theme-title-gap: 15px;    /* space between title and items */
            --theme-name-gap: 8px;      /* space between circle and name */
            --theme-option-width: 80px; /* fixed width per option to keep symmetry */
        }

        .lobby {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                0deg,
                rgba(255, 70, 70, 0.28) 0%,
                rgba(255, 70, 70, 0.18) 28%,
                rgba(255, 70, 70, 0.08) 52%,
                rgba(255, 70, 70, 0) 68%
            );
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            transition: opacity 0.5s ease;
        }
        
        .lobby.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }
        
        .lobby-logo {
            max-width: 1000px;
            max-height: 400px;
            width: auto;
            height: auto;
            filter: drop-shadow(0 0 20px rgba(255, 45, 45, 0.5)) drop-shadow(0 0 40px rgba(255, 45, 45, 0.325));
            animation: logoGlow 2s ease-in-out infinite alternate;
            display: block;
            margin-bottom: 50px;
        }

        /* .lobby-credit removed */

        .lobby-best {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff4d4d;
            font-size: 18px;
            opacity: 0.8;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(255, 60, 60, 0.4);
        }
          
          .lobby-character {
              position: absolute;
              bottom: 0;
              right: 200px;
              width: clamp(200px, 24vw, 420px);
              height: auto;
              pointer-events: none;
              user-select: none;
              z-index: 205;
              filter: drop-shadow(0 0 25px rgba(0, 0, 0, 0.65));
              transition: opacity 0.2s ease, transform 0.2s ease;
          }
        
        /* DEV: Wipe local data button (visible only in lobby) */
        .wipe-button {
            position: absolute;
            bottom: 20px;
            left: 20px;
            padding: 8px 14px;
            font-size: 12px;
            font-weight: bold;
            color: #00ff00;
            background: rgba(0, 255, 0, 0.08);
            border: 2px solid #00ff00;
            border-radius: 4px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            z-index: 210;
            transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
        }
        .wipe-button:hover {
            transform: translateY(-1px);
            background: rgba(0, 255, 0, 0.18);
            box-shadow: 0 0 12px rgba(0, 255, 0, 0.4);
        }
        
        @keyframes logoGlow {
            from {
                filter: drop-shadow(0 0 20px rgba(255, 45, 45, 0.5)) drop-shadow(0 0 40px rgba(255, 45, 45, 0.325));
            }
            to {
                filter: drop-shadow(0 0 30px rgba(255, 70, 70, 0.5)) drop-shadow(0 0 60px rgba(255, 70, 70, 0.375)) drop-shadow(0 0 80px rgba(255, 80, 80, 0.275));
            }
        }
        
        @keyframes titleGlow {
            from {
                text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff;
            }
            to {
                text-shadow: 0 0 30px #00ffff, 0 0 60px #00ffff, 0 0 80px #00ffff;
            }
        }
        
        .start-button {
            padding: 12px 80px;
            font-size: 12px;
            font-weight: bold;
            color: #ffffff;
            background: transparent;
            border: 3px solid #ff3b3b;
            border-radius: 0;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
            position: relative;
            overflow: hidden;
        }
        
        .start-button:hover {
            color: #ff5a5a;
            border-color: #ff5a5a;
        }
        
        .start-button .button-rain {
            position: absolute;
            top: 100%;
            left: 0;
            width: 100%;
            height: 0;
            overflow: hidden;
            pointer-events: none;
        }
        
        .start-button:hover .button-rain {
            height: 60px;
        }
        
        .rain-digit {
            position: absolute;
            color: #ffffff;
            font-family: monospace;
            font-size: 12px;
            animation: rainFall 1s linear infinite;
        }
        
        @keyframes rainFall {
            from {
                transform: translateY(-10px);
                opacity: 1;
            }
            to {
                transform: translateY(60px);
                opacity: 0;
            }
        }
        
        .start-button:active {
            transform: scale(0.98);
        }
        
        /* Theme selector (lobby) */
        .theme-selector {
            margin-top: 44px;
            margin-left: auto;
            margin-right: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            gap: var(--theme-title-gap, 10px);
        }
        .theme-label {
            color: #ff2d2d;
            font-size: 12px;
            letter-spacing: 2px;
            opacity: 0.9;
        }
        .theme-options {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--theme-gap, 22px);
        }
        .theme-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            width: var(--theme-option-width, 96px);
            transition: transform 0.2s ease;
        }
        .theme-option .circle {
            width: 38px;
            height: 38px;
            border-radius: 50%;
            border: 2px solid #cccccc;
            box-sizing: border-box;
            transform-origin: center center;
            transition: transform 0.2s ease, filter 0.2s ease;
        }
        .theme-option .theme-name {
            margin-top: var(--theme-name-gap, 6px);
            font-size: 11px;
            color: #cccccc;
            text-transform: none;
            letter-spacing: 1px;
            white-space: nowrap;
            width: 100%;
            text-align: center;
        }
        .theme-option.selected { /* visual emphasis handled on circle to avoid layout shift */ }
        .theme-option.selected .circle {
            transform: scale(1.25);
            filter: drop-shadow(0 0 12px #ff3f3f) drop-shadow(0 0 20px rgba(255, 63, 63, 0.55));
        }
        /* Small shake feedback for locked click */
        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-3px); }
            50% { transform: translateX(3px); }
            75% { transform: translateX(-2px); }
            100% { transform: translateX(0); }
        }
        .theme-option.shake { animation: shake 0.2s; }
        /* Locked theme state */
        .theme-option.locked { cursor: not-allowed; opacity: 0.75; }
        .theme-option.locked .circle { background: #000000 !important; border-color: #333333 !important; box-shadow: none !important; animation: none !important; }
        .theme-option.locked .theme-name { color: #777777 !important; }
        .theme-default {
            background: #ffffff;
            border: 2px solid transparent;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.9), 0 0 18px rgba(255, 255, 255, 0.55);
        }
        .theme-cyan {
            background: #00ffff;
            border: 2px solid rgba(0, 255, 255, 0.9);
            border-radius: 0;
            clip-path: polygon(50% 0, 100% 50%, 50% 100%, 0 50%);
            box-shadow: 0 0 10px rgba(0,255,255,0.8), 0 0 18px rgba(0,255,255,0.5);
        }
        .theme-rainbow {
            background: conic-gradient(from 0deg, red, orange, yellow, green, cyan, blue, violet, red);
            border: 2px solid rgba(255, 255, 255, 0.7);
            border-radius: 6px;
            animation: rainbowHue 8s linear infinite;
        }
        @keyframes rainbowHue {
            from { filter: hue-rotate(0deg); }
            to { filter: hue-rotate(360deg); }
        }
        
        .audio-controls {
            position: absolute;
            top: 18px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 300;
        }
        
        .music-toggle,
        .sfx-toggle {
            position: relative;
            width: 40px;
            height: 40px;
            background: transparent;
            border: none;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: #ffffff;
            transition: all 0.3s ease;
            z-index: 300;
        }
        
        .music-toggle:hover,
        .sfx-toggle:hover {
            transform: scale(1.1);
        }
        
        .music-icon,
        .sfx-icon {
            width: 32px;
            height: 26px;
            display: block;
        }

        .tutorial-button {
            position: absolute;
            top: 18px;
            left: 20px;
            width: 45px;
            height: 45px;
            background: transparent;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s ease;
            z-index: 300;
        }

        .tutorial-button:focus {
            outline: none;
        }

        .tutorial-button:hover,
        .tutorial-button:focus-visible {
            transform: scale(1.08);
        }

        .tutorial-button-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid #ff2d2d;
            color: #ff2d2d;
            font-family: Roboto, sans-serif;
            font-weight: 700;
            font-size: 20px;
            letter-spacing: 1px;
            background: rgba(255, 45, 45, 0.18);
            box-shadow: 0 0 12px rgba(255, 45, 45, 0.55);
            transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
        }

        .tutorial-button:hover .tutorial-button-icon,
        .tutorial-button:focus-visible .tutorial-button-icon {
            background: rgba(255, 45, 45, 0.32);
            box-shadow: 0 0 18px rgba(255, 45, 45, 0.75);
        }

        .tutorial-overlay {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.75);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 600;
        }

        .tutorial-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .tutorial-banner {
            position: relative;
            max-width: 640px;
            width: calc(100% - 64px);
            background: #000000;
            border: 2px solid #ff4d4d;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.75);
            padding: 40px 48px 36px;
            font-family: Roboto, sans-serif;
        }

        .tutorial-close {
            position: absolute;
            top: 12px;
            right: 12px;
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 0;
            background: transparent;
            color: #ffffff;
            font-size: 24px;
            font-weight: 600;
            line-height: 1;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s ease, color 0.2s ease;
        }

        .tutorial-close:focus {
            outline: none;
        }

        .tutorial-close:hover,
        .tutorial-close:focus-visible {
            transform: scale(1.08);
        }

        .tutorial-close:focus-visible {
            outline: 2px solid #ff4d4d;
            outline-offset: 3px;
        }

        .tutorial-title {
            margin: 0 0 24px;
            font-size: 28px;
            letter-spacing: 2px;
            color: #ffffff;
        }

        .tutorial-description {
            color: #ff4d4d;
            font-size: 16px;
            line-height: 1.6;
        }
        
        /* Quit Button in Pause Menu */
        .quit-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, 100px);
            padding: 12px 80px;
            font-size: 12px;
            font-weight: bold;
            color: #ffffff;
            background: transparent;
            border: 3px solid #00ffff;
            border-radius: 0;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s ease;
            z-index: 550;
        }
        
        .quit-button:hover,
        .quit-button:focus-visible {
            color: #00ffff;
            border-color: #ffffff;
        }
        
        .quit-button:active {
            transform: translate(-50%, 100px) scale(0.98);
        }
        
        .quit-button.visible {
            display: inline-flex;
        }
        
        /* Upgrade Selection Overlay */
        .upgrade-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 500;
        }
        .upgrade-overlay.visible { display: flex; }
        .upgrade-container {
            display: flex;
            flex-wrap: nowrap;
            gap: var(--upgrade-card-gap, 50px);
            padding: 24px;
            justify-content: center;
            align-items: center;
            margin: 0 auto;
        }
        .upgrade-card {
            background: #000000;
            border: 2px solid #ffffff;
            padding: 16px;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            width: 280px;
            position: relative;
            transition: transform 150ms ease, opacity 250ms ease, box-shadow 150ms ease;
        }
        .upgrade-card.dimmed { opacity: 0.35; }
        .upgrade-card.selected {
            opacity: 1;
            transform: scale(1.05);
            box-shadow: 0 0 20px #00ffff66, 0 0 8px #00ffff33 inset;
        }
        .upgrade-card img {
            width: 120px;
            height: 120px;
            object-fit: contain;
            margin-bottom: 12px;
            filter: drop-shadow(0 0 10px #00ffff33);
        }
        .upgrade-title {
            color: #00ffff;
            font-weight: bold;
            font-size: 22px;
            margin: 8px 0 6px;
        }
        .upgrade-desc {
            color: #ffffff;
            font-size: 16px;
            min-height: 48px;
            margin-bottom: 12px;
        }
        .upgrade-select-btn {
            padding: 10px 36px;
            border: 3px solid #00ffff;
            background: transparent;
			color: #ffffff;
            font-weight: bold;
            cursor: pointer;
        }
        .upgrade-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .upgrade-overlay-title {
            color: #00ffff;
            font-weight: bold;
            font-size: 60px;
            letter-spacing: 2px;
            margin-bottom: 16px;
        }
        .upgrade-key-badge {
            position: absolute;
            top: 8px;
            right: 8px;
            color: #00ffff;
            font-weight: bold;
            font-size: 18px;
        }
        .upgrade-hint {
            color: #ffffff;
            text-align: center;
            font-size: 14px;
            opacity: 0.9;
            margin-top: 12px;
        }
    </style>
</head>
    <body>
        <canvas id="canvas"></canvas>
        <div class="red-gradient-border" aria-hidden="true"></div>
    <div class="ui enemies">Kills: <span id="enemies">0</span></div>
    <div class="ui timer"><span id="timer">00:00</span></div>
    <div class="ui next-wave" id="nextWave" style="display: none;"></div>
    <div class="ui boss-name-label" id="bossNameLabel" style="display: none;"></div>
    <div class="ui score">Score: <span id="score">0</span><span class="score-addition" id="scoreAddition"></span></div>
    <div class="ui wave">Wave: <span id="wave">0</span></div>
    <div class="ui xp-label">XP</div>
    <div class="ui xp-bar"><div class="xp-bar-fill" id="xpFill"></div></div>
    <div class="ui xp-level" id="xpLevel">Lv. 1</div>
    <div class="ui controls">Controls >>> WASD: Move | L.Mouse: Bullets | Hold R.Mouse: Railgun | M.Mouse: Rockets | Space: Mines | Shift: Dash</div>
    <!-- DEV: FPS indicator -->
    <div class="ui fps" id="fps" style="display: none;">FPS: 60</div>
    
    <!-- Lobby Screen -->
    <div class="lobby" id="lobby">
        <button class="tutorial-button" id="tutorialButton" title="How to Play" aria-haspopup="dialog" aria-controls="tutorialOverlay">
            <span class="tutorial-button-icon">?</span>
        </button>
        <img class="lobby-logo" id="lobbyLogo" src="game-logo.png" alt="GEOMETRY RUSH" />
        <button class="start-button" id="startButton" style="margin-top: 24px;">
            START
            <div class="button-rain" id="buttonRain"></div>
        </button>
        <!-- Theme selector: centered by X under Start -->
        <div class="theme-selector" id="themeSelector" aria-label="Select Theme">
            <div class="theme-label">Select Skin</div>
            <div class="theme-options">
                <div class="theme-option" data-theme="default" id="themeDefault">
                    <div class="circle theme-default"></div>
                    <div class="theme-name">White</div>
                </div>
                <div class="theme-option" data-theme="cyan" id="themeCyan">
                    <div class="circle theme-cyan"></div>
                    <div class="theme-name" id="themeCyanName">Glow</div>
                </div>
                <div class="theme-option" data-theme="rainbow" id="themeRainbow">
                    <div class="circle theme-rainbow"></div>
                    <div class="theme-name" id="themeRainbowName">Rainbow</div>
                </div>
            </div>
            
          </div>
          <img
              class="lobby-character"
              id="lobbyCharacter"
              src="Character_1_lobby.png"
              alt="Lobby character preview"
          />
          <div class="lobby-best" id="bestStats">Best Score: 0 / Max Wave: 0</div>
        <!-- DEV: Wipe local saved data button (lobby only) -->
        <button class="wipe-button" id="wipeButton" title="Erase local saved data" style="display: none;">Wipe</button>
    </div>
    
    <!-- Audio Toggle Buttons -->
    <div class="audio-controls" aria-label="Audio Toggles">
        <div class="music-toggle" id="musicToggle" title="Toggle Music">
            <img class="music-icon" id="musicIcon" src="sound-on.png" alt="Music On" />
        </div>
        <div class="sfx-toggle" id="sfxToggle" title="Toggle Sound Effects" aria-pressed="true">
            <img class="sfx-icon" id="sfxIcon" src="sound-fx-on.png" alt="Sound Effects On" />
        </div>
    </div>
    
    <!-- Quit Button for Pause Menu -->
    <button type="button" class="quit-button" id="quitButton" title="Return to Lobby">Back to Lobby</button>

    <!-- Tutorial Overlay -->
    <div class="tutorial-overlay" id="tutorialOverlay" role="dialog" aria-modal="true" aria-hidden="true">
        <div class="tutorial-banner">
            <button class="tutorial-close" id="tutorialCloseButton" aria-label="Close Tutorial">âœ•</button>
            <h2 class="tutorial-title">HOW TO PLAY</h2>
            <div class="tutorial-description">
               	Kill enemies and collect green XP Orbs to level up and choose upgrades.<br>
				Every 3 waves, youâ€™ll encounter a random BOSS. Good Luck, player.<br><br>
                <label style="color: white;">CONTROLS</label><br>
              	WASD - Move<br>
                Mouse - Aim<br>
                Shift - Dash<br><br>
                <label style="color: white;">WEAPONS</label><br>
                L. Mouse - Blaster Projectiles<br>
                R. Mouse - Railgun (Hold to charge), MAX charge break shields<br>
                M. Mouse - Rockets with Area Damage<br>
                Space - Contact Mines with Area Damage
            </div>
        </div>
    </div>

    <div class="upgrade-overlay" id="upgradeOverlay">
        <div class="upgrade-wrapper">
            <div class="upgrade-overlay-title">LEVEL UP!</div>
            <div class="upgrade-container" id="upgradeContainer"></div>
            <div class="upgrade-hint">Press keys [ 1 ] [ 2 ] [ 3 ] to select Upgrade</div>
        </div>
    </div>
    <script src="enemies.js"></script>
    <script src="player-config.js"></script>
    <script src="sound-controller.js"></script>

    <script>
        // Global speed && scaling settings
        const SPEED_SETTINGS = { baseWidth: 1920, baseHeight: 1080, globalSpeed: 0.8 };

        const PLAYER_WEAPON_BASE_DAMAGE = Object.freeze({
            bullet: 50,
            rocket: 150,
            mine: 100,
            railgunMin: 5,
            railgunMax: 250
        });

        document.addEventListener('keydown', e => e.key === 'F8' && ['fps','wipeButton'].forEach(id => { const el = document.getElementById(id); if (el) el.style.display = el.style.display === 'none' ? '' : 'none'; }));

        function getMotionScale() {
            try {
                return (typeof window !== 'undefined' && window.game && window.game.speedScale) ? window.game.speedScale : 1;
            } catch (e) {
                return 1;
            }
        }

        function getTimeScale() {
            return SPEED_SETTINGS.globalSpeed || 1;
        }

        // Falling numbers background effect for lobby (simple, layered, cyan)
        class FallingNumbers {
            constructor(x, y, layer = 0, options = {}) {
                this.x = x;
                this.y = y;
                this.layer = layer;
                this.options = options || {};
                this.digits = Array.isArray(this.options.digits) && this.options.digits.length > 0
                    ? this.options.digits.map(d => String(d))
                    : ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
                this.digitChangeMode = this.options.digitChangeMode === 'random' ? 'random' : 'increment';
                this.color = this.options.color || '#ff3b3b';
                this.fontFamily = this.options.fontFamily || 'monospace';

                this.digitIndex = Math.floor(Math.random() * this.digits.length);
                this.digit = this.digits[this.digitIndex];

                // Layer-based simple properties (back to front)
                // Speeds are in px/frame scaled by global time scale; slowed to 50%
                if (layer === 0) { this.speed = 0.3; this.baseOpacity = 0.25 + Math.random() * 0.1; this.size = 10 + Math.random() * 3; }
                else if (layer === 1) { this.speed = 0.45; this.baseOpacity = 0.35 + Math.random() * 0.1; this.size = 12 + Math.random() * 4; }
                else if (layer === 2) { this.speed = 0.6; this.baseOpacity = 0.50 + Math.random() * 0.15; this.size = 14 + Math.random() * 6; }
                else if (layer === 3) { this.speed = 0.9; this.baseOpacity = 0.70 + Math.random() * 0.15; this.size = 18 + Math.random() * 8; }
                else /* layer 4 */ { this.speed = 1.3; this.baseOpacity = 0.85 + Math.random() * 0.1; this.size = 22 + Math.random() * 10; }

                // Per-number digit change cadence (slower in back, faster in front)
                const changeRanges = [ [18, 30], [14, 24], [10, 18], [6, 12], [3, 8] ];
                const [minC, maxC] = changeRanges[Math.max(0, Math.min(4, layer))];
                this.digitTick = 0;
                this.digitTickMax = minC + Math.random() * (maxC - minC);

                this.opacity = 0;
            }

            update(canvas) {
                const t = getTimeScale();
                // Fall straight down
                this.y += this.speed * t;

                // Advance digit based on per-number cadence
                this.digitTick += t;
                if (this.digitTick >= this.digitTickMax) {
                    this.advanceDigit();
                    this.digitTick = 0;
                }

                // Simple fade-in at top and fade-out near bottom for stability
                const fadeInH = 30;
                const fadeOutH = 60;
                let alpha = this.baseOpacity;
                if (this.y < fadeInH) {
                    alpha *= Math.max(0, Math.min(1, this.y / fadeInH));
                } else if (this.y > canvas.height - fadeOutH) {
                    const k = 1 - Math.max(0, Math.min(1, (this.y - (canvas.height - fadeOutH)) / fadeOutH));
                    alpha *= k;
                }
                this.opacity = alpha;

                // Keep until completely out of view
                return this.y < canvas.height + 50;
            }

            draw(ctx) {
                if (this.opacity <= 0.01) return;
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.fillStyle = this.color;
                ctx.font = `${this.size}px ${this.fontFamily}`;
                ctx.textAlign = 'center';
                ctx.fillText(String(this.digit), this.x, this.y);
                ctx.restore();
            }

            advanceDigit() {
                if (this.digits.length <= 1) return;
                if (this.digitChangeMode === 'random') {
                    let nextIndex = Math.floor(Math.random() * this.digits.length);
                    if (nextIndex === this.digitIndex && this.digits.length > 1) {
                        nextIndex = (nextIndex + 1) % this.digits.length;
                    }
                    this.digitIndex = nextIndex;
                } else {
                    this.digitIndex = (this.digitIndex + 1) % this.digits.length;
                }
                this.digit = this.digits[this.digitIndex];
            }
        }

        // Falling numbers manager for lobby
        class FallingNumbersManager {
            constructor(canvas, options = {}) {
                this.canvas = canvas;
                this.options = options || {};
                this.layers = [[], [], [], [], []]; // Five layers
                this.spawnTimers = [0, 0, 0, 0, 0];
                // Slower, steadier spawn per layer; more small digits in back
                this.spawnDelays = Array.isArray(this.options.spawnDelays) && this.options.spawnDelays.length === 5
                    ? this.options.spawnDelays
                    : [14, 12, 10, 8, 6];
                this.maxNumbers = Array.isArray(this.options.maxNumbers) && this.options.maxNumbers.length === 5
                    ? this.options.maxNumbers
                    : [70, 55, 40, 28, 18];
                // Prewarm so the screen isn't empty at start
                this.reset();
            }

            update() {
                // Update all layers
                for (let layer = 0; layer < 5; layer++) {
                    const arr = this.layers[layer];
                    let write = 0;
                    for (let read = 0; read < arr.length; read++) {
                        const item = arr[read];
                        if (item.update(this.canvas)) arr[write++] = item;
                    }
                    arr.length = write;
                    this.spawnTimers[layer] += getTimeScale();
                    if (this.spawnTimers[layer] >= this.spawnDelays[layer] &&
                        this.layers[layer].length < this.maxNumbers[layer]) {
                        this.spawnNumber(layer);
                        this.spawnTimers[layer] = 0;
                    }
                    
                }
            }

            spawnNumber(layer) {
                const x = Math.random() * this.canvas.width;
                const y = -50;
                this.layers[layer].push(new FallingNumbers(x, y, layer, this.options));
            }

            draw(ctx) {
                // Draw layers from back to front for proper depth
                for (let layer = 0; layer < 5; layer++) {
                    this.layers[layer].forEach(number => number.draw(ctx));
                }
            }

            _prewarm() {
                // Fill some digits across the screen for each layer at random Y positions
                for (let layer = 0; layer < 5; layer++) {
                    const count = Math.floor(this.maxNumbers[layer] * 0.6);
                    for (let i = 0; i < count; i++) {
                        const x = Math.random() * this.canvas.width;
                        const y = Math.random() * this.canvas.height;
                        this.layers[layer].push(new FallingNumbers(x, y, layer, this.options));
                    }
                }
            }

            reset() {
                for (let layer = 0; layer < 5; layer++) {
                    this.layers[layer] = [];
                    this.spawnTimers[layer] = 0;
                }
                this._prewarm();
            }
        }

        // Audio Manager
        class AudioManager {
            constructor(config) {
                const globalConfig = (typeof window !== 'undefined' && window.SOUND_CONTROLLER) ? window.SOUND_CONTROLLER : {};
                this.config = (config && typeof config === 'object') ? config : globalConfig;
                const settings = (this.config && typeof this.config.settings === 'object') ? this.config.settings : {};
                this.settings = {
                    defaultVolume: settings.defaultVolume ?? 0.7,
                    musicVolume: settings.musicVolume ?? 0.4,
                    concurrencyWindowMs: settings.concurrencyWindowMs ?? 250,
                    maxVoices: { default: 8, ...(settings.maxVoices || {}) }
                };
                this.audios = {};
                this.initialized = false;
                this.volume = this.settings.defaultVolume;
                this.musicVolume = this.settings.musicVolume;
                this.loadingPromises = [];
                this.musicEnabled = true;
                this.soundEffectsEnabled = true;
                this.musicKeys = new Set();
                this.soundEffectKeys = new Set();
                this._audioSettingsStorageKey = 'geometry_rush_audio_settings';
                this._loadAudioSettings();
            }

            _loadAudioSettings() {
                if (typeof localStorage === 'undefined') return;
                try {
                    const raw = localStorage.getItem(this._audioSettingsStorageKey);
                    if (!raw) return;
                    const parsed = JSON.parse(raw);
                    if (typeof parsed.musicEnabled === 'boolean') {
                        this.musicEnabled = parsed.musicEnabled;
                    }
                    if (typeof parsed.soundEffectsEnabled === 'boolean') {
                        this.soundEffectsEnabled = parsed.soundEffectsEnabled;
                    }
                } catch (e) {
                    console.warn('AudioManager: Failed to load audio settings.', e);
                }
            }

            _persistAudioSettings() {
                if (typeof localStorage === 'undefined') return;
                try {
                    const payload = JSON.stringify({
                        musicEnabled: this.musicEnabled,
                        soundEffectsEnabled: this.soundEffectsEnabled
                    });
                    localStorage.setItem(this._audioSettingsStorageKey, payload);
                } catch (e) {
                    console.warn('AudioManager: Failed to persist audio settings.', e);
                }
            }

            async initialize() {
                if (this.initialized) return;
                const basePath = typeof this.config.basePath === 'string' ? this.config.basePath : 'Sounds/';
                const audioFiles = (this.config && typeof this.config.files === 'object') ? this.config.files : {};
                const entries = Object.entries(audioFiles);
                if (entries.length === 0) {
                    console.warn('AudioManager: no audio files configured.');
                    this.initialized = true;
                    return;
                }

                this.loadingPromises = [];

                entries.forEach(([key, fileConfig]) => {
                    if (!fileConfig || !fileConfig.file) {
                        console.warn(`AudioManager: missing file config for "${key}"`);
                        return;
                    }
                    const src = `${basePath}${fileConfig.file}`;
                    const isMusic = Boolean(fileConfig.isMusic);
                    if (isMusic) {
                        this.musicKeys.add(key);
                    } else {
                        this.soundEffectKeys.add(key);
                    }
                    const audio = new Audio(src);
                    audio.volume = isMusic
                        ? (this.musicEnabled ? this.musicVolume : 0)
                        : (this.soundEffectsEnabled ? this.volume : 0);
                    audio.loop = Boolean(fileConfig.loop);
                    audio.preload = 'auto';
                    this.audios[key] = audio;

                    const loadPromise = new Promise((resolve) => {
                        const onLoad = () => {
                            console.log(`âœ“ Loaded: ${src}`);
                            audio.removeEventListener('canplaythrough', onLoad);
                            audio.removeEventListener('error', onError);
                            resolve();
                        };
                        const onError = (e) => {
                            console.warn(`âœ— Failed to load ${src}:`, e);
                            resolve();
                        };
                        audio.addEventListener('canplaythrough', onLoad);
                        audio.addEventListener('error', onError);
                        audio.load();
                    });
                    this.loadingPromises.push(loadPromise);
                });

                await Promise.all(this.loadingPromises);
                this.initialized = true;
                console.log('ðŸŽµ Audio initialized');
            }

            playSound(soundName) {
                if (!this.initialized || !this.audios[soundName]) return;
                const isMusic = this.musicKeys.has(soundName);
                const isSoundEffect = !isMusic;
                
                // Check if it's music && if music is disabled
                if (isMusic && !this.musicEnabled) return;
                if (isSoundEffect && !this.soundEffectsEnabled) return;
                
                try {
                    const audio = this.audios[soundName];
                    audio.currentTime = 0;
                    audio.volume = isMusic
                        ? (this.musicEnabled ? this.musicVolume : 0)
                        : (this.soundEffectsEnabled ? this.volume : 0);
                    // Limit concurrency for very frequent SFX
                    if (!this._playingCounts) this._playingCounts = {};
                    const key = soundName;
                    const now = Date.now();
                    if (!this._playingCounts[key]) this._playingCounts[key] = [];
                    const windowMs = this.settings.concurrencyWindowMs;
                    const maxVoicesConfig = this.settings.maxVoices || {};
                    const maxVoices = maxVoicesConfig[key] ?? maxVoicesConfig.default ?? 8;
                    // Prune finished voices
                    this._playingCounts[key] = this._playingCounts[key].filter(t => now - t < windowMs);
                    if (this._playingCounts[key].length >= maxVoices) return;
                    this._playingCounts[key].push(now);
                    audio.play().catch(e => console.warn(`Failed to play ${soundName}:`, e));
                } catch (e) {
                    console.warn(`Error playing ${soundName}:`, e);
                }
            }

            startLoopingSound(soundName) {
                if (!this.initialized || !this.audios[soundName]) return;
                const isMusic = this.musicKeys.has(soundName);
                if (isMusic && !this.musicEnabled) return;
                if (!isMusic && !this.soundEffectsEnabled) return;
                const audio = this.audios[soundName];
                audio.currentTime = 0;
                audio.volume = isMusic
                    ? (this.musicEnabled ? this.musicVolume : 0)
                    : (this.soundEffectsEnabled ? this.volume : 0);
                audio.play().catch(e => console.warn(`Failed to start looping ${soundName}:`, e));
            }

            stopLoopingSound(soundName) {
                if (!this.initialized || !this.audios[soundName]) return;
                this.audios[soundName].pause();
                this.audios[soundName].currentTime = 0;
            }

            pauseMusic() {
                if (this.initialized && this.audios.backgroundMusic) {
                    this.audios.backgroundMusic.pause();
                }
                if (this.initialized && this.audios.lobbyMusic) {
                    this.audios.lobbyMusic.pause();
                }
            }

            resumeMusic() {
                if (this.initialized && this.audios.backgroundMusic && this.musicEnabled) {
                    this.audios.backgroundMusic.play().catch(e => console.warn('Failed to resume music:', e));
                }
            }
            
            playLobbyMusic() {
                if (this.initialized && this.audios.lobbyMusic && this.musicEnabled) {
                    this.audios.lobbyMusic.play().catch(e => console.warn('Failed to play lobby music:', e));
                }
            }
            
            stopLobbyMusic() {
                if (this.initialized && this.audios.lobbyMusic) {
                    this.audios.lobbyMusic.pause();
                    this.audios.lobbyMusic.currentTime = 0;
                }
            }
            
            playGameMusic() {
                if (this.initialized && this.audios.backgroundMusic && this.musicEnabled) {
                    this.audios.backgroundMusic.play().catch(e => console.warn('Failed to play game music:', e));
                }
            }
            
            stopGameMusic() {
                if (this.initialized && this.audios.backgroundMusic) {
                    this.audios.backgroundMusic.pause();
                    this.audios.backgroundMusic.currentTime = 0;
                }
            }
            
            toggleMusic() {
                this.musicEnabled = !this.musicEnabled;
                if (this.initialized) {
                    if (this.musicEnabled) {
                        // Resume appropriate music based on current state
                        if (this.audios.lobbyMusic && !this.audios.lobbyMusic.paused) {
                            this.audios.lobbyMusic.volume = this.musicVolume;
                            this.audios.lobbyMusic.play().catch(e => console.warn('Failed to enable lobby music:', e));
                        }
                        if (this.audios.backgroundMusic && !this.audios.backgroundMusic.paused) {
                            this.audios.backgroundMusic.volume = this.musicVolume;
                            this.audios.backgroundMusic.play().catch(e => console.warn('Failed to enable game music:', e));
                        }
                    } else {
                        // Pause all music
                        if (this.audios.lobbyMusic) {
                            this.audios.lobbyMusic.pause();
                            this.audios.lobbyMusic.currentTime = 0;
                        }
                        if (this.audios.backgroundMusic) {
                            this.audios.backgroundMusic.pause();
                            this.audios.backgroundMusic.currentTime = 0;
                        }
                    }
                }
                this._persistAudioSettings();
                return this.musicEnabled;
            }

            toggleSoundEffects() {
                this.soundEffectsEnabled = !this.soundEffectsEnabled;
                if (this.initialized) {
                    Object.entries(this.audios).forEach(([key, audio]) => {
                        const isMusic = this.musicKeys.has(key);
                        if (isMusic) return;
                        if (this.soundEffectsEnabled) {
                            audio.volume = this.volume;
                        } else {
                            audio.pause();
                            audio.currentTime = 0;
                        }
                    });
                }
                this._persistAudioSettings();
                return this.soundEffectsEnabled;
            }
        }

        // Background binary effect
        class BackgroundBinary {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.baseX = x; // Store original position for parallax
                this.baseY = y;
                this.digit = Math.random() < 0.5 ? '0' : '1';
                this.opacity = 0;
                this.maxOpacity = 0.3;
                this.life = 180 + Math.random() * 120;
                this.maxLife = this.life;
                this.fadeInDuration = 30;
                this.fadeOutDuration = 60;
                this.size = 12 + Math.random() * 8;
            }

            update() {
                const t = getTimeScale();
                this.life -= t;
                if (this.life > this.maxLife - this.fadeInDuration) {
                    const fadeProgress = (this.maxLife - this.life) / this.fadeInDuration;
                    this.opacity = this.maxOpacity * fadeProgress;
                } else if (this.life < this.fadeOutDuration) {
                    this.opacity = this.maxOpacity * (this.life / this.fadeOutDuration);
                } else {
                    this.opacity = this.maxOpacity;
                }
                return this.life > 0;
            }
            
            updateParallax(playerDeltaX, playerDeltaY) {
                // Move in opposite direction to player movement for parallax effect
                this.baseX -= playerDeltaX * 0.3; // 30% parallax intensity
                this.baseY -= playerDeltaY * 0.3;
                this.x = this.baseX;
                this.y = this.baseY;
            }

            draw(ctx) {
                if (this.opacity > 0.01) {
                    ctx.save();
                    ctx.globalAlpha = this.opacity;
                    ctx.fillStyle = '#ff0000';
                    ctx.font = `${this.size}px monospace`;
                    ctx.textAlign = 'center';
                    ctx.fillText(this.digit, this.x, this.y);
                    ctx.restore();
                }
            }
        }

        // Background binary manager
        class BackgroundBinaryManager {
            constructor(canvas) {
                this.canvas = canvas;
                this.binaries = [];
                this.spawnTimer = 0;
                this.spawnDelay = 4; // Reduced from 8 to spawn twice as fast
                this.maxBinaries = 100; // Increased from 50 to double the amount
            }

            update() {
                const t = getTimeScale();
                let write = 0;
                for (let read = 0; read < this.binaries.length; read++) {
                    const bin = this.binaries[read];
                    if (bin.update()) this.binaries[write++] = bin;
                }
                this.binaries.length = write;
                this.spawnTimer += t;
                if (this.spawnTimer >= this.spawnDelay && this.binaries.length < this.maxBinaries) {
                    this.spawnBinary();
                    this.spawnTimer = 0;
                }
            }
            
            updateParallax(playerDeltaX, playerDeltaY) {
                this.binaries.forEach(binary => {
                    binary.updateParallax(playerDeltaX, playerDeltaY);
                });
            }

            spawnBinary() {
                const x = Math.random() * this.canvas.width;
                const y = Math.random() * this.canvas.height;
                this.binaries.push(new BackgroundBinary(x, y));
            }

            draw(ctx) {
                this.binaries.forEach(binary => binary.draw(ctx));
            }
        }

        // Input manager
        class InputManager {
            constructor() {
                this.keys = {};
                this.mouse = { x: 0, y: 0, down: false, middleDown: false, rightDown: false };
                this.lastActionTime = {};
            }

            preventSpam(action, delay = 100) {
                const now = Date.now();
                if (this.lastActionTime[action] && now - this.lastActionTime[action] < delay) return false;
                this.lastActionTime[action] = now;
                return true;
            }

            clear() {
                this.keys = {};
                this.mouse.down = false;
                this.mouse.middleDown = false;
                this.mouse.rightDown = false;
                this.lastActionTime = {};
            }
        }

        // Player management
        class Player {
            constructor(canvas) {
                this.canvas = canvas;
                this.x = canvas.width / 2;
                this.y = canvas.height / 2;
                this.radius = 20;
                this.speed = 5;
                this.health = 100;
                this.maxHealth = 100;
                this.damageFlash = 0;
				this.healFlash = 0;
                this.invulnerable = false;
                this.invulnerabilityTime = 0;
                this.railgunCharge = 0;
                this.railgunMaxChargeTime = 3000;
                this.blinkState = true;
                this.blinkFrame = 0;
                this.isDashing = false;
                this.dashProgress = 0;
                this.dashDuration = 10;
                this.dashDistance = 300;
                this.dashStartX = 0;
                this.dashStartY = 0;
                this.dashEndX = 0;
                this.dashEndY = 0;
                this.railgunCharging = false;
                this.railgunMaxChargeSoundPlayed = false;
				this._lastHealth = this.health;
                this.explosionAreaMultiplier = 1;
                // Visual theme for rendering: 'default' | 'cyan' | 'rainbow'
                this.theme = 'default';
            }

            startDash(keys, effects, audio) {
                if (this.isDashing) return;
                let dx = 0, dy = 0;
                if (keys.w) dy -= 1;
                if (keys.s) dy += 1;
                if (keys.a) dx -= 1;
                if (keys.d) dx += 1;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist === 0) return;
                const motion = getMotionScale();
                dx = (dx / dist) * this.dashDistance * motion;
                dy = (dy / dist) * this.dashDistance * motion;
                this.isDashing = true;
                this.invulnerable = true;
                this.dashProgress = 0;
                this.dashStartX = this.x;
                this.dashStartY = this.y;
                this.dashEndX = this.x + dx;
                this.dashEndY = this.y + dy;
                this.dashEndX = Math.max(this.radius, Math.min(this.canvas.width - this.radius, this.dashEndX));
                this.dashEndY = Math.max(this.radius, Math.min(this.canvas.height - this.radius, this.dashEndY));
                if (audio) audio.playSound('dash');
            }

            move(keys, canvas) {
                if (this.isDashing) return;
                const speedMul = this.speedMultiplier || 1;
                const motion = getMotionScale();
                let newX = this.x, newY = this.y;
                if (keys.w) newY -= this.speed * speedMul * motion;
                if (keys.s) newY += this.speed * speedMul * motion;
                if (keys.a) newX -= this.speed * speedMul * motion;
                if (keys.d) newX += this.speed * speedMul * motion;
                this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, newX));
                this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, newY));
                this.canvas = canvas;
            }

            takeDamage(damage, sourceX, sourceY, effects, audio) {
                if (this.health <= 0 || this.invulnerable) return false;
                const actualDamage = Math.min(damage, this.health);
                if (actualDamage <= 0) return false;
                this.health = Math.max(0, this.health - actualDamage);
                this.damageFlash = 20;
                this.invulnerable = true;
                this.invulnerabilityTime = 5;
                effects.createDamageLabel(sourceX || this.x, sourceY || this.y - this.radius - 15, actualDamage, true);
                if (audio) audio.playSound('playerDamage');
                if (typeof window !== 'undefined' && window.game && window.game.shakeCanvas) {
                    window.game.shakeCanvas(5, 220);
                }
                return true;
            }

            stopRailgunCharge(audio) {
                if (this.railgunCharging && audio) {
                    audio.stopLoopingSound('railgunCharge');
                    this.railgunCharging = false;
                }
                this.railgunCharge = 0;
                this.blinkState = true;
                this.blinkFrame = 0;
                this.railgunMaxChargeSoundPlayed = false;
                if (typeof window !== 'undefined' && window.game && window.game.effects && window.game.effects.disableRailgunAura) {
                    window.game.effects.disableRailgunAura();
                }
            }

            update(input, effects, canvas, audio) {
                const timeScale = getTimeScale();
                if (this.damageFlash > 0) this.damageFlash -= timeScale;
				if (this.healFlash > 0) this.healFlash -= timeScale;
                if (this.invulnerable && this.invulnerabilityTime > 0 && !this.isDashing) {
                    this.invulnerabilityTime -= timeScale;
                    if (this.invulnerabilityTime <= 0) this.invulnerable = false;
                }
                this.health = Math.max(0, Math.min(this.maxHealth, Math.floor(this.health)));

                if (this.isDashing) {
                    this.dashProgress += timeScale;
                    const t = this.dashProgress / this.dashDuration;
                    this.x = this.dashStartX + (this.dashEndX - this.dashStartX) * t;
                    this.y = this.dashStartY + (this.dashEndY - this.dashStartY) * t;
                    effects.createDashTrail(this.x, this.y, this.theme);
                    if (this.dashProgress >= this.dashDuration) {
                        this.isDashing = false;
                        this.invulnerable = false;
				// Detect positive HP changes and trigger a single green blink
				if (this.health > this._lastHealth) {
					this.healFlash = 12;
				}
				this._lastHealth = this.health;
			}
                } else if (input.mouse.rightDown) {
                    if (!this.railgunCharging && audio) {
                        audio.startLoopingSound('railgunCharge');
                        this.railgunCharging = true;
                    }
                    const chargeMul = this.railgunChargeSpeedMultiplier || 1;
                    this.railgunCharge = Math.min(1, this.railgunCharge + (chargeMul * (1000 / 60 / this.railgunMaxChargeTime)) * timeScale);
                    if (effects && effects.enableRailgunAura) { effects.enableRailgunAura(); }
                    if (this.railgunCharge === 1) {
                        // Stop charging sound && play max charge sound when fully charged (only once)
                        if (this.railgunCharging && audio) {
                            audio.stopLoopingSound('railgunCharge');
                            this.railgunCharging = false;
                        }
                        if (!this.railgunMaxChargeSoundPlayed && audio) {
                            audio.playSound('railgunChargeMax');
                            this.railgunMaxChargeSoundPlayed = true;
                        }
                        this.blinkFrame = (this.blinkFrame + timeScale) % 30;
                        this.blinkState = this.blinkFrame < 15;
                    } else {
                        this.blinkState = true;
                        this.blinkFrame = 0;
                    }
                } else if (this.railgunCharge > 0) {
                    if (this.railgunCharging && audio) {
                        audio.stopLoopingSound('railgunCharge');
                        this.railgunCharging = false;
                    }
                    // Apply bullet damage multiplier to railgun as well
                    const dmgMul = this.bulletDamageMultiplier || 1;
                    effects.createRailgunBeam(this.x, this.y, input.mouse.x, input.mouse.y, canvas, this.railgunCharge);
                    if (effects && effects.effects.length > 0) {
                        const last = effects.effects[effects.effects.length - 1];
                        if (last && last.type === 'railgunBeam') {
                            last.damage = Math.floor(last.damage * dmgMul);
                            // Visual tweak for max charge: wider and orange
                            if (this.railgunCharge === 1) {
                                last.width = Math.floor((last.width || 8) * 1.25);
                                last._isMaxCharge = true;
                            }
                        }
                    }
                    if (audio) {
                        if (this.railgunCharge === 1) audio.playSound('MaxRailgunShot');
                        else audio.playSound('railgunShoot');
                    }
                    if (effects && effects.disableRailgunAura) { effects.disableRailgunAura(); }
                    this.railgunCharge = 0;
                    this.blinkState = true;
                    this.blinkFrame = 0;
                    this.railgunMaxChargeSoundPlayed = false;
                } else if (this.railgunCharging && audio) {
                    audio.stopLoopingSound('railgunCharge');
                    this.railgunCharging = false;
                    if (effects && effects.disableRailgunAura) { effects.disableRailgunAura(); }
                }
            }

			draw(ctx) {
                // Priority effects override theme
                if (this.damageFlash > 0) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = '#ff0000';
                    ctx.fill();
                    ctx.strokeStyle = '#cc0000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                } else if (this.healFlash > 0) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = '#00ff55';
                    ctx.fill();
                    ctx.strokeStyle = '#00aa44';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                } else if (this.invulnerable) {
                    // Keep invulnerable visual as before
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = '#f0f0ff';
                    ctx.fill();
                    ctx.strokeStyle = '#a0a0ff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                } else {
                    // Apply theme visuals
                    const drawDiamond = () => {
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y - this.radius);
                        ctx.lineTo(this.x + this.radius, this.y);
                        ctx.lineTo(this.x, this.y + this.radius);
                        ctx.lineTo(this.x - this.radius, this.y);
                        ctx.closePath();
                    };
                    const drawSquare = () => {
                        ctx.beginPath();
                        ctx.rect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
                    };
                    if (this.theme === 'cyan') {
                        ctx.save();
                        ctx.shadowColor = '#00ffff';
                        ctx.shadowBlur = 22;
                        drawDiamond();
                        ctx.fillStyle = '#00faff';
                        ctx.fill();
                        ctx.lineWidth = 2;
                        ctx.strokeStyle = '#00b0d4';
                        ctx.stroke();
                        ctx.restore();
                    } else if (this.theme === 'rainbow') {
                        const r = this.radius;
                        const grad = ctx.createLinearGradient(this.x - r, this.y - r, this.x + r, this.y + r);
                        const t = (Date.now() % 12000) / 12000; // 12s slow cycle
                        const addStop = (offset) => {
                            const hue = Math.floor(((t + offset) % 1) * 360);
                            grad.addColorStop(offset, `hsl(${hue}, 100%, 60%)`);
                        };
                        addStop(0.0);
                        addStop(0.16);
                        addStop(0.33);
                        addStop(0.50);
                        addStop(0.66);
                        addStop(0.83);
                        addStop(1.0);
                        ctx.save();
                        drawSquare();
                        ctx.fillStyle = grad;
                        ctx.fill();
                        ctx.lineWidth = 2;
                        ctx.strokeStyle = '#ffffffaa';
                        ctx.stroke();
                        ctx.restore();
                    } else {
                        // default
                        ctx.save();
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                        ctx.shadowColor = 'rgba(255, 255, 255, 0.9)';
                        ctx.shadowBlur = 18;
                        ctx.fillStyle = '#ffffff';
                        ctx.fill();
                        ctx.restore();
                    }
                }

                const healthColor = this.health > 60 ? '#00ff00' : this.health > 30 ? '#ffaa00' : '#ff0000';
                ctx.fillStyle = healthColor;
                ctx.font = 'bold 20px Roboto';
                ctx.textAlign = 'center';
                ctx.fillText(`HP: ${this.health}`, this.x, this.y + this.radius + 22);

                if (this.railgunCharge > 0 && this.blinkState) {
                    const w = this.radius * 2;
                    const h = 4;
                    const isMax = this.railgunCharge >= 0.95;
                    ctx.fillStyle = isMax ? 'rgba(120, 60, 0, 0.7)' : 'rgba(0, 100, 100, 0.7)';
                    ctx.fillRect(this.x - w/2, this.y - this.radius - 10, w, h);
                    ctx.fillStyle = isMax ? 'rgba(255, 165, 0, 0.9)' : 'rgba(0, 255, 255, 0.7)';
                    ctx.fillRect(this.x - w/2, this.y - this.radius - 10, w * this.railgunCharge, h);
                }
            }
        }

        // Player bullet management
        class Bullet {
            constructor(x, y, dx, dy, damage = PLAYER_WEAPON_BASE_DAMAGE.bullet) {
                this.x = x;
                this.y = y;
                this.dx = dx;
                this.dy = dy;
                this.radius = 4;
                this.life = 100;
                this.damage = damage;
            }

            update(canvas, effects) {
                effects.createBulletTrail(this.x, this.y, '#00ffff');
                const motion = getMotionScale();
                const t = getTimeScale();
                this.x += this.dx * motion;
                this.y += this.dy * motion;
                this.life -= t;
                if (this.life <= 0) {
                    effects.createBulletExplosion(this.x, this.y, '#00ffff');
                    return false;
                }
                return this.x >= 0 && this.x <= canvas.width && this.y >= 0 && this.y <= canvas.height;
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#00ffff';
                ctx.fill();
                ctx.strokeStyle = '#00cccc';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }

        // Player rocket projectile
        class Rocket {
            constructor(x, y, dirX, dirY, damage = PLAYER_WEAPON_BASE_DAMAGE.rocket, areaMultiplier = 1) {
                this.x = x;
                this.y = y;
                const len = Math.sqrt(dirX * dirX + dirY * dirY) || 1;
                this.dirX = dirX / len;
                this.dirY = dirY / len;
                this.speed = 4;
                this.acceleration = 0.15; // gradually increases speed
                this.radius = 8; // 2x bullet
                this.life = 240; // up to ~4s
                this.damage = damage;
                this.type = 'rocket';
                this._baseAoeRadius = 100;
                const areaMul = areaMultiplier > 0 ? areaMultiplier : 1;
                this.aoeRadius = this._baseAoeRadius * Math.sqrt(areaMul);
                this.explodesOnRemove = true; // signal game to trigger AoE when removed
                this.blinkPhase = 0;
                this.blinkSpeed = 0.07; // slow blink
            }

            update(canvas, effects) {
                // Cyan trail (3x life)
                if (effects && effects.createRocketTrail) effects.createRocketTrail(this.x, this.y, '#00ffff');
                const motion = getMotionScale();
                const t = getTimeScale();
                this.speed += this.acceleration * t;
                this.x += this.dirX * this.speed * motion;
                this.y += this.dirY * this.speed * motion;
                this.life -= t;
                this.blinkPhase += this.blinkSpeed * t;
                const inside = this.x >= 0 && this.x <= canvas.width && this.y >= 0 && this.y <= canvas.height;
                if (!inside || this.life <= 0) {
                    return false; // removed -> Game will explode
                }
                return true;
            }

            draw(ctx) {
                const blink = 0.6 + 0.4 * Math.abs(Math.sin(this.blinkPhase));
                ctx.save();
                ctx.globalAlpha = blink;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#ffffff';
                ctx.fill();
                ctx.strokeStyle = '#00cccc';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.restore();
            }
        }

        // Player mine (stationary explosive)
        class Mine {
            constructor(x, y, playerRadius, damage = PLAYER_WEAPON_BASE_DAMAGE.mine, areaMultiplier = 1) {
                this.x = x;
                this.y = y;
                this.radius = Math.max(2, Math.floor((playerRadius || 20) * 0.25 * 1.15));
                this.life = 180; // ~3s
                this.damage = damage;
                this.type = 'mine';
                this._baseAoeRadius = 100; // same as rocket
                const areaMul = areaMultiplier > 0 ? areaMultiplier : 1;
                this.aoeRadius = this._baseAoeRadius * Math.sqrt(areaMul);
                this.explodesOnRemove = true; // signal game to trigger AoE when removed
                this.blinkPhase = 0;
                this.blinkSpeed = 0.25; // faster blink than rocket
            }

            update(canvas, effects) {
                const t = getTimeScale();
                this.life -= t;
                this.blinkPhase += this.blinkSpeed * t;
                return this.life > 0; // removed -> Game will explode
            }

            draw(ctx) {
                const blink = 0.55 + 0.45 * Math.abs(Math.sin(this.blinkPhase));
                ctx.save();
                ctx.globalAlpha = blink;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#00FFFF';
                ctx.fill();
                ctx.strokeStyle = '#00FFFF';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.restore();
            }
        }

        // Enemy bullet management
        class EnemyBullet {
            constructor(x, y, dx, dy, damage = 15, options = {}) {
                this.x = x;
                this.y = y;
                this.dx = dx;
                this.dy = dy;
                this.radius = options.radius != null ? options.radius : 6;
                this.life = options.life != null ? options.life : 200;
                this.damage = damage;
                this.fillColor = options.fillColor || '#FFC13B';
                this.strokeColor = options.strokeColor || this.fillColor;
                this.trailColor = options.trailColor || this.fillColor;
                this.trailLifeMultiplier = options.trailLifeMultiplier || 1;
                this.trailSizeMultiplier = options.trailSizeMultiplier || 1;
                this.trailOpacityMultiplier = options.trailOpacityMultiplier || 1;
                this.glowColor = options.glowColor || null;
            }

            update(canvas, effects) {
                if (effects && typeof effects.createBulletTrail === 'function') {
                    effects.createBulletTrail(this.x, this.y, this.trailColor, {
                        lifeMultiplier: this.trailLifeMultiplier,
                        sizeMultiplier: this.trailSizeMultiplier,
                        opacityMultiplier: this.trailOpacityMultiplier
                    });
                }
                const motion = getMotionScale();
                const t = getTimeScale();
                this.x += this.dx * motion;
                this.y += this.dy * motion;
                this.life -= t;
                if (this.life <= 0) {
                    if (effects && typeof effects.createBulletExplosion === 'function') {
                        effects.createBulletExplosion(this.x, this.y, this.trailColor);
                    }
                    return false;
                }
                return this.x >= 0 && this.x <= canvas.width && this.y >= 0 && this.y <= canvas.height;
            }

            draw(ctx) {
                ctx.save();
                if (this.glowColor) {
                    ctx.shadowColor = this.glowColor;
                    ctx.shadowBlur = this.radius * 2.2;
                }
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.fillColor;
                ctx.fill();
                ctx.strokeStyle = this.strokeColor;
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.restore();
            }
        }

        class EnemyRocket {
            constructor(x, y, targetX, targetY, damage = 25, options = {}) {
                this.x = x;
                this.y = y;
                const dx = targetX - x;
                const dy = targetY - y;
                const len = Math.sqrt(dx * dx + dy * dy) || 1;
                this.dirX = dx / len;
                this.dirY = dy / len;
                this.speed = options.initialSpeed != null ? options.initialSpeed : 4;
                this.acceleration = options.acceleration != null ? options.acceleration : 0.12;
                this.radius = options.radius != null ? options.radius : 8;
                this.life = options.life != null ? options.life : 220;
                this.damage = damage;
                this.aoeRadius = options.aoeRadius != null ? options.aoeRadius : 100;
                this.trailColor = options.trailColor || '#ff3e3e';
                this.glowColor = options.glowColor || 'rgba(255, 64, 64, 0.8)';
                this.hitPlayer = false;
            }

            update(canvas, effects, player) {
                if (effects && typeof effects.createRocketTrail === 'function') {
                    effects.createRocketTrail(this.x, this.y, this.trailColor);
                }
                const t = getTimeScale();
                const motion = getMotionScale();
                this.speed += this.acceleration * t;
                this.x += this.dirX * this.speed * motion;
                this.y += this.dirY * this.speed * motion;
                this.life -= t;
                if (player) {
                    const dx = player.x - this.x;
                    const dy = player.y - this.y;
                    const limit = player.radius + this.radius;
                    if (dx * dx + dy * dy <= limit * limit) {
                        this.hitPlayer = true;
                        return false;
                    }
                }
                const inside = this.x >= -this.radius && this.x <= canvas.width + this.radius &&
                               this.y >= -this.radius && this.y <= canvas.height + this.radius;
                if (!inside || this.life <= 0) {
                    return false;
                }
                return true;
            }

            draw(ctx) {
                ctx.save();
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#ff2e2e';
                ctx.shadowColor = this.glowColor;
                ctx.shadowBlur = this.radius * 2;
                ctx.fill();
                ctx.strokeStyle = '#c40000';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.restore();
            }
        }

        class EnemyMine {
            constructor(x, y, bossRadius, damage = 25, options = {}) {
                this.x = x;
                this.y = y;
                const baseRadius = Math.max(3, Math.floor((bossRadius || 20) * 0.3));
                this.radius = options.radius != null ? options.radius : baseRadius;
                this.life = options.life != null ? options.life : 180;
                this.damage = damage;
                this.aoeRadius = options.aoeRadius != null ? options.aoeRadius : 100;
                this.blinkPhase = 0;
                this.blinkSpeed = options.blinkSpeed != null ? options.blinkSpeed : 0.25;
                this.glowColor = options.glowColor || 'rgba(255, 60, 60, 0.9)';
                this.triggered = false;
            }

            update(canvas, effects, player) {
                const t = getTimeScale();
                this.life -= t;
                this.blinkPhase += this.blinkSpeed * t;
                if (player) {
                    const dx = player.x - this.x;
                    const dy = player.y - this.y;
                    const limit = player.radius + this.radius;
                    if (dx * dx + dy * dy <= limit * limit) {
                        this.triggered = true;
                        return false;
                    }
                }
                return this.life > 0;
            }

            draw(ctx) {
                const blink = 0.55 + 0.45 * Math.abs(Math.sin(this.blinkPhase));
                ctx.save();
                ctx.globalAlpha = blink;
                ctx.shadowColor = this.glowColor;
                ctx.shadowBlur = this.radius * 1.6;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#ff2e2e';
                ctx.fill();
                ctx.strokeStyle = '#c40000';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.restore();
            }
        }

        function getFirstBossOverride() {
            const candidate = BOSS_SELECTION.firstBossKey;
            if (typeof candidate === 'string') {
                const trimmed = candidate.trim();
                if (trimmed.length > 0) {
                    return trimmed;
                }
            }
            return null;
        }

        function getBossDisplayName(bossKey) {
            if (!bossKey) return '';
            const mapped = BOSS_NAME_MAP[bossKey];
            if (mapped) return mapped;
            if (typeof ENEMY_TYPES !== 'undefined' && ENEMY_TYPES && ENEMY_TYPES[bossKey] && ENEMY_TYPES[bossKey].displayName) {
                return ENEMY_TYPES[bossKey].displayName;
            }
            const normalized = String(bossKey);
            return normalized.replace(/_/g, ' ').toUpperCase();
        }

        const BOSS_SPAWN_SOUND_MAP = Object.freeze({
            rhombus_boss: 'bossSpawnRhomboss',
            player_2_boss: 'bossSpawnPlayerTwo',
            tetris_cross_boss: 'bossSpawnTetris',
			ping_and_pong_boss: 'bossSpawnPingAndPong',
            vector_snake_boss: 'bossSpawnVectorSnake'
        });

        function shuffleArray(arr) {
            const a = arr.slice();
            for (let i = a.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                const tmp = a[i];
                a[i] = a[j];
                a[j] = tmp;
            }
            return a;
        }

        // XP / Level configuration is defined in player-config.js

        // Shape renderer utility
        class ShapeRenderer {
            static drawShape(ctx, x, y, type, size, fillColor, strokeColor, options = {}) {
                const { killerGlowAlpha } = options || {};
                ctx.save();
                ctx.fillStyle = fillColor;
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = 2;
                if (type === 'square' || type === 'dash_square') {
                    const s = size * 1.4;
                    if (type === 'dash_square') {
                        ctx.shadowColor = 'rgba(255, 0, 0, 0.7)';
                        ctx.shadowBlur = size * 1.1;
                        ctx.lineWidth = 3;
                    } else {
                        ctx.shadowColor = 'transparent';
                        ctx.shadowBlur = 0;
                    }
                    ctx.fillRect(x - s/2, y - s/2, s, s);
                    ctx.strokeRect(x - s/2, y - s/2, s, s);
            } else if (type === 'triangle' || type === 'killer_triangle') {
                const isKiller = type === 'killer_triangle';
                if (isKiller) {
                    const fallbackAlpha = 0.75 * 0.5;
                    const alpha = typeof killerGlowAlpha === 'number'
                        ? Math.max(0, Math.min(1, killerGlowAlpha))
                        : fallbackAlpha;
                    ctx.shadowColor = `rgba(255, 56, 72, ${alpha})`;
                    ctx.shadowBlur = size * 1.6;
                    ctx.lineWidth = 3;
                } else {
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                    ctx.lineWidth = 2;
                }
                    ctx.beginPath();
                    const h = size * 1.5;
                    ctx.moveTo(x, y - h);
                    ctx.lineTo(x - h * 0.866, y + h * 0.5);
                    ctx.lineTo(x + h * 0.866, y + h * 0.5);
                    ctx.closePath();
                if (isKiller) {
                    const gradient = ctx.createLinearGradient(x, y - h, x, y + h);
                    gradient.addColorStop(0, '#ff5f78');
                    gradient.addColorStop(1, ctx.fillStyle || '#ff2448');
                    ctx.fillStyle = gradient;
                    ctx.strokeStyle = ctx.strokeStyle || '#ff889a';
                }
                    ctx.fill();
                    ctx.stroke();
                } else if (type === 'rhombus' || type === 'rhombus_boss') {
                    ctx.beginPath();
                    ctx.moveTo(x, y - size);
                    ctx.lineTo(x + size, y);
                    ctx.lineTo(x, y + size);
                    ctx.lineTo(x - size, y);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                } else if (type === 'octagon' || type === 'super_octagon') {
                    const sides = 8;
                    if (type === 'super_octagon') {
                        ctx.shadowColor = 'rgba(255, 40, 0, 0.75)';
                        ctx.shadowBlur = size * 0.75;
                        ctx.lineWidth = 4;
                    } else {
                        ctx.shadowColor = 'transparent';
                        ctx.shadowBlur = 0;
                    }
                    ctx.beginPath();
                    for (let i = 0; i < sides; i++) {
                        const angle = (Math.PI * 2 * i) / sides;
                        const px = x + size * Math.cos(angle);
                        const py = y + size * Math.sin(angle);
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }
                ctx.restore();
            }
        }

        // Spatial hash for broad-phase collision culling
        class SpatialHash {
            constructor(cellSize) {
                this.cellSize = cellSize;
                this.buckets = new Map();
            }

            clear() { this.buckets.clear(); }

            _key(col, row) { return col + ',' + row; }

            _range(minX, minY, maxX, maxY) {
                const cs = this.cellSize;
                const c0 = Math.floor(minX / cs), r0 = Math.floor(minY / cs);
                const c1 = Math.floor(maxX / cs), r1 = Math.floor(maxY / cs);
                return { c0, r0, c1, r1 };
            }

            insert(item, minX, minY, maxX, maxY) {
                const { c0, r0, c1, r1 } = this._range(minX, minY, maxX, maxY);
                for (let r = r0; r <= r1; r++) {
                    for (let c = c0; c <= c1; c++) {
                        const k = this._key(c, r);
                        let arr = this.buckets.get(k);
                        if (!arr) { arr = []; this.buckets.set(k, arr); }
                        arr.push(item);
                    }
                }
            }

            queryAABB(minX, minY, maxX, maxY) {
                const { c0, r0, c1, r1 } = this._range(minX, minY, maxX, maxY);
                const results = new Set();
                for (let r = r0; r <= r1; r++) {
                    for (let c = c0; c <= c1; c++) {
                        const k = this._key(c, r);
                        const arr = this.buckets.get(k);
                        if (arr) {
                            for (let i = 0; i < arr.length; i++) results.add(arr[i]);
                        }
                    }
                }
                return Array.from(results);
            }
        }

        // Effect base class
        class Effect {
            constructor(type, x, y, config) {
                this.type = type;
                this.x = x;
                this.y = y;
                Object.assign(this, config);
            }

            update(...args) {
                return this.typeSpecificUpdate(...args);
            }

            draw(ctx) {
                this.typeSpecificDraw(ctx);
            }
        }

        // Effects manager
        class EffectsManager {
            constructor() {
                this.effects = [];
                this.playerX = 0;
                this.playerY = 0;
                this.railgunAuraEffect = null;
            }

            enableRailgunAura() {
                if (this.railgunAuraEffect) return;
                const aura = new Effect('railgunAura', this.playerX, this.playerY, {
                    particleCount: 8,
                    angle: 0,
                    rotationSpeed: 0.12,
                    baseRadius: 30,
                    radiusOffset: 6,
                    baseSize: 2.5,
                    maxOpacityBase: 0.5,
                    typeSpecificUpdate: function(playerX, playerY) {
                        this.x = playerX;
                        this.y = playerY;
                        this.angle += this.rotationSpeed * getTimeScale();
                        this.renderRadius = (this.baseRadius || 25) + this.radiusOffset;
                        const charge = (typeof window !== 'undefined' && window.game && window.game.player) ? (window.game.player.railgunCharge || 0) : 0;
                        const fade = Math.max(0, 1 - Math.min(1, charge));
                        this.currentMaxOpacity = (this.maxOpacityBase || 0.5) * fade;
                        return true;
                    },
                    typeSpecificDraw: function(ctx) {
                        const step = Math.PI * 2 / this.particleCount;
                        const charge = (typeof window !== 'undefined' && window.game && window.game.player) ? (window.game.player.railgunCharge || 0) : 0;
                        const color = (charge >= 0.95) ? '#ffa500' : '#00ffff';
                        for (let i = 0; i < this.particleCount; i++) {
                            const a = this.angle + i * step;
                            const px = this.x + Math.cos(a) * this.renderRadius;
                            const py = this.y + Math.sin(a) * this.renderRadius;
                            ctx.save();
                            ctx.globalAlpha = this.currentMaxOpacity != null ? this.currentMaxOpacity : (this.maxOpacityBase || 0.5);
                            ctx.fillStyle = color;
                            ctx.beginPath();
                            ctx.arc(px, py, this.baseSize, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();
                        }
                    }
                });
                this.effects.push(aura);
                this.railgunAuraEffect = aura;
            }

            disableRailgunAura() {
                if (!this.railgunAuraEffect) return;
                const idx = this.effects.indexOf(this.railgunAuraEffect);
                if (idx !== -1) this.effects.splice(idx, 1);
                this.railgunAuraEffect = null;
            }

            createBulletTrail(x, y, color, options = {}) {
                const lifeMultiplier = Math.max(0.1, options.lifeMultiplier || 1);
                const sizeMultiplier = options.sizeMultiplier || 1;
                const opacityMultiplier = options.opacityMultiplier || 1;
                const shrinkFactor = options.shrinkFactor || 0.95;
                const baseSize = options.baseSize || 5;
                const baseLife = options.baseLife || 6;
                const maxLife = baseLife * lifeMultiplier;
                const baseOpacity = 0.5 * opacityMultiplier;
                this.effects.push(new Effect('bulletTrail', x, y, {
                    size: baseSize * sizeMultiplier,
                    baseOpacity,
                    opacity: baseOpacity,
                    life: maxLife,
                    maxLife,
                    color,
                    shrinkFactor,
                    typeSpecificUpdate: function() {
                        const t = getTimeScale();
                        this.life -= t;
                        this.opacity = this.baseOpacity * Math.max(0, this.life / this.maxLife);
                        this.size *= Math.pow(this.shrinkFactor, t);
                        return this.life > 0;
                    },
                    typeSpecificDraw: function(ctx) {
                        ctx.save();
                        ctx.globalAlpha = this.opacity;
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                }));
            }

            createBulletExplosion(x, y, color) {
                this.effects.push(new Effect('bulletExplosion', x, y, {
                    size: 8,
                    opacity: 0.8,
                    life: 20,
                    maxLife: 20,
                    color,
                    typeSpecificUpdate: function() {
                        const t = getTimeScale();
                        this.life -= t;
                        this.opacity = this.life / this.maxLife;
                        this.size += 0.5 * getMotionScale();
                        return this.life > 0;
                    },
                    typeSpecificDraw: function(ctx) {
                        ctx.save();
                        ctx.globalAlpha = this.opacity;
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                }));
            }

            createRocketTrail(x, y, color) {
                this.effects.push(new Effect('rocketTrail', x, y, {
                    size: 6,
                    opacity: 0.7,
                    life: 18, // 3x longer than bullet trail
                    color,
                    typeSpecificUpdate: function() {
                        const t = getTimeScale();
                        this.life -= t;
                        this.opacity = this.life / 18;
                        this.size *= Math.pow(0.97, t);
                        return this.life > 0;
                    },
                    typeSpecificDraw: function(ctx) {
                        ctx.save();
                        ctx.globalAlpha = this.opacity;
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                }));
            }

            createRocketExplosionRing(x, y, maxRadius) {
                this.effects.push(new Effect('rocketExplosionRing', x, y, {
                    radius: 0,
                    maxRadius,
                    life: 30,
                    maxLife: 30,
                    typeSpecificUpdate: function() {
                        const t = getTimeScale();
                        this.life -= t;
                        const k = 1 - (this.life / this.maxLife);
                        this.radius = this.maxRadius * k;
                        return this.life > 0;
                    },
                    typeSpecificDraw: function(ctx) {
                        const alpha = Math.max(0, this.life / this.maxLife);
                        ctx.save();
                        ctx.globalAlpha = alpha;
                        ctx.strokeStyle = '#00ffff';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.restore();
                    }
                }));
            }

        createEnemyRocketExplosionRing(x, y, maxRadius) {
            this.effects.push(new Effect('enemyRocketExplosionRing', x, y, {
                radius: 0,
                maxRadius,
                life: 30,
                maxLife: 30,
                typeSpecificUpdate: function() {
                    const t = getTimeScale();
                    this.life -= t;
                    const k = 1 - (this.life / this.maxLife);
                    this.radius = this.maxRadius * k;
                    return this.life > 0;
                },
                typeSpecificDraw: function(ctx) {
                    const alpha = Math.max(0, this.life / this.maxLife);
                    ctx.save();
                    ctx.globalAlpha = alpha;
                    ctx.strokeStyle = '#ff2e2e';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
            }));
        }

            createKillerTriangleDetonation(x, y, maxRadius) {
                const radius = Math.max(40, maxRadius || 300);
                const totalLife = 48;
                this.effects.push(new Effect('killerTriangleNova', x, y, {
                    maxRadius: radius,
                    innerRadius: 0,
                    outerRadius: 0,
                    life: totalLife,
                    maxLife: totalLife,
                    typeSpecificUpdate: function() {
                        const t = getTimeScale();
                        this.life -= t;
                        const progress = 1 - (this.life / this.maxLife);
                        const eased = 1 - Math.pow(1 - progress, 2);
                        this.outerRadius = this.maxRadius * Math.min(1, 0.15 + eased * 0.95);
                        this.innerRadius = this.outerRadius * Math.min(0.85, eased * 0.55);
                        this.opacity = Math.max(0, 1 - progress * 0.8);
                        return this.life > 0;
                    },
                    typeSpecificDraw: function(ctx) {
                        if (!ctx) return;
                        ctx.save();
                        ctx.globalAlpha = Math.max(0, Math.min(1, this.opacity));
                        const gradient = ctx.createRadialGradient(
                            this.x, this.y, this.innerRadius || 0,
                            this.x, this.y, this.outerRadius || this.maxRadius
                        );
                        gradient.addColorStop(0, 'rgba(255, 105, 132, 0.55)');
                        gradient.addColorStop(0.55, 'rgba(255, 50, 70, 0.35)');
                        gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.outerRadius || this.maxRadius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                }));
                this.effects.push(new Effect('killerTriangleShockwave', x, y, {
                    maxRadius: radius,
                    radius: 0,
                    life: totalLife,
                    maxLife: totalLife,
                    typeSpecificUpdate: function() {
                        const t = getTimeScale();
                        this.life -= t;
                        const progress = 1 - (this.life / this.maxLife);
                        this.radius = this.maxRadius * Math.pow(Math.min(1, progress), 0.92);
                        this.lineWidth = 6 - 3.5 * progress;
                        this.opacity = Math.max(0, 0.95 - progress * 0.65);
                        return this.life > 0;
                    },
                    typeSpecificDraw: function(ctx) {
                        if (!ctx) return;
                        ctx.save();
                        ctx.globalAlpha = Math.max(0, Math.min(1, this.opacity));
                        ctx.strokeStyle = '#ff4664';
                        ctx.lineWidth = Math.max(1.5, this.lineWidth || 3);
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius || 0, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.restore();
                    }
                }));
                for (let i = 0; i < 18; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 3.6 + Math.random() * 3.4;
                    this.effects.push(new Effect('killerTriangleShard', x, y, {
                        size: 4 + Math.random() * 3,
                        maxSize: 4 + Math.random() * 3,
                        color: '#ff3b58',
                        dx: Math.cos(angle) * speed,
                        dy: Math.sin(angle) * speed,
                        life: 32,
                        maxLife: 32,
                        typeSpecificUpdate: function() {
                            const motion = getMotionScale();
                            const t = getTimeScale();
                            this.x += this.dx * motion;
                            this.y += this.dy * motion;
                            this.dx *= Math.pow(0.92, t);
                            this.dy *= Math.pow(0.92, t);
                            this.life -= t;
                            this.opacity = Math.max(0, this.life / this.maxLife);
                            this.size = this.maxSize * Math.pow(0.97, this.maxLife - this.life);
                            return this.life > 0;
                        },
                        typeSpecificDraw: function(ctx) {
                            ctx.save();
                            ctx.globalAlpha = Math.max(0, this.opacity);
                            ctx.fillStyle = this.color;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, Math.max(0.5, this.size), 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();
                        }
                    }));
                }
            }

            createSnakeAppleBlast(x, y, maxRadius) {
                const radius = Math.max(20, maxRadius || 100);
                this.effects.push(new Effect('snakeAppleBlast', x, y, {
                    radius: 0,
                    fillRadius: 0,
                    maxRadius: radius,
                    life: 28,
                    maxLife: 28,
                    typeSpecificUpdate: function() {
                        const t = getTimeScale();
                        this.life -= t;
                        const progress = 1 - (this.life / this.maxLife);
                        const eased = 1 - Math.pow(1 - progress, 2);
                        this.radius = this.maxRadius * eased;
                        this.fillRadius = this.maxRadius * Math.min(1, progress * 1.15);
                        return this.life > 0;
                    },
                    typeSpecificDraw: function(ctx) {
                        if (!ctx) return;
                        const alpha = Math.max(0, this.life / this.maxLife);
                        ctx.save();
                        ctx.globalAlpha = 0.4 * alpha;
                        ctx.fillStyle = '#ff2244';
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.fillRadius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 0.9 * alpha;
                        ctx.strokeStyle = '#ff5566';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.restore();
                    }
                }));
            }

            createHitEffect(x, y) {
                for (let i = 0; i < 8; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 1 + Math.random() * 2;
                    this.effects.push(new Effect('hitEffect', x, y, {
                        size: 2 + Math.random() * 2,
                        opacity: 1,
                        life: 15 + Math.random() * 10,
                        dx: Math.cos(angle) * speed,
                        dy: Math.sin(angle) * speed,
                        typeSpecificUpdate: function() {
                            const motion = getMotionScale();
                            const t = getTimeScale();
                            this.x += this.dx * motion;
                            this.y += this.dy * motion;
                            this.dx *= Math.pow(0.9, t);
                            this.dy *= Math.pow(0.9, t);
                            this.life -= t;
                            this.opacity = this.life / 25;
                            this.size *= Math.pow(0.98, t);
                            return this.life > 0;
                        },
                        typeSpecificDraw: function(ctx) {
                            ctx.save();
                            ctx.globalAlpha = this.opacity;
                            ctx.fillStyle = '#00ffff';
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();
                        }
                    }));
                }
            }

            createShieldImpact(x, y, radius, damageType = 'generic') {
                const clampedRadius = Math.max(20, radius || 40);
                const ringLife = 20;
                this.effects.push(new Effect('shieldImpact', x, y, {
                    life: ringLife,
                    maxLife: ringLife,
                    startRadius: clampedRadius * 0.65,
                    endRadius: clampedRadius,
                    strokeColor: damageType === 'railgun' ? '#ffd966' : '#ffb347',
                    fillColor: damageType === 'railgun' ? 'rgba(255, 220, 120, 0.22)' : 'rgba(255, 170, 80, 0.22)',
                    typeSpecificUpdate: function() {
                        const t = getTimeScale();
                        this.life -= t;
                        const progress = 1 - Math.max(0, this.life / this.maxLife);
                        this.renderRadius = this.startRadius + (this.endRadius - this.startRadius) * progress;
                        this.opacity = Math.max(0, 1 - progress);
                        return this.life > 0;
                    },
                    typeSpecificDraw: function(ctx) {
                        ctx.save();
                        ctx.globalAlpha = this.opacity * 0.6;
                        ctx.fillStyle = this.fillColor;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.renderRadius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = this.opacity;
                        ctx.strokeStyle = this.strokeColor;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.renderRadius, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.restore();
                    }
                }));
                for (let i = 0; i < 6; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 2.5 + Math.random() * 2.5;
                    this.effects.push(new Effect('shieldSpark', x, y, {
                        life: 18,
                        maxLife: 18,
                        dx: Math.cos(angle) * speed,
                        dy: Math.sin(angle) * speed,
                        color: damageType === 'railgun' ? '#ffe27a' : '#ff9124',
                        size: 3 + Math.random() * 2,
                        typeSpecificUpdate: function() {
                            const motion = getMotionScale();
                            const t = getTimeScale();
                            this.x += this.dx * motion;
                            this.y += this.dy * motion;
                            this.dx *= Math.pow(0.9, t);
                            this.dy *= Math.pow(0.9, t);
                            this.life -= t;
                            this.opacity = Math.max(0, this.life / this.maxLife);
                            return this.life > 0;
                        },
                        typeSpecificDraw: function(ctx) {
                            ctx.save();
                            ctx.globalAlpha = this.opacity;
                            ctx.fillStyle = this.color;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();
                        }
                    }));
                }
            }

            createDamageLabel(x, y, damage, isPlayerDamage) {
                if (isPlayerDamage) {
                    this.effects = this.effects.filter(e => e.type !== 'damageLabel' || e.life > 20);
                }
                this.effects.push(new Effect('damageLabel', x, y, {
                    damage: Math.floor(damage),
                    dx: isPlayerDamage ? (Math.random() - 0.5) * 4 : 0,
                    dy: isPlayerDamage ? -2 - Math.random() * 1.5 : -0.5,
                    gravity: isPlayerDamage ? 0 : 0,
                    opacity: 1.0,
                    life: isPlayerDamage ? 50 : 90,
                    maxLife: isPlayerDamage ? 50 : 90,
                    scale: 0.8,
                    isPlayerDamage,
                    typeSpecificUpdate: function() {
                        const motion = getMotionScale();
                        const t = getTimeScale();
                        this.x += this.dx * motion;
                        this.y += this.dy * motion;
                        this.dy += this.gravity * t;
                        this.dx *= Math.pow(0.99, t);
                        this.life -= t;
                        this.opacity = Math.max(0, this.life / this.maxLife);
                        this.scale = 1.0 + (1 - this.opacity) * 0.2;
                        return this.life > 0;
                    },
                    typeSpecificDraw: function(ctx) {
                        if (this.opacity > 0.01 && !isNaN(this.damage)) {
                            ctx.save();
                            ctx.globalAlpha = this.opacity;
                            const fontSize = Math.floor(24 * this.scale);
                            ctx.font = `bold ${fontSize}px Roboto`;
                            ctx.textAlign = 'center';
                            ctx.strokeStyle = '#000000';
                            ctx.lineWidth = 3;
                            ctx.fillStyle = this.isPlayerDamage ? '#ff0000' : '#00ffff';
                            const text = `-${this.damage}`;
                            ctx.strokeText(text, this.x, this.y);
                            ctx.fillText(text, this.x, this.y);
                            ctx.restore();
                        }
                    }
                }));
            }

            createExplosion(x, y, type, size) {
                const config = ENEMY_TYPES[type] || {};
                const fallbackType = type || 'square';
                const fillColor = config.fillColor || '#ff5555';
                const strokeColor = config.strokeColor || '#cc2222';
                const count = 3 + Math.floor(Math.random() * 3);
                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 2 + Math.random() * 3;
                    this.effects.push(new Effect('explosion', x, y, {
                        size: size * (0.3 + Math.random() * 0.2),
                        opacity: 1,
                        life: 30 + Math.random() * 20,
                        dx: Math.cos(angle) * speed,
                        dy: Math.sin(angle) * speed,
                        fillColor,
                        strokeColor,
                        shapeType: config.shapeType || fallbackType,
                        typeSpecificUpdate: function() {
                            const motion = getMotionScale();
                            const t = getTimeScale();
                            this.x += this.dx * motion;
                            this.y += this.dy * motion;
                            this.dx *= Math.pow(0.95, t);
                            this.dy *= Math.pow(0.95, t);
                            this.life -= t;
                            this.opacity = this.life / 50;
                            return this.life > 0;
                        },
                        typeSpecificDraw: function(ctx) {
                            ctx.save();
                            ctx.globalAlpha = this.opacity;
                            ShapeRenderer.drawShape(ctx, this.x, this.y, this.shapeType, this.size, this.fillColor, this.strokeColor);
                            ctx.restore();
                        }
                    }));
                }
            }

            createTriangleTrail(x, y, size, opacity, fillColor, options = {}) {
                const life = Math.max(1, Math.floor(options.life || 60));
                const shrinkFactor = typeof options.shrinkFactor === 'number' ? options.shrinkFactor : 0.98;
                const fadeExponent = typeof options.fadeExponent === 'number' ? options.fadeExponent : 1;
                const glowColor = options.glowColor || null;
                const glowOpacity = typeof options.glowOpacity === 'number' ? Math.max(0, Math.min(1, options.glowOpacity)) : 0.45;
                this.effects.push(new Effect('triangleTrail', x, y, {
                    baseSize: size,
                    size,
                    baseOpacity: opacity,
                    opacity,
                    fillColor,
                    life,
                    maxLife: life,
                    shrinkFactor,
                    fadeExponent,
                    glowColor,
                    glowOpacity,
                    typeSpecificUpdate: function() {
                        const t = getTimeScale();
                        this.life -= t;
                        const normalized = Math.max(0, this.life / this.maxLife);
                        this.opacity = this.baseOpacity * Math.pow(normalized, this.fadeExponent);
                        const elapsed = this.maxLife - this.life;
                        this.size = this.baseSize * Math.pow(this.shrinkFactor, elapsed);
                        return this.life > 0;
                    },
                    typeSpecificDraw: function(ctx) {
                        if (!ctx) return;
                        ctx.save();
                        if (this.glowColor) {
                            const alpha = Math.max(0, Math.min(1, this.opacity * this.glowOpacity));
                            if (alpha > 0.001) {
                                ctx.globalAlpha = alpha;
                                ctx.fillStyle = this.glowColor;
                                ctx.beginPath();
                                ctx.arc(this.x, this.y, this.size * 1.35, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        }
                        ctx.globalAlpha = Math.max(0, Math.min(1, this.opacity));
                        ctx.fillStyle = this.fillColor;
                        ctx.beginPath();
                        const h = this.size * 1.5;
                        ctx.moveTo(this.x, this.y - h);
                        ctx.lineTo(this.x - h * 0.866, this.y + h * 0.5);
                        ctx.lineTo(this.x + h * 0.866, this.y + h * 0.5);
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    }
                }));
            }

            createRailgunBeam(startX, startY, targetX, targetY, canvas, charge) {
                if (!isFinite(startX) || !isFinite(startY) || !isFinite(targetX) || !isFinite(targetY)) {
                    return;
                }
                const dx = targetX - startX;
                const dy = targetY - startY;
                const invLen = 1 / (Math.sqrt(dx * dx + dy * dy) || 1);
                const maxDist = Math.max(canvas.width, canvas.height) * 2;
                const damageMultiplier = (typeof window !== 'undefined' && window.game && window.game.player)
                    ? (window.game.player.bulletDamageMultiplier || 1)
                    : 1;
                const railgunMinDamage = PLAYER_WEAPON_BASE_DAMAGE.railgunMin;
                const railgunMaxDamage = PLAYER_WEAPON_BASE_DAMAGE.railgunMax;
                const chargeThreshold = 0.05;
                const baseRailgunDamage = charge <= chargeThreshold
                    ? railgunMinDamage
                    : railgunMinDamage + (railgunMaxDamage - railgunMinDamage) * (charge - chargeThreshold) / (1 - chargeThreshold);
                this.effects.push(new Effect('railgunBeam', startX, startY, {
                    endX: startX + (dx * invLen) * maxDist,
                    endY: startY + (dy * invLen) * maxDist,
                    charge: charge,
                    _isMaxCharge: charge >= 0.95,
                    damage: baseRailgunDamage * damageMultiplier,
                    life: 60,
                    maxLife: 60,
                    opacity: 1.0,
                    width: 8,
                    hitEnemies: new Set(),
                    hitTetrominoIds: new Set(),
                    _segDx: dx * invLen,
                    _segDy: dy * invLen,
                    typeSpecificUpdate: function() {
                        const t = getTimeScale();
                        this.life -= t;
                        this.opacity = this.life / this.maxLife;
                        return this.life > 0;
                    },
                    typeSpecificDraw: function(ctx) {
                        if (!isFinite(this.x) || !isFinite(this.y) || !isFinite(this.endX) || !isFinite(this.endY)) {
                            return;
                        }
                        ctx.save();
                        ctx.globalAlpha = this.opacity;
                        if (!this._gradient) {
                            const g = ctx.createLinearGradient(this.x, this.y, this.endX, this.endY);
                            if (this._isMaxCharge) {
                                g.addColorStop(0, 'rgba(255, 165, 0, 0.2)');
                                g.addColorStop(0.5, 'rgba(255, 165, 0, 1)');
                                g.addColorStop(1, 'rgba(255, 165, 0, 0.2)');
                            } else {
                                g.addColorStop(0, 'rgba(0, 255, 255, 0.2)');
                                g.addColorStop(0.5, 'rgba(0, 255, 255, 1)');
                                g.addColorStop(1, 'rgba(0, 255, 255, 0.2)');
                            }
                            this._gradient = g;
                        }
                        ctx.strokeStyle = this._gradient;
                        ctx.lineWidth = this.width;
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y);
                        ctx.lineTo(this.endX, this.endY);
                        ctx.stroke();
                        ctx.restore();
                    },
                    intersectsEnemy: function(enemy) {
                        if (this.hitEnemies.has(enemy)) return false;
                        const dx = this.endX - this.x;
                        const dy = this.endY - this.y;
                        const segLen2 = dx*dx + dy*dy;
                        const t = ((enemy.x - this.x) * dx + (enemy.y - this.y) * dy) / segLen2;
                        if (t < 0 || t > 1) return false;
                        const cx = this.x + t * dx;
                        const cy = this.y + t * dy;
                        const ddx = enemy.x - cx;
                        const ddy = enemy.y - cy;
                        const r2 = enemy.radius * enemy.radius;
                        if (ddx*ddx + ddy*ddy <= r2) {
                            this.hitEnemies.add(enemy);
                            return true;
                        }
                        return false;
                    },
                    intersectsCircle: function(cx, cy, radius, id) {
                        if (id != null && this.hitTetrominoIds.has(id)) return false;
                        const dx = this.endX - this.x;
                        const dy = this.endY - this.y;
                        const segLen2 = dx*dx + dy*dy;
                        const t = ((cx - this.x) * dx + (cy - this.y) * dy) / segLen2;
                        if (t < 0 || t > 1) return false;
                        const px = this.x + t * dx;
                        const py = this.y + t * dy;
                        const ddx = cx - px;
                        const ddy = cy - py;
                        if (ddx*ddx + ddy*ddy <= radius*radius) {
                            if (id != null) this.hitTetrominoIds.add(id);
                            return true;
                        }
                        return false;
                    }
                }));
            }

            createDashTrail(x, y, theme = 'default') {
                const maxLife = 48;
                const baseSize = 26;
                const endSize = 10;
                const startHue = Math.random() * 360;
                this.effects.push(new Effect('dashTrail', x, y, {
                    theme,
                    life: maxLife,
                    maxLife,
                    size: baseSize,
                    baseSize,
                    endSize,
                    opacity: 1,
                    startHue,
                    currentHue: startHue,
                    typeSpecificUpdate: function() {
                        const t = getTimeScale();
                        this.life -= t;
                        const normalized = Math.max(0, this.life / this.maxLife);
                        this.opacity = Math.pow(normalized, 0.75);
                        this.size = this.endSize + (this.baseSize - this.endSize) * normalized;
                        if (this.theme === 'rainbow') {
                            const paletteShift = (1 - normalized) * 240;
                            this.currentHue = (this.startHue + paletteShift) % 360;
                        }
                        return this.life > 0;
                    },
                    typeSpecificDraw: function(ctx) {
                        ctx.save();
                        let fillStyle;
                        if (this.theme === 'cyan') {
                            ctx.shadowColor = 'rgba(0, 255, 255, 0.8)';
                            ctx.shadowBlur = this.size * 0.8;
                            const grad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
                            grad.addColorStop(0, 'rgba(0, 255, 255, 0.9)');
                            grad.addColorStop(0.55, 'rgba(0, 200, 255, 0.45)');
                            grad.addColorStop(1, 'rgba(0, 140, 255, 0)');
                            fillStyle = grad;
                        } else if (this.theme === 'rainbow') {
                            const hue = this.currentHue || this.startHue || 0;
                            ctx.shadowColor = 'rgba(255, 255, 255, 0.6)';
                            ctx.shadowBlur = this.size * 0.6;
                            const grad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
                            grad.addColorStop(0, `hsla(${hue}, 100%, 68%, 0.9)`);
                            grad.addColorStop(0.4, `hsla(${(hue + 60) % 360}, 100%, 60%, 0.7)`);
                            grad.addColorStop(0.8, `hsla(${(hue + 140) % 360}, 100%, 55%, 0.5)`);
                            grad.addColorStop(1, `hsla(${(hue + 180) % 360}, 100%, 50%, 0)`);
                            fillStyle = grad;
                        } else {
                            ctx.shadowColor = 'rgba(255, 255, 255, 0.4)';
                            ctx.shadowBlur = this.size * 0.5;
                            const grad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
                            grad.addColorStop(0, 'rgba(255, 255, 255, 0.85)');
                            grad.addColorStop(0.6, 'rgba(200, 200, 255, 0.35)');
                            grad.addColorStop(1, 'rgba(140, 140, 200, 0)');
                            fillStyle = grad;
                        }
                        ctx.fillStyle = fillStyle;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                }));
            }

            createEnemyDashEffect(startX, startY, endX, endY) {
                const dx = endX - startX;
                const dy = endY - startY;
                const length = Math.sqrt(dx * dx + dy * dy) || 1;
                const normalX = -dy / length;
                const normalY = dx / length;
                this.effects.push(new Effect('enemyDashEffect', startX, startY, {
                    endX,
                    endY,
                    normalX,
                    normalY,
                    sparkCount: Math.max(3, Math.floor(length / 20)),
                    life: 24,
                    maxLife: 24,
                    typeSpecificUpdate: function() {
                        const t = getTimeScale();
                        this.life -= t;
                        return this.life > 0;
                    },
                    typeSpecificDraw: function(ctx) {
                        if (!ctx) return;
                        const progress = Math.max(0, this.life / this.maxLife);
                        ctx.save();
                        ctx.globalAlpha = Math.pow(progress, 0.7);
                        const grad = ctx.createLinearGradient(this.x, this.y, this.endX, this.endY);
                        grad.addColorStop(0, 'rgba(255, 60, 60, 0)');
                        grad.addColorStop(0.5, 'rgba(255, 0, 0, 0.9)');
                        grad.addColorStop(1, 'rgba(255, 60, 60, 0)');
                        ctx.strokeStyle = grad;
                        ctx.shadowColor = 'rgba(255, 0, 0, 0.65)';
                        ctx.shadowBlur = 18 * progress;
                        ctx.lineWidth = 6;
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y);
                        ctx.lineTo(this.endX, this.endY);
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                        ctx.globalAlpha = Math.pow(progress, 1.2);
                        ctx.fillStyle = 'rgba(255, 120, 120, 0.4)';
                        const sparkStep = 1 / Math.max(1, this.sparkCount - 1);
                        for (let i = 0; i < this.sparkCount; i++) {
                            const tPos = i * sparkStep;
                            const sx = this.x + dx * tPos;
                            const sy = this.y + dy * tPos;
                            const offset = (Math.random() - 0.5) * 8 * progress;
                            ctx.beginPath();
                            ctx.arc(sx + this.normalX * offset, sy + this.normalY * offset, 3 + 2 * progress, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.restore();
                    }
                }));
            }

            createRhombusEffect(x, y, isBecomingInvul) {
                const particles = [];
                const particleCount = 12;
                for (let i = 0; i < particleCount; i++) {
                    const angle = (Math.PI * 2 * i) / particleCount;
                    const speed = 3 + Math.random() * 2;
                    particles.push({
                        x,
                        y,
                        dx: Math.cos(angle) * speed,
                        dy: Math.sin(angle) * speed,
                        size: 3 + Math.random() * 3,
                        opacity: 1,
                        life: 30
                    });
                }
                this.effects.push(new Effect('rhombusEffect', x, y, {
                    shockwaveRadius: 0,
                    shockwaveMaxRadius: 80,
                    life: 30,
                    maxLife: 30,
                    isBecomingInvul,
                    particles,
                    typeSpecificUpdate: function() {
                        const t = getTimeScale();
                        const motion = getMotionScale();
                        this.life -= t;
                        this.shockwaveRadius = (this.shockwaveMaxRadius * (1 - this.life / this.maxLife));
                        this.particles = this.particles.filter(p => {
                            p.x += p.dx * motion;
                            p.y += p.dy * motion;
                            p.dx *= Math.pow(0.95, t);
                            p.dy *= Math.pow(0.95, t);
                            p.life -= t;
                            p.opacity = p.life / 30;
                            return p.life > 0;
                        });
                        return this.life > 0;
                    },
                    typeSpecificDraw: function(ctx) {
                        ctx.save();
                        const opacity = this.life / this.maxLife;
                        ctx.globalAlpha = opacity * 0.5;
                        const color = this.isBecomingInvul ? '#000000' : '#ff9999';
                        ctx.strokeStyle = color;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.shockwaveRadius, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                        this.particles.forEach(p => {
                            ctx.globalAlpha = p.opacity;
                            ctx.fillStyle = color;
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                            ctx.fill();
                        });
                        ctx.restore();
                    }
                }));
            }

            update(playerX, playerY) {
                this.playerX = playerX;
                this.playerY = playerY;
                // In-place compaction to avoid new array allocations
                let write = 0;
                for (let read = 0; read < this.effects.length; read++) {
                    const eff = this.effects[read];
                    if (eff.update(playerX, playerY)) {
                        this.effects[write++] = eff;
                    }
                }
                this.effects.length = write;
            }

            draw(ctx, score, playerX, playerY, bullets) {
                // Pre-scan dash trails to avoid repeated filtering per effect
                const dashTrails = [];
                for (let i = 0; i < this.effects.length; i++) {
                    const ef = this.effects[i];
                    if (ef.type === 'dashTrail') dashTrails.push(ef);
                }
                const dashCount = dashTrails.length;
                const maxOpacity = 0.45;
                const minOpacity = 0.1;
                for (let i = 0; i < this.effects.length; i++) {
                    const effect = this.effects[i];
                    if (effect.type === 'dashTrail') {
                        const index = dashTrails.indexOf(effect);
                        const normalizedIndex = dashCount <= 1 ? 1 : index / Math.max(1, dashCount - 1);
                        const opacityScale = minOpacity + (maxOpacity - minOpacity) * normalizedIndex;
                        if (effect.opacity <= 0) continue;
                        ctx.save();
                        ctx.globalAlpha = effect.opacity * opacityScale;
                        effect.draw(ctx);
                        ctx.restore();
                    } else {
                        effect.draw(ctx);
                    }
                }
                for (let i = 0; i < bullets.length; i++) {
                    const b = bullets[i];
                    if (!b || b._dead) continue;
                    b.draw(ctx);
                }
                this.playerX = playerX;
                this.playerY = playerY;
            }

            createXPRing(x, y, size, xpAmount) {
                const fillColor = 'rgba(0, 255, 0, 0.25)';
                const strokeColor = '#00ff00';
                this.effects.push(new Effect('xpRing', x, y, {
                    size,
                    xpAmount,
                    life: 360, // 6 seconds at 60fps
                    maxLife: 360,
                    pulse: 0,
                    fadeOut: 0,
                    magnetRadius: 100,
                    minMagnetSpeed: 2,
                    maxMagnetSpeed: 12,
                    typeSpecificUpdate: function(playerX, playerY) {
                        const magnetRange = this.magnetRadius || 0;
                        if (typeof playerX === 'number' && typeof playerY === 'number' && magnetRange > 0) {
                            const dx = playerX - this.x;
                            const dy = playerY - this.y;
                            const dist = Math.hypot(dx, dy);
                            if (dist <= magnetRange) {
                                const closeness = 1 - Math.min(dist / magnetRange, 1);
                                const minSpeed = this.minMagnetSpeed ?? 2;
                                const maxSpeed = this.maxMagnetSpeed ?? 10;
                                const speed = (minSpeed + (maxSpeed - minSpeed) * closeness) * (this.speedMultiplier || 1) * getMotionScale();
                                if (dist > 0.0001) {
                                    const step = speed / dist;
                                    this.x += dx * step;
                                    this.y += dy * step;
                                    if (dist <= speed) {
                                        this.x = playerX;
                                        this.y = playerY;
                                    }
                                } else {
                                    this.x = playerX;
                                    this.y = playerY;
                                }
                            }
                        }
                        if (this.life > 0) {
                            this.life--;
                        }
                        // More visible blink during the last 2 seconds
                        if (this.life > 0 && this.life < 120) {
                            this.pulse += 0.6; // faster pulse for visibility
                        } else {
                            this.pulse += 0.25;
                        }
                        // After life ends, fade out for ~60 frames (1s); still collectible while visible
                        if (this.life <= 0) {
                            this.fadeOut = Math.min(1, this.fadeOut + 1/60);
                            return this.fadeOut < 1;
                        }
                        return true;
                    },
                    typeSpecificDraw: function(ctx) {
                        const blinkAlpha = this.life < 120 ? (0.2 + 0.6 * Math.abs(Math.sin(this.pulse))) : 0.5;
                        ctx.save();
                        // Fill with base 0.25 alpha && subtle blink modulation; apply fade when life <= 0
                        ctx.fillStyle = fillColor;
                        const renderAlpha = this.life > 0 ? 1.0 : Math.max(0, 1.0 - this.fadeOut);
                        ctx.globalAlpha = renderAlpha;
                        // Slight pre-expire shrink during last 2 seconds; shrink fully during fade out
                        const preExpireDuration = 120;
                        const preExpireScale = (this.life > 0 && this.life < preExpireDuration)
                            ? (1 - 0.2 * (1 - (this.life / preExpireDuration)))
                            : 1;
                        const renderSize = this.life > 0
                            ? (this.size * preExpireScale)
                            : Math.max(0, this.size * (1 - this.fadeOut));
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, renderSize, 0, Math.PI * 2);
                        ctx.fill();
                        // Stroke with blink && fade
                        ctx.strokeStyle = strokeColor;
                        ctx.lineWidth = 3;
                        const strokeAlpha = this.life > 0 ? blinkAlpha : Math.max(0, blinkAlpha * (1 - this.fadeOut));
                        ctx.globalAlpha = strokeAlpha;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, renderSize, 0, Math.PI * 2);
                        ctx.globalAlpha = 1.0;
                        ctx.stroke();
                        ctx.restore();
                    }
                }));
            }

            createXPCollectEffect(x, y) {
                const rings = 1;
                const startRadius = 12;
                const delayFrames = 30; // 0.5s at 60fps
                for (let i = 0; i < rings; i++) {
                    this.effects.push(new Effect('xpCollectRing', x, y, {
                        radius: startRadius,
                        opacity: 0.9,
                        life: 40,
                        maxLife: 40,
                        lineWidth: 3,
                        delay: i * delayFrames,
                        typeSpecificUpdate: function() {
                            if (this.delay > 0) { this.delay--; return true; }
                            this.life--;
                            const t = 1 - (this.life / this.maxLife);
                            this.radius = startRadius + t * 40;
                            this.opacity = Math.max(0, 0.9 * (1 - t));
                            return this.life > 0;
                        },
                        typeSpecificDraw: function(ctx) {
                            if (this.delay > 0) return;
                            ctx.save();
                            ctx.globalAlpha = this.opacity;
                            ctx.strokeStyle = '#00ff00';
                            ctx.lineWidth = this.lineWidth;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.restore();
                        }
                    }));
                }
            }
        }

        // Enemy management
        class Enemy {
            constructor(x, y, type, config) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.radius = config.size;
                this.speed = config.speed;
                this.health = config.health;
                this.maxHealth = config.health;
                this.points = config.points;
                this.damage = config.damage;
                this.fillColor = config.fillColor;
                this.strokeColor = config.strokeColor;
                this.damageFlash = 0;
                this.lastShot = 0;
                this.shootDelay = config.shootDelay != null ? config.shootDelay : (type === 'octagon' ? 4000 : Infinity);
                this.enemyBulletSpeed = config.enemyBulletSpeed || 8;
                this.enemyBulletDamage = typeof config.enemyBulletDamage === 'number' ? config.enemyBulletDamage : 15;
                this.enemyProjectileVisuals = {
                    radius: config.enemyBulletRadius,
                    fillColor: config.enemyBulletFillColor,
                    strokeColor: config.enemyBulletStrokeColor,
                    trailColor: config.bulletTrailColor,
                    trailLifeMultiplier: config.bulletTrailLifeMultiplier,
                    trailSizeMultiplier: config.bulletTrailSizeMultiplier,
                    trailOpacityMultiplier: config.bulletTrailOpacityMultiplier,
                    glowColor: config.enemyBulletGlowColor
                };
                this.lastTrailTime = 0;
                this.deathSound = config.deathSound || 'enemyDeath';
                this.explosionRadius = config.explosionRadius || 0;
                this.explosionDamage = config.explosionDamage || 0;
                this.trailIntervalMs = config.trailIntervalMs || null;
                this.trailLife = config.trailLife || null;
                this.trailShrinkFactor = config.trailShrinkFactor || null;
                this.trailFadeExponent = config.trailFadeExponent || null;
                this.spawnShieldUntil = 0;
                this.superShieldActive = type === 'super_octagon';
                this.shieldRadiusOffset = config.shieldRadiusOffset != null ? config.shieldRadiusOffset : 0;
                this.shieldColor = config.shieldColor || null;
                this.shieldLineColor = config.shieldLineColor || null;
                this.glowColor = config.glowColor || null;
                this.shieldPulse = 0;
                this.glowPulse = (this.glowColor && type !== 'super_octagon') ? Math.random() * Math.PI * 2 : 0;
                if (this.type === 'super_octagon') {
                    if (!this.shieldRadiusOffset) this.shieldRadiusOffset = Math.max(24, this.radius * 0.3);
                    if (!this.shieldColor) this.shieldColor = 'rgba(255, 160, 0, 0.18)';
                    if (!this.shieldLineColor) this.shieldLineColor = 'rgba(255, 210, 0, 0.85)';
                    if (!this.glowColor) this.glowColor = 'rgba(255, 32, 0, 0.65)';
                    if (typeof config.enemyBulletDamage !== 'number') {
                        this.enemyBulletDamage = 18;
                    }
                } else {
                    this.superShieldActive = false;
                }
                this.isBoss = !!config.isBoss || config.role === 'boss';
                this.bossTriangleSpawnIntervalMs = config.bossTriangleSpawnIntervalMs || 0;
                this.lastTriangleSpawnTime = 0;
                // Damage indicator for health bar (white overlay segment)
                this.recentDamage = 0;
                this.recentDamageFade = 0; // frames left
                if (type === 'rhombus' || type === 'rhombus_boss') {
                    this.invulnerable = false;
                    this.lastStateChange = Date.now();
                    this.stateChangeDuration = 2500;
                    this.circleRadius = 150 + Math.random() * 100;
                    this.angleOffset = Math.random() * Math.PI * 2;
                    this.clockwise = Math.random() < 0.5;
                    this.orbitSpeed = 0.02 + Math.random() * 0.02;
                    this.approachSpeed = 0.8;
                }
                if (type === 'killer_triangle') {
                    this.behaviorState = 'orbit';
                    this.killerOrbitDurationBase = config.orbitDurationFrames || 150;
                    this.killerOrbitDurationRange = config.orbitDurationRange || 120;
                    this.killerDashDurationFrames = config.dashDurationFrames || 70;
                    this.killerDashSpeedMultiplier = config.dashSpeedMultiplier || 1.7;
                    this.killerOrbitRadiusMin = config.orbitRadiusMin || Math.max(this.radius * 4, 120);
                    this.killerOrbitRadiusMax = Math.max(this.killerOrbitRadiusMin + 20, config.orbitRadiusMax || Math.max(this.radius * 8, 240));
                    this.killerOrbitAngularMin = config.orbitAngularSpeedMin || 0.018;
                    this.killerOrbitAngularMax = config.orbitAngularSpeedMax || 0.032;
                    this.killerWobbleStrength = config.wobbleStrength || 0.55;
                    this.behaviorTimerMax = this.killerOrbitDurationBase + Math.random() * this.killerOrbitDurationRange;
                    this.behaviorTimer = this.behaviorTimerMax;
                    this.orbitAngle = Math.random() * Math.PI * 2;
                    this.orbitDirection = Math.random() < 0.5 ? -1 : 1;
                    this.orbitAngularSpeed = this.killerOrbitAngularMin + Math.random() * (this.killerOrbitAngularMax - this.killerOrbitAngularMin);
                    this.orbitRadius = this.killerOrbitRadiusMin + Math.random() * Math.max(1, this.killerOrbitRadiusMax - this.killerOrbitRadiusMin);
                    this.wobblePhase = Math.random() * Math.PI * 2;
                    if (!this.trailIntervalMs) this.trailIntervalMs = 35;
                    if (!this.trailLife) this.trailLife = 100;
                    if (!this.trailShrinkFactor) this.trailShrinkFactor = 0.985;
                    if (!this.trailFadeExponent) this.trailFadeExponent = 1.15;
                }
                if (type === 'dash_square') {
                    this.dashCooldownMs = config.dashCooldownMs || 2000;
                    this.dashDistance = config.dashDistance || 70;
                    this.dashDurationMs = config.dashDurationMs || 180;
                    this.lastDashTime = Date.now() - Math.random() * this.dashCooldownMs;
                    this.isDashing = false;
                    this.dashVelocityX = 0;
                    this.dashVelocityY = 0;
                    this.dashFrames = 0;
                    this.dashTotalFrames = Math.max(1, Math.round(this.dashDurationMs / (1000 / 60)));
                    this.dashStartX = this.x;
                    this.dashStartY = this.y;
                    this.dashEndX = this.x;
                    this.dashEndY = this.y;
                }
            }

            update(player, canvas, effects, enemyBullets, audio) {
                const motion = getMotionScale();
                const t = getTimeScale();
                const now = Date.now();
                if (this.damageFlash > 0) this.damageFlash -= t;
                if (this.glowColor && this.type !== 'super_octagon') {
                    const glowStep = 0.062 * t;
                    this.glowPulse = ((this.glowPulse || 0) + glowStep) % (Math.PI * 2);
                }
                if (this.type === 'super_octagon') {
                    const shieldStep = 0.08 * t;
                    const glowStep = 0.05 * t;
                    this.shieldPulse = (this.shieldPulse + shieldStep) % (Math.PI * 2);
                    this.glowPulse = (this.glowPulse + glowStep) % (Math.PI * 2);
                }
                if (this.type === 'rhombus' || this.type === 'rhombus_boss') {
                    if (now - this.lastStateChange >= this.stateChangeDuration / Math.max(0.001, t)) {
                        const wasInvulnerable = this.invulnerable;
                        this.invulnerable = !this.invulnerable;
                        this.lastStateChange = now;
                        effects.createRhombusEffect(this.x, this.y, this.invulnerable);
                    }
                }
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy) || 0.1;
                if (this.type === 'rhombus' || this.type === 'rhombus_boss') {
                    this.angleOffset += (this.clockwise ? this.orbitSpeed : -this.orbitSpeed) * t;
                    const desiredX = player.x + Math.cos(this.angleOffset) * this.circleRadius;
                    const desiredY = player.y + Math.sin(this.angleOffset) * this.circleRadius;
                    const desiredDx = desiredX - this.x;
                    const desiredDy = desiredY - this.y;
                    const desiredDist = Math.sqrt(desiredDx * desiredDx + desiredDy * desiredDy) || 0.1;
                    this.x += (desiredDx / desiredDist) * this.speed * this.approachSpeed * motion;
                    this.y += (desiredDy / desiredDist) * this.speed * this.approachSpeed * motion;
                } else if (this.type === 'killer_triangle') {
                    this.updateKillerTriangleMovement(player, motion, t, dx, dy, dist);
                } else {
                    let moveX = (dx / dist) * this.speed * motion;
                    let moveY = (dy / dist) * this.speed * motion;
                    if (this.type === 'dash_square') {
                        const cooldown = this.dashCooldownMs || 2000;
                        const effectiveCooldown = cooldown / Math.max(0.001, t);
                        if (!this.isDashing && now - this.lastDashTime >= effectiveCooldown) {
                            const dirX = (dx / dist) || 0;
                            const dirY = (dy / dist) || 0;
                            const dashDistance = this.dashDistance || 70;
                            const dashDuration = (this.dashDurationMs || 180) / Math.max(0.001, t);
                            const frames = Math.max(3, Math.round(dashDuration / (1000 / 60)));
                            const dashStep = dashDistance / frames;
                            this.dashVelocityX = dirX * dashStep;
                            this.dashVelocityY = dirY * dashStep;
                            this.dashTotalFrames = frames;
                            this.dashFrames = 0;
                            this.isDashing = true;
                            this.dashStartX = this.x;
                            this.dashStartY = this.y;
                            this.dashEndX = this.x + dirX * dashDistance;
                            this.dashEndY = this.y + dirY * dashDistance;
                            this.lastDashTime = now;
                            if (effects && effects.createEnemyDashEffect) {
                                effects.createEnemyDashEffect(this.dashStartX, this.dashStartY, this.dashEndX, this.dashEndY);
                            }
                            if (audio) audio.playSound('enemyDash');
                        }
                        if (this.isDashing) {
                            moveX = this.dashVelocityX * motion;
                            moveY = this.dashVelocityY * motion;
                            this.dashFrames += 1;
                            if (this.dashFrames >= this.dashTotalFrames) {
                                this.isDashing = false;
                            }
                        }
                    }
                    this.x += moveX;
                    this.y += moveY;
                }
                if (this.type === 'octagon' || this.type === 'super_octagon') {
                    if (now - this.lastShot >= this.shootDelay / Math.max(0.001, t)) {
                        this.shoot(player, enemyBullets, audio);
                        this.lastShot = now;
                    }
                }
                if (this.type === 'triangle') {
                    if (now - this.lastTrailTime >= 50 / Math.max(0.001, t)) {
                        const baseSize = this.radius * 0.8;
                        for (let i = 0; i < 5; i++) {
                            const size = baseSize * Math.pow(0.75, i);
                            const opacity = 0.5 - (i * 0.125);
                            effects.createTriangleTrail(this.x, this.y, size, opacity, this.fillColor);
                        }
                        this.lastTrailTime = now;
                    }
                } else if (this.type === 'killer_triangle') {
                    const intervalMs = this.trailIntervalMs != null ? this.trailIntervalMs : 35;
                    if (now - this.lastTrailTime >= intervalMs / Math.max(0.001, t)) {
                        const baseSize = this.radius;
                        const life = this.trailLife || 100;
                        const shrinkFactor = this.trailShrinkFactor || 0.985;
                        const fadeExponentBase = this.trailFadeExponent || 1.15;
                        const glowColor = this.glowColor || 'rgba(255, 52, 76, 0.6)';
                        for (let i = 0; i < 6; i++) {
                            const size = baseSize * Math.pow(0.78, i);
                            const opacity = Math.max(0.1, 0.75 - i * 0.08);
                            const fadeExponent = fadeExponentBase + i * 0.1;
                            const glowOpacity = Math.max(0.05, 0.65 - i * 0.08);
                            effects.createTriangleTrail(
                                this.x,
                                this.y,
                                size,
                                opacity,
                                this.fillColor,
                                {
                                    life,
                                    shrinkFactor,
                                    fadeExponent,
                                    glowColor,
                                    glowOpacity
                                }
                            );
                        }
                        this.lastTrailTime = now;
                    }
                }
                // Boss periodic triangle spawns
                if (this.isBoss && this.bossTriangleSpawnIntervalMs > 0) {
                    if (now - this.lastTriangleSpawnTime >= this.bossTriangleSpawnIntervalMs / Math.max(0.001, t)) {
                        const count = 4;
                        const minRadius = 90;
                        const extraRadius = 60;
                        for (let i = 0; i < count; i++) {
                            const angle = (Math.PI * 2 * i) / count + Math.random() * 0.5;
                            const distance = minRadius + extraRadius + Math.random() * 40;
                            const tx = this.x + Math.cos(angle) * distance;
                            const ty = this.y + Math.sin(angle) * distance;
                            const e = new Enemy(tx, ty, 'triangle', ENEMY_TYPES['triangle']);
                            e.spawnShieldUntil = now + 800;
                            e.spawnedByBossType = this.type;
                            if (this.type === 'rhombus_boss') {
                                e.spawnedByRhombusBoss = true;
                            }
                            if (typeof window !== 'undefined' && window.game) window.game.enemies.push(e);
                        }
                        if (audio) audio.playSound('MinionSummon');
                        this.lastTriangleSpawnTime = now;
                    }
                }
                return dist;
            }

            updateKillerTriangleMovement(player, motion, t, dx, dy, dist) {
                const step = Math.max(0.001, t);
                let effectiveDist = dist;
                if (!isFinite(effectiveDist) || effectiveDist < 0.001) {
                    effectiveDist = 0.001;
                }
                if (!this.behaviorState) {
                    this.behaviorState = 'orbit';
                    this.behaviorTimerMax = this.killerOrbitDurationBase + Math.random() * this.killerOrbitDurationRange;
                    this.behaviorTimer = this.behaviorTimerMax;
                    this.orbitAngle = Math.random() * Math.PI * 2;
                    this.orbitDirection = Math.random() < 0.5 ? -1 : 1;
                    this.orbitAngularSpeed = this.killerOrbitAngularMin + Math.random() * (this.killerOrbitAngularMax - this.killerOrbitAngularMin);
                    this.orbitRadius = this.killerOrbitRadiusMin + Math.random() * Math.max(1, this.killerOrbitRadiusMax - this.killerOrbitRadiusMin);
                    this.wobblePhase = Math.random() * Math.PI * 2;
                }
                if (this.behaviorState === 'orbit') {
                    this.behaviorTimer -= step;
                    const targetRadius = Math.max(
                        this.killerOrbitRadiusMin,
                        Math.min(this.killerOrbitRadiusMax, effectiveDist * 0.85 + 80)
                    );
                    if (!isFinite(this.orbitRadius)) this.orbitRadius = targetRadius;
                    this.orbitRadius += (targetRadius - this.orbitRadius) * 0.08 * step;
                    this.orbitAngularSpeed = Math.min(
                        this.killerOrbitAngularMax,
                        Math.max(this.killerOrbitAngularMin, this.orbitAngularSpeed)
                    );
                    this.orbitAngle += this.orbitAngularSpeed * this.orbitDirection * step;
                    const desiredX = player.x + Math.cos(this.orbitAngle) * this.orbitRadius;
                    const desiredY = player.y + Math.sin(this.orbitAngle) * this.orbitRadius;
                    const ddx = desiredX - this.x;
                    const ddy = desiredY - this.y;
                    const len = Math.sqrt(ddx * ddx + ddy * ddy) || 1;
                    const baseSpeed = this.speed * 0.9;
                    this.x += (ddx / len) * baseSpeed * motion;
                    this.y += (ddy / len) * baseSpeed * motion;
                    if (this.behaviorTimer <= 0) {
                        this.behaviorState = 'dive';
                        this.behaviorTimerMax = this.killerDashDurationFrames;
                        this.behaviorTimer = this.killerDashDurationFrames;
                        this.wobblePhase = Math.random() * Math.PI * 2;
                    }
                } else {
                    this.behaviorTimer -= step;
                    const progress = this.behaviorTimerMax > 0 ? 1 - (this.behaviorTimer / this.behaviorTimerMax) : 1;
                    const wobble = Math.sin((this.wobblePhase || 0) + progress * Math.PI * 2) * this.killerWobbleStrength;
                    const angle = Math.atan2(dy, dx) + wobble;
                    const dirX = Math.cos(angle);
                    const dirY = Math.sin(angle);
                    const speedMul = this.killerDashSpeedMultiplier || 1.6;
                    this.x += dirX * this.speed * speedMul * motion;
                    this.y += dirY * this.speed * speedMul * motion;
                    if (this.behaviorTimer <= 0 || effectiveDist < this.radius * 1.8) {
                        this.behaviorState = 'orbit';
                        this.behaviorTimerMax = this.killerOrbitDurationBase + Math.random() * this.killerOrbitDurationRange;
                        this.behaviorTimer = this.behaviorTimerMax;
                        this.orbitDirection = (Math.random() < 0.5 ? -1 : 1);
                        this.orbitAngle = Math.atan2(this.y - player.y, this.x - player.x);
                    }
                }
            }

            shoot(player, enemyBullets, audio) {
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy) || 0.1;
                const speed = this.enemyBulletSpeed || 8;
                const damage = typeof this.enemyBulletDamage === 'number' ? this.enemyBulletDamage : 15;
                const vx = (dx / dist) * speed;
                const vy = (dy / dist) * speed;
                let projectileOptions;
                if (this.enemyProjectileVisuals) {
                    const opts = {};
                    if (this.enemyProjectileVisuals.radius != null) opts.radius = this.enemyProjectileVisuals.radius;
                    if (this.enemyProjectileVisuals.fillColor) opts.fillColor = this.enemyProjectileVisuals.fillColor;
                    if (this.enemyProjectileVisuals.strokeColor) opts.strokeColor = this.enemyProjectileVisuals.strokeColor;
                    if (this.enemyProjectileVisuals.trailColor) opts.trailColor = this.enemyProjectileVisuals.trailColor;
                    if (this.enemyProjectileVisuals.trailLifeMultiplier) opts.trailLifeMultiplier = this.enemyProjectileVisuals.trailLifeMultiplier;
                    if (this.enemyProjectileVisuals.trailSizeMultiplier) opts.trailSizeMultiplier = this.enemyProjectileVisuals.trailSizeMultiplier;
                    if (this.enemyProjectileVisuals.trailOpacityMultiplier) opts.trailOpacityMultiplier = this.enemyProjectileVisuals.trailOpacityMultiplier;
                    if (this.enemyProjectileVisuals.glowColor) opts.glowColor = this.enemyProjectileVisuals.glowColor;
                    if (Object.keys(opts).length > 0) projectileOptions = opts;
                }
                enemyBullets.push(new EnemyBullet(
                    this.x,
                    this.y,
                    vx,
                    vy,
                    damage,
                    projectileOptions
                ));
                if (audio) audio.playSound('enemyShoot');
            }

            takeDamage(damage, effects, score, ctx, audio, options = {}) {
                const now = Date.now();
                const {
                    ignoreShield = false,
                    damageType = 'generic',
                    impactX = this.x,
                    impactY = this.y
                } = options;
                if ((this.spawnShieldUntil && now < this.spawnShieldUntil) || ((this.type === 'rhombus' || this.type === 'rhombus_boss') && this.invulnerable)) return true;
                if (this.type === 'super_octagon' && this.superShieldActive) {
                    const shieldRadius = this.radius + (this.shieldRadiusOffset || Math.max(24, this.radius * 0.3));
                    if (effects && typeof effects.createShieldImpact === 'function') {
                        effects.createShieldImpact(
                            impactX != null ? impactX : this.x,
                            impactY != null ? impactY : this.y,
                            shieldRadius,
                            damageType
                        );
                    }
                    if (!ignoreShield) {
                        if (audio && damageType !== 'railgun') audio.playSound('enemyHit');
                        return true;
                    }
                }
                this.health -= damage;
                this.damageFlash = 10;
                // Record recent damage for health bar overlay
                this.recentDamage = Math.max(0, damage);
                this.recentDamageFade = 45; // ~0.75s at 60fps
                if (effects) {
                    effects.createHitEffect(this.x, this.y);
                    effects.createDamageLabel(this.x, this.y - this.radius - 30, damage, false);
                }
                if (this.health <= 0) {
                    if (audio) audio.playSound(this.deathSound || 'enemyDeath');
                    return false;
                } else {
                    if (audio) {
                        if (this.isBoss) audio.playSound('boss_hit');
                        else audio.playSound('enemyHit');
                    }
                    return true;
                }
            }

            draw(ctx) {
                const isSuper = this.type === 'super_octagon';
                let shieldRadius = null;
                let shieldPulsePhase = this.shieldPulse || 0;
                if (isSuper) {
                    const baseOffset = this.shieldRadiusOffset || Math.max(24, this.radius * 0.3);
                    shieldPulsePhase = this.shieldPulse || 0;
                    const pulseScale = 1 + 0.035 * Math.sin(shieldPulsePhase * 1.5);
                    shieldRadius = (this.radius + baseOffset) * pulseScale;
                    const glowIntensity = 0.35 + 0.25 * Math.sin((this.glowPulse || 0) * 1.2);
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.fillStyle = this.glowColor || 'rgba(255, 32, 0, 0.65)';
                    ctx.globalAlpha = Math.max(0, Math.min(1, glowIntensity));
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, shieldRadius * 0.85, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    ctx.save();
                    const pulseAlpha = 0.45 + 0.18 * Math.sin(shieldPulsePhase * 2);
                    const damageBoost = this.damageFlash > 0 ? 0.25 : 0;
                    const totalAlpha = Math.max(0, Math.min(1, pulseAlpha + damageBoost));
                    ctx.globalAlpha = totalAlpha;
                    ctx.fillStyle = this.shieldColor || 'rgba(255, 160, 0, 0.6)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, shieldRadius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
                let color, stroke;
                if ((this.type === 'rhombus' || this.type === 'rhombus_boss') && this.invulnerable) {
                    color = 'rgba(0, 0, 0, 0.5)';
                    stroke = '#ff0000';
                } else {
                    color = this.damageFlash > 0 ? '#ffffff' : this.fillColor;
                    stroke = this.damageFlash > 0 ? '#ffffff' : this.strokeColor;
                }
                const glowPulse = this.glowColor ? (this.glowPulse || 0) : 0;
                const isKillerTriangle = this.type === 'killer_triangle';
                const killerBlinkFactor = isKillerTriangle ? Math.max(0, Math.sin(glowPulse * 3.2)) : 1;
                const killerShadowAlpha = isKillerTriangle ? 0.375 * killerBlinkFactor : undefined;
                ShapeRenderer.drawShape(ctx, this.x, this.y, this.type, this.radius, color, stroke, {
                    killerGlowAlpha: killerShadowAlpha
                });
                if (this.glowColor && this.type !== 'super_octagon') {
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    const basePulse = 0.35 + 0.25 * Math.sin(glowPulse * 1.8);
                    const damageBoost = this.damageFlash > 0 ? 0.25 : 0;
                    let glowAlpha = Math.max(0, Math.min(1, basePulse + damageBoost));
                    if (isKillerTriangle) {
                        glowAlpha = Math.max(0, Math.min(1, (basePulse + damageBoost) * 0.5 * killerBlinkFactor));
                    }
                    ctx.globalAlpha = glowAlpha;
                    ctx.fillStyle = this.glowColor;
                    const radiusMul = 1.5 + 0.15 * Math.sin(glowPulse * 2.6);
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * radiusMul, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
                if (isSuper && shieldRadius != null) {
                    ctx.save();
                    const damageBoost = this.damageFlash > 0 ? 0.2 : 0;
                    const outlineAlpha = 0.55 + 0.15 * Math.sin(shieldPulsePhase * 2.5) + damageBoost;
                    ctx.globalAlpha = Math.max(0, Math.min(1, outlineAlpha));
                    ctx.strokeStyle = this.shieldLineColor || 'rgba(255, 210, 0, 0.85)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, shieldRadius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
                if (this.maxHealth > 50) {
                    const w = this.radius * 2, h = 4;
                    ctx.fillStyle = 'rgba(100, 0, 0, 0.7)';
                    ctx.fillRect(this.x - w/2, this.y - this.radius - 10, w, h);
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
                    const healthPct = Math.max(0, this.health / this.maxHealth);
                    ctx.fillRect(this.x - w/2, this.y - this.radius - 10, w * healthPct, h);
                    // Draw recent damage overlay as white segment with fading opacity
                    if (this.recentDamageFade > 0 && this.maxHealth > 0) {
                        const t = getTimeScale();
                        this.recentDamageFade = Math.max(0, this.recentDamageFade - t);
                        const recentPct = Math.min(1, this.recentDamage / this.maxHealth);
                        const overlayStart = this.x - w/2 + w * healthPct;
                        const overlayWidth = Math.max(0, w * recentPct);
                        const alpha = Math.max(0, this.recentDamageFade / 45);
                        ctx.fillStyle = `rgba(255,255,255,${0.9 * alpha})`;
                        ctx.fillRect(overlayStart, this.y - this.radius - 10, overlayWidth, h);
                    }
                }
            }
        }

        // ---- Tetris Cross Boss and Tetromino System ----
        // Shapes: I, O, T, S, Z, J, L (using 4x4 grids for rotation ease)
        const TETROMINO_SHAPES = {
            I: [
                [0,0,0,0],
                [1,1,1,1],
                [0,0,0,0],
                [0,0,0,0]
            ],
            O: [
                [0,1,1,0],
                [0,1,1,0],
                [0,0,0,0],
                [0,0,0,0]
            ],
            T: [
                [0,1,0,0],
                [1,1,1,0],
                [0,0,0,0],
                [0,0,0,0]
            ],
            S: [
                [0,1,1,0],
                [1,1,0,0],
                [0,0,0,0],
                [0,0,0,0]
            ],
            Z: [
                [1,1,0,0],
                [0,1,1,0],
                [0,0,0,0],
                [0,0,0,0]
            ],
            J: [
                [1,0,0,0],
                [1,1,1,0],
                [0,0,0,0],
                [0,0,0,0]
            ],
            L: [
                [0,0,1,0],
                [1,1,1,0],
                [0,0,0,0],
                [0,0,0,0]
            ]
        };

        function rotateGridClockwise(grid) {
            const n = grid.length;
            const out = Array.from({ length: n }, () => Array(n).fill(0));
            for (let r = 0; r < n; r++) {
                for (let c = 0; c < n; c++) {
                    out[c][n - 1 - r] = grid[r][c];
                }
            }
            return out;
        }

        let TETROMINO_ID_SEQ = 1;
        class TetrominoPiece {
            constructor(shapeKey, cellSize, canvasWidth) {
                this.id = TETROMINO_ID_SEQ++;
                this.shapeKey = shapeKey;
                this.grid = TETROMINO_SHAPES[shapeKey].map(row => row.slice());
                this.cellSize = cellSize;
                this.hp = TETRIS_SETTINGS.pieceHp;
                this.baseSpeed = TETRIS_SETTINGS.fallSpeedPxPerSec;
                this.enrageAdd = 0;
                this.rotation = 0;
                // Random lane at top
                const cols = TETRIS_SETTINGS.cols;
                const maxColStart = Math.max(0, cols - 4);
                this.col = Math.floor(Math.random() * (maxColStart + 1));
                this.x = this.col * cellSize + cellSize / 2;
                // position above view
                this.y = -2 * cellSize;
                this.glow = 0;
                this.landed = false;
                this.damageFlash = 0;
                this.dying = false;
                this.deathLife = 0;
                this.deathMaxLife = 24;
            }

            getCells() {
                const cells = [];
                for (let r = 0; r < 4; r++) {
                    for (let c = 0; c < 4; c++) {
                        if (this.grid[r][c]) {
                            const cx = this.x + (c - 1.5) * this.cellSize;
                            const cy = this.y + (r - 1.5) * this.cellSize;
                            cells.push({ x: cx, y: cy, r: this.cellSize * 0.5 - 4 });
                        }
                    }
                }
                return cells;
            }

            rotate() {
                this.grid = rotateGridClockwise(this.grid);
                this.rotation = (this.rotation + 1) % 4;
            }

            update(canvas) {
                if (this.damageFlash > 0) this.damageFlash -= getTimeScale();
                if (this.dying) {
                    this.deathLife += getTimeScale();
                    this.glow = (this.glow + 0.06 * getTimeScale()) % (Math.PI * 2);
                    return true;
                }
                if (this.landed) return true;
                const motion = getMotionScale();
                const t = getTimeScale();
                const speed = (this.baseSpeed + this.enrageAdd) * motion * (t / (1000 / 60));
                this.y += speed;
                // If any cell hits bottom, mark landed
                const bottom = canvas.height;
                const cells = this.getCells();
                if (cells.some(cell => cell.y + cell.r >= bottom)) {
                    this.landed = true;
                }
                this.glow = (this.glow + 0.06 * t) % (Math.PI * 2);
                return true;
            }

            draw(ctx) {
                const cells = this.getCells();
                ctx.save();
                const t = this.dying ? Math.min(1, this.deathLife / this.deathMaxLife) : 0;
                const alpha = this.dying ? (1 - t) : 1;
                const scale = this.dying ? (1 - 0.2 * t) : 1;
                const blink = this.damageFlash > 0 && (Math.floor(this.damageFlash / 2) % 2 === 0);
                const halfBase = this.cellSize / 2 - 2;
                const half = halfBase * scale;
                // Batch draw all tetromino cells with one fill+stroke to minimize state churn
                ctx.globalAlpha = alpha;
                ctx.fillStyle = 'rgba(255, 80, 80, 0.9)';
                ctx.strokeStyle = 'rgba(255, 30, 30, 1)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < cells.length; i++) {
                    const c = cells[i];
                    ctx.rect(c.x - half, c.y - half, half * 2, half * 2);
                }
                ctx.fill();
                ctx.stroke();
                if (blink) {
                    ctx.save();
                    ctx.globalAlpha = Math.min(1, 0.7 * alpha);
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    for (let i = 0; i < cells.length; i++) {
                        const c = cells[i];
                        ctx.rect(c.x - half, c.y - half, half * 2, half * 2);
                    }
                    ctx.fill();
                    ctx.restore();
                }
                ctx.restore();
            }

            startDeath(effects) {
                if (this.dying) return;
                this.dying = true;
                this.deathLife = 0;
                const cells = this.getCells();
                cells.forEach(kc => effects.createBulletExplosion(kc.x, kc.y, '#ff4040'));
            }
        }

        class TetrisManager {
            constructor(game) {
                this.game = game;
                this.activePieces = [];
                this.stack = []; // landed cells for game-over detection
                this.lastSpawn = 0;
                this.spawnIntervalMs = TETRIS_SETTINGS.spawnIntervalMs;
                this.enrage = 0;
            }

            reset() {
                this.activePieces = [];
                this.stack = [];
                this.lastSpawn = 0;
                this.spawnIntervalMs = TETRIS_SETTINGS.spawnIntervalMs;
                this.enrage = 0;
            }

            computeCellSize() {
                const cols = TETRIS_SETTINGS.cols;
                const width = this.game.canvas.width;
                const margin = 0;
                const cellSize = Math.floor((width - margin * 2) / cols);
                TETRIS_SETTINGS.cellSize = cellSize;
                return cellSize;
            }

            spawnRandomPiece() {
                const keys = Object.keys(TETROMINO_SHAPES);
                const key = keys[Math.floor(Math.random() * keys.length)];
                const cell = this.computeCellSize();
                const p = new TetrominoPiece(key, cell, this.game.canvas.width);
                // Enrage affects new pieces' speed
                p.enrageAdd = this.enrage;
                this.activePieces.push(p);
            }

            update() {
                const t = getTimeScale();
                const now = Date.now();
                const canvas = this.game.canvas;
                // Enrage: gradual speed increase
                this.enrage += (TETRIS_SETTINGS.enrageSpeedPxPerSec2 / 60) * t;
                // Spawn pacing shortens slowly
                const accel = (TETRIS_SETTINGS.spawnAccelerationMsPerSec / 60) * t;
                this.spawnIntervalMs = Math.max(
                    TETRIS_SETTINGS.minSpawnIntervalMs,
                    this.spawnIntervalMs - accel
                );
                if (now - this.lastSpawn >= this.spawnIntervalMs / Math.max(0.001, t)) {
                    this.spawnRandomPiece();
                    this.lastSpawn = now;
                }
                // Update pieces
                for (let i = this.activePieces.length - 1; i >= 0; i--) {
                    const p = this.activePieces[i];
                    const beforeY = p.y;
                    p.update(canvas);

                    if (p.dying) {
                        if (p.deathLife >= p.deathMaxLife) {
                            this.activePieces.splice(i, 1);
                        }
                        continue;
                    }

                    // Collision with stack: if any cell overlaps an existing stacked cell, land it and revert to before overlap
                    const cells = p.getCells();
                    let overlapsStack = false;
                    if (!p.landed && this.stack.length > 0) {
                        for (let c = 0; c < cells.length && !overlapsStack; c++) {
                            const cell = cells[c];
                            const half = cell.r;
                            for (let s = 0; s < this.stack.length; s++) {
                                const st = this.stack[s];
                                const shalf = st.r;
                                const dx = Math.abs(cell.x - st.x);
                                const dy = Math.abs(cell.y - st.y);
                                if (dx <= half + shalf && dy <= half + shalf) {
                                    overlapsStack = true;
                                    break;
                                }
                            }
                        }
                    }
                    if (overlapsStack) {
                        p.y = beforeY; // revert to just before overlap
                        p.landed = true;
                    }
                    if (p.landed) {
                        // Project all cells to stack
                        const landedCells = p.getCells();
                        landedCells.forEach(c => this.stack.push({ x: c.x, y: c.y, r: c.r }));
                        this.activePieces.splice(i, 1);
                    }
                }
                // Game over check: if any stacked cell reaches top
                const topThreshold = 0 + 20; // allow slight buffer
                for (let k = 0; k < this.stack.length; k++) {
                    if (this.stack[k].y - this.stack[k].r <= topThreshold) {
                        // Player is destroyed
                        if (!this.game.gameOver) {
                            this.game.player.takeDamage(this.game.player.health, this.game.player.x, this.game.player.y, this.game.effects, this.game.audio);
                        }
                        break;
                    }
                }
            }

            draw(ctx) {
                // Draw stack (batch by style, no shadow blur)
                ctx.save();
                ctx.fillStyle = 'rgba(180, 20, 20, 0.9)';
                ctx.strokeStyle = 'rgba(255, 40, 40, 1)';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                for (let i = 0; i < this.stack.length; i++) {
                    const cell = this.stack[i];
                    const half = cell.r;
                    ctx.rect(cell.x - half, cell.y - half, half * 2, half * 2);
                }
                ctx.fill();
                ctx.stroke();
                ctx.restore();
                // Draw active pieces
                this.activePieces.forEach(p => p.draw(ctx));
            }

            clearAll() {
                this.activePieces = [];
                this.stack = [];
            }
        }

        class TetrisCrossBoss {
            constructor(game) {
                this.game = game;
                this.hp = TETRIS_SETTINGS.bossHp;
                this.maxHp = TETRIS_SETTINGS.bossHp;
                this.width = 80;
                this.height = 80;
                // position in upper center under XP bar
                this.x = game.canvas.width / 2;
                const safeMinY = (game.getBossSafeMinCenterY ? game.getBossSafeMinCenterY() : 120);
                this.y = Math.max(safeMinY, 0.2 * game.canvas.height);
                this.vx = 0;
                this.targetVx = 3.0; // desired horizontal speed (px/frame baseline)
                this.inertia = 0.02;
                this.margin = 50; // never fully crosses screen
                this.spawnBelowUiY = this.y;
                this.lastSpawn = 0;
                this.active = true;
                this.damageFlash = 0;
                this.lastShoot = 0;
                this.shootCooldownMs = 1100;
                this.recentDamage = 0;
                this.recentDamageFade = 0;
                const superShield = ENEMY_TYPES['super_octagon'] || {};
                this.shieldColor = superShield.shieldColor || 'rgba(255, 160, 0, 0.18)';
                this.shieldLineColor = superShield.shieldLineColor || 'rgba(255, 210, 0, 0.85)';
                this.glowColor = superShield.glowColor || 'rgba(255, 32, 0, 0.65)';
                const baseOffset = superShield.shieldRadiusOffset != null ? superShield.shieldRadiusOffset : 24;
                this.shieldBaseRadius = Math.max(this.width, this.height) / 2 + baseOffset;
                this.shieldPulse = 0;
                this.glowPulse = 0;
            }

            update() {
                const t = getTimeScale();
                const motion = getMotionScale();
                const shieldStep = 0.08 * t;
                const glowStep = 0.05 * t;
                this.shieldPulse = (this.shieldPulse + shieldStep) % (Math.PI * 2);
                this.glowPulse = (this.glowPulse + glowStep) % (Math.PI * 2);
                // Horizontal movement with inertia
                const desired = this.targetVx * motion;
                this.vx += (desired - this.vx) * Math.min(1, this.inertia * t);
                this.x += this.vx * t;
                // Damage flash decay
                if (this.damageFlash > 0) this.damageFlash -= t;
                // Bounce softly at margins and enforce vertical floor below XP bar
                const left = this.margin;
                const right = this.game.canvas.width - this.margin;
                if (this.x < left) { this.x = left; this.targetVx = Math.abs(this.targetVx); }
                if (this.x > right) { this.x = right; this.targetVx = -Math.abs(this.targetVx); }
                // Clamp Y so boss (and its HP bar at y-74) stays below the XP bar
                const safeY = this.game.getBossSafeMinCenterY ? this.game.getBossSafeMinCenterY() : 120;
                if (this.y < safeY) this.y = safeY;
                // Spawn pieces handled by game.tetrisManager
                // Boss shoots enemy bullets toward player every 3 seconds
                const now = Date.now();
                if (now - this.lastShoot >= this.shootCooldownMs / Math.max(0.001, getTimeScale())) {
                    const player = this.game.player;
                    if (player) {
                        const baseAngle = Math.atan2(player.y - this.y, player.x - this.x);
                        for (let i = 0; i < 3; i++) {
                            const angle = baseAngle + (Math.random() - 0.5) * (Math.PI / 12); // ~Â±15Â°
                            const speed = 8 + Math.random() * 1.5;
                            const dx = Math.cos(angle) * speed;
                            const dy = Math.sin(angle) * speed;
                            this.game.enemyBullets.push(new EnemyBullet(this.x, this.y, dx, dy));
                        }
                        if (this.game.audio) this.game.audio.playSound('enemyShoot');
                    }
                    this.lastShoot = now;
                }
                return true;
            }

            takeRailgunDamage(damage, fullCharge) {
                // Only fully charged railgun can penetrate shield
                if (!fullCharge) return true; // no effect
                this.damageFlash = 12;
                this.recentDamage = Math.max(0, damage);
                this.recentDamageFade = 45;
                this.hp -= damage;
                if (this.game && this.game.audio && this.hp > 0) {
                    this.game.audio.playSound('boss_hit');
                }
                if (this.hp <= 0) {
                    this.active = false;
                    // Clear all tetrominoes
                    if (this.game.tetrisManager) this.game.tetrisManager.clearAll();
                    // Cross-shaped explosion and XP reward
                    if (this.game.effects && this.game.effects.createExplosion) {
                        // Emit a cross pattern by exploding along 4 arms using square shards
                        const arms = 4;
                        const armLen = 6;
                        const speed = 3.5;
                        for (let i = 0; i < arms; i++) {
                            for (let j = 1; j <= armLen; j++) {
                                const angle = (Math.PI / 2) * i;
                                const dx = Math.cos(angle) * (speed + j * 0.4);
                                const dy = Math.sin(angle) * (speed + j * 0.4);
                                this.game.effects.effects.push(new Effect('explosion', this.x, this.y, {
                                    size: 12 * (0.8 + Math.random() * 0.4),
                                    opacity: 1,
                                    life: 28 + Math.random() * 16,
                                    dx, dy,
                                    fillColor: '#ff3333',
                                    strokeColor: '#ff3333',
                                    shapeType: 'square',
                                    typeSpecificUpdate: function() {
                                        const motion = getMotionScale();
                                        const t = getTimeScale();
                                        this.x += this.dx * motion;
                                        this.y += this.dy * motion;
                                        this.dx *= Math.pow(0.94, t);
                                        this.dy *= Math.pow(0.94, t);
                                        this.life -= t;
                                        this.opacity = this.life / 45;
                                        return this.life > 0;
                                    },
                                    typeSpecificDraw: function(ctx) {
                                        ctx.save();
                                        ctx.globalAlpha = this.opacity;
                                        ShapeRenderer.drawShape(ctx, this.x, this.y, this.shapeType, this.size, this.fillColor, this.strokeColor);
                                        ctx.restore();
                                    }
                                }));
                            }
                        }
                    }
                    if (this.game.effects && this.game.effects.createXPRing) {
                        this.game.effects.createXPRing(this.x, this.y, 22, 200);
                    }
                    if (this.game.audio) this.game.audio.playSound('bossDefeated');
                    return false; // dead
                }
                return true;
            }

            draw(ctx) {
                const shieldPulsePhase = this.shieldPulse || 0;
                const baseRadius = this.shieldBaseRadius || 63;
                const pulseScale = 1 + 0.035 * Math.sin(shieldPulsePhase * 1.5);
                const shieldRadius = baseRadius * pulseScale;
                const glowPulsePhase = this.glowPulse || 0;
                ctx.save();
                ctx.save();
                const glowIntensity = 0.35 + 0.25 * Math.sin(glowPulsePhase * 1.2);
                ctx.globalCompositeOperation = 'lighter';
                ctx.fillStyle = this.glowColor || 'rgba(255, 32, 0, 0.65)';
                ctx.globalAlpha = Math.max(0, Math.min(1, glowIntensity));
                ctx.beginPath();
                ctx.arc(this.x, this.y, shieldRadius * 0.85, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                ctx.save();
                const pulseAlpha = 0.45 + 0.18 * Math.sin(shieldPulsePhase * 2);
                const damageBoost = this.damageFlash > 0 ? 0.25 : 0;
                ctx.globalAlpha = Math.max(0, Math.min(1, pulseAlpha + damageBoost));
                ctx.fillStyle = this.shieldColor || 'rgba(255, 160, 0, 0.6)';
                ctx.beginPath();
                ctx.arc(this.x, this.y, shieldRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                const s = 18; // square size
                const halfW = Math.floor(this.width / s / 2) * s;
                const halfH = Math.floor(this.height / s / 2) * s;
                const fill = this.damageFlash > 0 ? 'rgba(255,255,255,0.95)' : 'rgba(255, 80, 80, 0.95)';
                const stroke = this.damageFlash > 0 ? 'rgba(255,255,255,1)' : 'rgba(255, 30, 30, 1)';
                ctx.fillStyle = fill;
                ctx.strokeStyle = stroke;
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let x = -halfW; x <= halfW; x += s) {
                    ctx.rect(this.x + x - s/2, this.y - s/2, s, s);
                }
                for (let y = -halfH; y <= halfH; y += s) {
                    ctx.rect(this.x - s/2, this.y + y - s/2, s, s);
                }
                ctx.fill();
                ctx.stroke();
                ctx.save();
                const outlineAlpha = 0.55 + 0.15 * Math.sin(shieldPulsePhase * 2.5) + (this.damageFlash > 0 ? 0.2 : 0);
                ctx.globalAlpha = Math.max(0, Math.min(1, outlineAlpha));
                ctx.strokeStyle = this.shieldLineColor || 'rgba(255, 210, 0, 0.85)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(this.x, this.y, shieldRadius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
                const w = 120, h = 6;
                ctx.fillStyle = 'rgba(100, 0, 0, 0.7)';
                ctx.fillRect(this.x - w/2, this.y - 74, w, h);
                ctx.fillStyle = 'rgba(255, 60, 60, 0.95)';
                const pct = Math.max(0, Math.min(1, this.hp / this.maxHp));
                ctx.fillRect(this.x - w/2, this.y - 74, w * pct, h);
                if (this.recentDamageFade && this.recentDamageFade > 0 && this.maxHp > 0) {
                    this.recentDamageFade = Math.max(0, this.recentDamageFade - getTimeScale());
                    const recentPct = Math.min(1, (this.recentDamage || 0) / this.maxHp);
                    const overlayStart = this.x - w/2 + w * pct;
                    const overlayWidth = Math.max(0, w * recentPct);
                    const alpha = Math.max(0, this.recentDamageFade / 45);
                    ctx.fillStyle = `rgba(255,255,255,${0.9 * alpha})`;
                    ctx.fillRect(overlayStart, this.y - 74, overlayWidth, h);
                }
                ctx.restore();
            }
        }

        // ---- Vector Snake Boss ----
        class VectorSnakeBoss {
            constructor(game) {
                this.game = game;
                this.settings = VECTOR_SNAKE_SETTINGS;
                this.segments = [];
                this.pathPoints = [];
                this.apples = [];
                this.direction = { dx: 1, dy: 0 };
                this.entryPhase = null;
                this.alive = true;
                const now = Date.now();
                this.chaseJitterState = { offsetX: 0, offsetY: 0, expiresAt: now };
                this.spawnTimestamp = now;
                this.nextTurnTime = now + this._nextTurnDelay();
                this.appleIdSeq = 1;
                this.headRecentDamage = 0;
                this.headRecentDamageFade = 0;
                this._beamHitSet = new WeakSet();
                this.speedMultiplier = 1;
                this.targetAppleId = null;
                this.appleSpawnController = this._createAppleSpawnController(now);
                this.applesConsumedBySnake = 0;
                this._initSnake();
            }

            _getHeadRadiusValue() {
                if (this.segments && this.segments.length > 0) {
                    const head = this.segments[0];
                    if (head) {
                        if (typeof head.radius === 'number') return head.radius;
                        if (typeof head.size === 'number') return head.size / 2;
                    }
                }
                const settings = this.settings || {};
                if (typeof settings.headRadius === 'number') return settings.headRadius;
                if (typeof settings.headSize === 'number') return settings.headSize / 2;
                if (typeof settings.segmentRadius === 'number') return settings.segmentRadius;
                if (typeof settings.segmentSize === 'number') return settings.segmentSize / 2;
                return 30;
            }

            _getMovementBounds() {
                const canvas = this.game.canvas;
                const settings = this.settings || {};
                const headRadius = this._getHeadRadiusValue();
                const rawEdgePadding = Math.max(headRadius, settings.edgePadding || headRadius);
                const horizontalPadding = Math.max(rawEdgePadding, settings.horizontalPadding || rawEdgePadding);
                const verticalPadding = Math.max(rawEdgePadding, settings.verticalPadding || rawEdgePadding);
                const leftPadding = Math.max(horizontalPadding, settings.leftPadding || horizontalPadding);
                const rightPadding = Math.max(horizontalPadding, settings.rightPadding || horizontalPadding);
                let topPadding = Math.max(verticalPadding, settings.topPadding || verticalPadding);
                if (!settings.ignoreBossSafeZone && this.game.getBossSafeMinCenterY) {
                    topPadding = Math.max(topPadding, this.game.getBossSafeMinCenterY());
                }
                const bottomPadding = Math.max(verticalPadding, settings.bottomPadding || verticalPadding);

                const left = Math.max(headRadius, Math.min(canvas.width - headRadius, leftPadding));
                const right = Math.max(left, Math.min(canvas.width - headRadius, canvas.width - Math.max(headRadius, rightPadding)));
                const top = Math.max(headRadius, Math.min(canvas.height - headRadius, topPadding));
                const bottom = Math.max(top, Math.min(canvas.height - headRadius, canvas.height - Math.max(headRadius, bottomPadding)));

                return { left, right, top, bottom };
            }

            _getAppleSpawnBounds() {
                const canvas = this.game.canvas;
                const bounds = this._getMovementBounds();
                const appleRadius = this.settings.appleRadius || 20;
                const left = Math.max(bounds.left, appleRadius);
                const right = Math.max(left, Math.min(bounds.right, canvas.width - appleRadius));
                const top = Math.max(bounds.top, appleRadius);
                const bottom = Math.max(top, Math.min(bounds.bottom, canvas.height - appleRadius));
                return { left, right, top, bottom };
            }

            _initSnake() {
                const settings = this.settings;
                const canvas = this.game.canvas;
                const grid = settings.gridSize || 48;
                const bounds = this._getMovementBounds();
                const randomBetween = (min, max) => {
                    if (min >= max) return min;
                    return min + Math.random() * (max - min);
                };
                const alignToGrid = (value) => Math.round(value / grid) * grid;
                let targetX = alignToGrid(randomBetween(bounds.left, bounds.right));
                let targetY = alignToGrid(randomBetween(bounds.top, bounds.bottom));
                targetX = Math.max(bounds.left, Math.min(bounds.right, targetX));
                targetY = Math.max(bounds.top, Math.min(bounds.bottom, targetY));
                const headSize = settings.headSize || (settings.headRadius ? settings.headRadius * 2 : settings.segmentSize || (settings.segmentRadius || 20) * 2);
                const headRadius = settings.headRadius || headSize / 2;
                const segmentSize = settings.segmentSize || (settings.segmentRadius || 20) * 2;
                const segmentRadius = settings.segmentRadius || segmentSize / 2;
                const segmentSpacing = settings.segmentSpacing || segmentSize;
                const initialTail = 6;
                const offscreenDistance = segmentSpacing * (initialTail + 3) + headRadius;
                const sides = ['left', 'right', 'top', 'bottom'];
                const side = sides[Math.floor(Math.random() * sides.length)];
                let startX = targetX;
                let startY = targetY;
                let direction = { dx: 1, dy: 0 };
                switch (side) {
                    case 'right':
                        direction = { dx: -1, dy: 0 };
                        startX = canvas.width + offscreenDistance;
                        break;
                    case 'top':
                        direction = { dx: 0, dy: 1 };
                        startY = -offscreenDistance;
                        break;
                    case 'bottom':
                        direction = { dx: 0, dy: -1 };
                        startY = canvas.height + offscreenDistance;
                        break;
                    default:
                        direction = { dx: 1, dy: 0 };
                        startX = -offscreenDistance;
                        break;
                }
                if (direction.dx !== 0) {
                    startY = targetY;
                } else {
                    startX = targetX;
                }
                startX = alignToGrid(startX);
                startY = alignToGrid(startY);
                this.direction = direction;
                const head = {
                    type: 'head',
                    x: startX,
                    y: startY,
                    radius: headRadius,
                    size: headSize,
                    hp: settings.headHp,
                    maxHp: settings.headHp,
                    damageFlash: 0
                };
                this.segments.push(head);
                for (let i = 1; i <= initialTail; i++) {
                    this.segments.push({
                        type: 'body',
                        x: startX - direction.dx * i * segmentSpacing,
                        y: startY - direction.dy * i * segmentSpacing,
                        radius: segmentRadius,
                        size: segmentSize,
                        hp: settings.segmentHp,
                        maxHp: settings.segmentHp,
                        damageFlash: 0
                    });
                }
                this.entryPhase = {
                    active: true,
                    side,
                    targetX,
                    targetY,
                    speedMultiplier: 1.1
                };
                this.pathPoints.length = 0;
                for (let i = 0; i < this.segments.length; i++) {
                    const seg = this.segments[i];
                    this.pathPoints.push({ x: Math.round(seg.x), y: Math.round(seg.y) });
                }
            }

            _updateEntryPhase(now, head) {
                const entry = this.entryPhase;
                if (!entry || !entry.active || !head) return;
                const motion = getMotionScale();
                const timeScale = getTimeScale();
                const baseSpeed = this.settings.movementSpeed || 3.5;
                const entrySpeedMultiplier = entry.speedMultiplier || 1.1;
                const step = baseSpeed * this.speedMultiplier * entrySpeedMultiplier * motion * timeScale;
                head.x += this.direction.dx * step;
                head.y += this.direction.dy * step;
                const targetX = entry.targetX;
                const targetY = entry.targetY;
                let reachedX = this.direction.dx === 0;
                let reachedY = this.direction.dy === 0;
                if (!reachedX) {
                    if (this.direction.dx > 0 && head.x >= targetX) {
                        head.x = targetX;
                        reachedX = true;
                    } else if (this.direction.dx < 0 && head.x <= targetX) {
                        head.x = targetX;
                        reachedX = true;
                    }
                } else {
                    head.x = targetX;
                }
                if (!reachedY) {
                    if (this.direction.dy > 0 && head.y >= targetY) {
                        head.y = targetY;
                        reachedY = true;
                    } else if (this.direction.dy < 0 && head.y <= targetY) {
                        head.y = targetY;
                        reachedY = true;
                    }
                } else {
                    head.y = targetY;
                }
                head.x = Math.round(head.x);
                head.y = Math.round(head.y);
                this.pathPoints.unshift({ x: head.x, y: head.y });
                if (this.pathPoints.length > 1) this._trimPath();
                this._updateSegmentsFromPath();
                this._updateDamageFlash();
                if (this.appleSpawnController) {
                    this.appleSpawnController.lastTimestamp = now;
                    this.appleSpawnController.accumulatorMs = 0;
                }
                if (reachedX && reachedY) {
                    entry.active = false;
                    this._alignHeadToGrid();
                    head.x = Math.round(head.x);
                    head.y = Math.round(head.y);
                    if (this.pathPoints.length > 0) {
                        this.pathPoints[0].x = head.x;
                        this.pathPoints[0].y = head.y;
                    } else {
                        this.pathPoints.unshift({ x: head.x, y: head.y });
                    }
                    this._updateSegmentsFromPath();
                    this.nextTurnTime = now + this._nextTurnDelay();
                }
            }

            _nextTurnDelay() {
                const base = this.settings.turnIntervalMs || 1500;
                const variance = this.settings.turnIntervalVarianceMs || 0;
                const offset = (Math.random() * 2 - 1) * variance;
                return Math.max(700, base + offset);
            }

            _createAppleSpawnController(now) {
                const settings = this.settings;
                const baseInterval = Math.max(400, settings.appleSpawnIntervalMs || 7000);
                const minSetting = settings.appleMinSpawnIntervalMs || baseInterval;
                const minInterval = Math.max(200, Math.min(baseInterval, minSetting));
                const rampDuration = Math.max(0, settings.appleSpawnRampDurationMs || 90000);
                return {
                    baseIntervalMs: baseInterval,
                    minIntervalMs: minInterval,
                    rampDurationMs: rampDuration,
                    currentIntervalMs: baseInterval,
                    accumulatorMs: 0,
                    lastTimestamp: now,
                    lastSpawnTimestamp: now
                };
            }

            _computeAppleSpawnTargetInterval(now) {
                const controller = this.appleSpawnController;
                if (!controller) return this.settings.appleSpawnIntervalMs || 7000;
                const base = controller.baseIntervalMs;
                const min = controller.minIntervalMs;
                if (base <= min) return min;
                const ramp = controller.rampDurationMs;
                if (!ramp || ramp <= 0) return base;
                const elapsed = Math.max(0, now - this.spawnTimestamp);
                if (elapsed >= ramp) return min;
                const progress = elapsed / ramp;
                const eased = 1 - Math.pow(1 - progress, 2);
                const target = base - (base - min) * eased;
                return Math.max(min, Math.min(base, target));
            }

            _getAppleSpawnCount() {
                if (this.applesConsumedBySnake >= 3) {
                    return 2;
                }
                return 1;
            }

            _updateAppleSpawning(now, timeScale) {
                const controller = this.appleSpawnController;
                if (!controller) return;

                const delta = Math.max(0, now - (controller.lastTimestamp || now));
                controller.lastTimestamp = now;

                const targetInterval = this._computeAppleSpawnTargetInterval(now);
                controller.currentIntervalMs = Math.max(controller.minIntervalMs, Math.min(controller.baseIntervalMs, targetInterval));
                const interval = controller.currentIntervalMs;

                const scale = typeof timeScale === 'number' && Number.isFinite(timeScale) ? Math.max(0, timeScale) : 1;
                const increment = delta * scale;
                if (Number.isFinite(increment) && increment > 0) {
                    controller.accumulatorMs = Math.max(0, controller.accumulatorMs + increment);
                }
                controller.accumulatorMs = Math.min(controller.accumulatorMs, interval * 2);

                if (this.apples.length >= this.settings.maxApples) {
                    controller.accumulatorMs = Math.min(controller.accumulatorMs, interval);
                    return;
                }

                if (controller.accumulatorMs >= interval) {
                    const desiredCount = this._getAppleSpawnCount();
                    const spawned = this._spawnAppleNearPlayer(desiredCount);
                    if (spawned > 0) {
                        controller.accumulatorMs = 0;
                        controller.lastSpawnTimestamp = now;
                        controller.currentIntervalMs = Math.max(
                            controller.minIntervalMs,
                            Math.min(controller.baseIntervalMs, this._computeAppleSpawnTargetInterval(now))
                        );
                    }
                }
            }

            update() {
                if (!this.alive) return false;
                const now = Date.now();
                const head = this.segments[0];
                if (!head) return false;
                if (this.entryPhase && this.entryPhase.active) {
                    this._updateEntryPhase(now, head);
                    return true;
                }

                const targetApple = this._findNearestApple(head);
                let steeringTarget = null;
                if (targetApple) {
                    steeringTarget = targetApple;
                    this._steerTowardsApple(targetApple, now);
                } else {
                    this.targetAppleId = null;
                    const playerTarget = this._computePlayerStalkTarget(head, now);
                    if (playerTarget) {
                        steeringTarget = playerTarget;
                        this._steerTowardsTarget(playerTarget, now);
                    } else if (now >= this.nextTurnTime) {
                        this._chooseDirection(false);
                    }
                }

                this._updateSpeedMultiplier(now);

                const motion = getMotionScale();
                const timeScale = getTimeScale();
                const baseSpeed = this.settings.movementSpeed || 3.5;
                const speed = baseSpeed * this.speedMultiplier * motion * timeScale;
                this._moveHead(speed, steeringTarget, now);
                this.pathPoints.unshift({ x: head.x, y: head.y });
                if (this.pathPoints.length > 1) this._trimPath();
                this._updateSegmentsFromPath();
                this._updateDamageFlash();

                this._updateAppleSpawning(now, timeScale);
                this._updateApples(now);
                this._checkAppleConsumption();
                return true;
            }

            _chooseDirection(forceTurn, targetPoint = null) {
                const head = this.segments[0];
                if (!head) return;
                if (targetPoint) {
                    const desired = this._selectDirectionTowards(head, targetPoint, forceTurn);
                    if (desired) {
                        if (desired.dx !== this.direction.dx || desired.dy !== this.direction.dy) {
                            this.direction = desired;
                            this._alignHeadToGrid();
                        }
                        this.nextTurnTime = Date.now() + this._nextTurnDelay();
                        return;
                    }
                }
                const options = [
                    { dx: 1, dy: 0 },
                    { dx: -1, dy: 0 },
                    { dx: 0, dy: 1 },
                    { dx: 0, dy: -1 }
                ];
                const viable = options.filter(dir => {
                    if (!forceTurn && this._isOpposite(dir, this.direction)) return false;
                    return this._directionKeepsInBounds(head, dir, targetPoint);
                });
                const pool = viable.length > 0 ? viable : options.filter(dir => !this._isOpposite(dir, this.direction));
                const chosen = pool[Math.floor(Math.random() * pool.length)] || this.direction;
                if (chosen.dx !== this.direction.dx || chosen.dy !== this.direction.dy) {
                    this.direction = chosen;
                    this._alignHeadToGrid();
                }
                this.nextTurnTime = Date.now() + this._nextTurnDelay();
            }

            _directionKeepsInBounds(head, dir, targetPoint = null) {
                if (!head || !dir) return false;
                const bounds = this._getMovementBounds();
                const tolerance = typeof this.settings.edgeTolerance === 'number'
                    ? Math.max(0, this.settings.edgeTolerance)
                    : Math.max(6, (this.settings.movementSpeed || 4) * 2);

                const nearBoundary =
                    (dir.dx < 0 && head.x <= bounds.left + tolerance) ||
                    (dir.dx > 0 && head.x >= bounds.right - tolerance) ||
                    (dir.dy < 0 && head.y <= bounds.top + tolerance) ||
                    (dir.dy > 0 && head.y >= bounds.bottom - tolerance);

                if (!nearBoundary) return true;

                if (targetPoint) {
                    const pointWithinBounds =
                        targetPoint.x >= bounds.left && targetPoint.x <= bounds.right &&
                        targetPoint.y >= bounds.top && targetPoint.y <= bounds.bottom;

                    if (pointWithinBounds) {
                        if (dir.dx < 0 && targetPoint.x <= head.x) return true;
                        if (dir.dx > 0 && targetPoint.x >= head.x) return true;
                        if (dir.dy < 0 && targetPoint.y <= head.y) return true;
                        if (dir.dy > 0 && targetPoint.y >= head.y) return true;
                    }
                }

                return false;
            }

            _isOpposite(a, b) {
                if (!a || !b) return false;
                return a.dx === -b.dx && a.dy === -b.dy;
            }

            _alignHeadToGrid() {
                const head = this.segments[0];
                if (!head) return;
                const settings = this.settings;
                const grid = settings.gridSize || 48;
                const bounds = this._getMovementBounds();
                if (this.direction.dx !== 0) {
                    head.y = Math.round(head.y / grid) * grid;
                } else if (this.direction.dy !== 0) {
                    head.x = Math.round(head.x / grid) * grid;
                }
                head.x = Math.max(bounds.left, Math.min(bounds.right, head.x));
                head.y = Math.max(bounds.top, Math.min(bounds.bottom, head.y));
            }

            _moveHead(step, targetPoint, now) {
                const head = this.segments[0];
                if (!head) return;
                const bounds = this._getMovementBounds();
                let nextX = head.x + this.direction.dx * step;
                let nextY = head.y + this.direction.dy * step;
                if (nextX < bounds.left || nextX > bounds.right || nextY < bounds.top || nextY > bounds.bottom) {
                    this._chooseDirection(true, targetPoint);
                    if (now && targetPoint && 'id' in targetPoint) {
                        this.targetAppleId = targetPoint.id || null;
                    }
                    nextX = head.x + this.direction.dx * step;
                    nextY = head.y + this.direction.dy * step;
                    if (nextX < bounds.left || nextX > bounds.right || nextY < bounds.top || nextY > bounds.bottom) {
                        this._chooseDirection(true);
                        nextX = head.x + this.direction.dx * step;
                        nextY = head.y + this.direction.dy * step;
                    }
                }
                head.x = Math.max(bounds.left, Math.min(bounds.right, nextX));
                head.y = Math.max(bounds.top, Math.min(bounds.bottom, nextY));
                head.x = Math.round(head.x);
                head.y = Math.round(head.y);
            }

            _updateSpeedMultiplier(now) {
                const interval = this.settings.speedIncreaseIntervalMs || 0;
                const percent = this.settings.speedIncreasePercent || 0;
                if (!interval || interval <= 0 || !percent || percent <= 0) {
                    this.speedMultiplier = 1;
                    return;
                }
                const elapsed = Math.max(0, now - this.spawnTimestamp);
                const steps = Math.floor(elapsed / interval);
                const base = 1 + percent;
                this.speedMultiplier = Math.pow(base, steps);
            }

            _findNearestApple(head) {
                if (!head || this.apples.length === 0) return null;
                let nearest = null;
                let nearestDistSq = Infinity;
                for (let i = 0; i < this.apples.length; i++) {
                    const apple = this.apples[i];
                    const dx = apple.x - head.x;
                    const dy = apple.y - head.y;
                    const distSq = dx * dx + dy * dy;
                    if (distSq < nearestDistSq) {
                        nearestDistSq = distSq;
                        nearest = apple;
                    }
                }
                this.targetAppleId = nearest ? nearest.id || null : null;
                return nearest;
            }

            _selectDirectionTowards(head, target, forceTurn = false) {
                if (!head || !target) return null;
                const threshold = 4;
                const dx = target.x - head.x;
                const dy = target.y - head.y;
                const candidates = [];
                if (Math.abs(dx) > threshold) {
                    candidates.push({ dx: dx > 0 ? 1 : -1, dy: 0, weight: Math.abs(dx) });
                }
                if (Math.abs(dy) > threshold) {
                    candidates.push({ dx: 0, dy: dy > 0 ? 1 : -1, weight: Math.abs(dy) });
                }
                if (candidates.length === 0) return null;
                candidates.sort((a, b) => b.weight - a.weight);

                const viable = candidates.filter(dir => this._directionKeepsInBounds(head, dir, target));
                const pool = viable.length > 0 ? viable : candidates;

                const current = pool.find(dir => dir.dx === this.direction.dx && dir.dy === this.direction.dy);
                if (current) return { dx: current.dx, dy: current.dy };

                const isPlayerTarget = target && target.targetType === 'player';
                if (!forceTurn && isPlayerTarget) {
                    const randomnessChance = this.settings.directionRandomnessChance || 0;
                    if (randomnessChance > 0 && pool.length > 1 && Math.random() < randomnessChance) {
                        const nonOppositePool = pool.filter(dir => !this._isOpposite(dir, this.direction));
                        const choicePool = nonOppositePool.length > 0 ? nonOppositePool : pool;
                        const randomChoice = choicePool[Math.floor(Math.random() * choicePool.length)];
                        if (randomChoice) {
                            return { dx: randomChoice.dx, dy: randomChoice.dy };
                        }
                    }
                }

                if (!forceTurn) {
                    const nonOpposite = pool.find(dir => !this._isOpposite(dir, this.direction));
                    if (nonOpposite) {
                        return { dx: nonOpposite.dx, dy: nonOpposite.dy };
                    }
                }

                const fallback = pool[0];
                return fallback ? { dx: fallback.dx, dy: fallback.dy } : null;
            }

            _steerTowardsTarget(target, now, options = {}) {
                const head = this.segments[0];
                if (!head || !target) return;
                const desired = this._selectDirectionTowards(head, target, !!options.forceTurn);
                if (!desired) return;
                if (desired.dx === this.direction.dx && desired.dy === this.direction.dy) return;
                this.direction = desired;
                this._alignHeadToGrid();
                this.nextTurnTime = now + this._nextTurnDelay();
                if (options.rememberTargetId && target && 'id' in target) {
                    this.targetAppleId = target.id || null;
                }
            }

            _steerTowardsApple(apple, now) {
                if (!apple) return;
                this._steerTowardsTarget(apple, now, { rememberTargetId: true });
            }

            _computePlayerStalkTarget(head, now) {
                const player = this.game && this.game.player;
                if (!player || !head) return null;
                const bounds = this._getMovementBounds();
                const desiredDistance = this.settings.playerStalkDistance || 140;
                const dx = player.x - head.x;
                const dy = player.y - head.y;
                const dist = Math.hypot(dx, dy);
                let targetX = player.x;
                let targetY = player.y;
                if (dist < desiredDistance * 0.6) {
                    const angle = dist > 0 ? Math.atan2(dy, dx) : Math.random() * Math.PI * 2;
                    targetX = player.x - Math.cos(angle) * desiredDistance;
                    targetY = player.y - Math.sin(angle) * desiredDistance;
                }
                targetX = Math.max(bounds.left, Math.min(bounds.right, targetX));
                targetY = Math.max(bounds.top, Math.min(bounds.bottom, targetY));
                let target = {
                    x: targetX,
                    y: targetY,
                    targetType: 'player'
                };
                if (typeof now === 'number' && Number.isFinite(now)) {
                    target = this._applyPlayerChaseJitter(target, now) || target;
                }
                target.x = Math.round(Math.max(bounds.left, Math.min(bounds.right, target.x)));
                target.y = Math.round(Math.max(bounds.top, Math.min(bounds.bottom, target.y)));
                return target;
            }

            _applyPlayerChaseJitter(target, now) {
                if (!target) return target;
                if (!this.chaseJitterState) {
                    this.chaseJitterState = { offsetX: 0, offsetY: 0, expiresAt: 0 };
                }
                const settings = this.settings || {};
                const interval = Math.max(240, settings.playerChaseJitterIntervalMs || 900);
                const segmentSpacing = settings.segmentSpacing || settings.segmentSize || (settings.segmentRadius || 20) * 2 || 40;
                const maxDistance = Math.max(18, settings.playerChaseJitterDistance || segmentSpacing * 1.4);
                const minSetting = settings.playerChaseJitterMinDistance;
                const minDistance = Math.max(6, Math.min(maxDistance, typeof minSetting === 'number' ? minSetting : maxDistance * 0.35));
                if (!this.chaseJitterState.expiresAt || now >= this.chaseJitterState.expiresAt) {
                    const distance = minDistance + Math.random() * (maxDistance - minDistance);
                    const angle = Math.random() * Math.PI * 2;
                    this.chaseJitterState.offsetX = Math.cos(angle) * distance;
                    this.chaseJitterState.offsetY = Math.sin(angle) * distance;
                    this.chaseJitterState.expiresAt = now + interval;
                }
                const jitteredX = target.x + this.chaseJitterState.offsetX;
                const jitteredY = target.y + this.chaseJitterState.offsetY;
                const bounds = this._getMovementBounds();
                const clampedX = Math.max(bounds.left, Math.min(bounds.right, jitteredX));
                const clampedY = Math.max(bounds.top, Math.min(bounds.bottom, jitteredY));
                return {
                    x: clampedX,
                    y: clampedY,
                    targetType: target.targetType || 'player'
                };
            }

            _maybeShootApple(apple, now) {
                if (!apple || !this.game || !Array.isArray(this.game.enemyBullets)) return;
                const interval = this.settings.appleShootIntervalMs || 2500;
                if (apple.nextShotTime === undefined) {
                    apple.nextShotTime = now + interval;
                }
                if (now < apple.nextShotTime) return;
                this._fireAppleBullets(apple);
                apple.nextShotTime = now + interval;
            }

            _fireAppleBullets(apple) {
                if (!apple || !this.game || !Array.isArray(this.game.enemyBullets)) return;
                const speed = this.settings.appleBulletSpeed || 5;
                const damage = this.settings.appleBulletDamage || 25;
                const origins = [
                    { dx: speed, dy: 0 },
                    { dx: -speed, dy: 0 },
                    { dx: 0, dy: speed },
                    { dx: 0, dy: -speed }
                ];
                for (let i = 0; i < origins.length; i++) {
                    const dir = origins[i];
                    this.game.enemyBullets.push(new EnemyBullet(apple.x, apple.y, dir.dx, dir.dy, damage));
                }
                if (this.game.audio) {
                    this.game.audio.playSound('enemyShoot');
                }
                if (this.game.effects && typeof this.game.effects.createBulletExplosion === 'function') {
                    this.game.effects.createBulletExplosion(apple.x, apple.y, '#FFC13B');
                }
            }

            _trimPath() {
                const maxDistance = (this.settings.segmentSpacing || 32) * (this.segments.length + 4);
                let accumulated = 0;
                for (let i = 0; i < this.pathPoints.length - 1; i++) {
                    const p0 = this.pathPoints[i];
                    const p1 = this.pathPoints[i + 1];
                    accumulated += Math.hypot(p1.x - p0.x, p1.y - p0.y);
                    if (accumulated >= maxDistance) {
                        this.pathPoints.length = i + 2;
                        return;
                    }
                }
            }

            _samplePath(distance) {
                if (this.pathPoints.length === 0) return null;
                let accumulated = 0;
                for (let i = 0; i < this.pathPoints.length - 1; i++) {
                    const p0 = this.pathPoints[i];
                    const p1 = this.pathPoints[i + 1];
                    const segDist = Math.hypot(p1.x - p0.x, p1.y - p0.y);
                    if (segDist <= 0) continue;
                    if (accumulated + segDist >= distance) {
                        const ratio = (distance - accumulated) / segDist;
                        return {
                            x: p0.x + (p1.x - p0.x) * ratio,
                            y: p0.y + (p1.y - p0.y) * ratio
                        };
                    }
                    accumulated += segDist;
                }
                return this.pathPoints[this.pathPoints.length - 1];
            }

            _updateSegmentsFromPath() {
                const spacing = this.settings.segmentSpacing || 32;
                for (let i = 1; i < this.segments.length; i++) {
                    const target = this._samplePath(i * spacing);
                    if (target) {
                        this.segments[i].x = Math.round(target.x);
                        this.segments[i].y = Math.round(target.y);
                    }
                }
            }

            _updateDamageFlash() {
                const t = getTimeScale();
                for (let i = 0; i < this.segments.length; i++) {
                    const seg = this.segments[i];
                    if (seg.damageFlash > 0) {
                        seg.damageFlash = Math.max(0, seg.damageFlash - t);
                    }
                }
                for (let i = 0; i < this.apples.length; i++) {
                    const apple = this.apples[i];
                    if (apple.damageFlash > 0) apple.damageFlash = Math.max(0, apple.damageFlash - t);
                }
            }

            _createAppleAt(x, y) {
                const settings = this.settings;
                const now = Date.now();
                const appleRadius = settings.appleRadius || 20;
                const apple = {
                    id: this.appleIdSeq++,
                    x,
                    y,
                    radius: appleRadius,
                    hp: settings.appleHp,
                    maxHp: settings.appleHp,
                    damageFlash: 0,
                    spawnTime: now,
                    pulse: Math.random() * Math.PI * 2,
                    nextShotTime: now + (settings.appleShootIntervalMs || 4000)
                };
                this.apples.push(apple);
                if (this.game.effects) {
                    this.game.effects.createBulletExplosion(x, y, '#ff3366');
                }
                return apple;
            }

            _spawnAppleNearPlayer(count = 1) {
                const player = this.game.player;
                if (!player || !this.game || !this.game.canvas) return 0;
                const settings = this.settings;
                const appleBounds = this._getAppleSpawnBounds();
                const bounds = this._getMovementBounds();
                const minDistance = settings.appleSpawnNearPlayerMinDistance || 80;
                const maxDistanceSetting = settings.appleSpawnNearPlayerMaxDistance || (minDistance + 160);
                let maxDistance = Math.max(minDistance + 20, maxDistanceSetting);
                const appleRadius = settings.appleRadius || 20;
                const segmentRadius = settings.segmentRadius || (settings.segmentSize || 40) / 2;
                const baseSnakePadding = segmentRadius + appleRadius + 12;
                const avoidApplePadding = appleRadius * 2 + 16;
                const maxApples = typeof settings.maxApples === 'number' ? settings.maxApples : Infinity;
                const availableSlots = Math.max(0, maxApples - this.apples.length);
                const desiredCount = Math.max(1, Math.floor(count));
                const spawnCount = Math.min(desiredCount, availableSlots);
                if (spawnCount <= 0) return 0;

                const originX = player.x;
                const originY = player.y;

                const clampX = (x) => Math.max(appleBounds.left, Math.min(appleBounds.right, x));
                const clampY = (y) => Math.max(appleBounds.top, Math.min(appleBounds.bottom, y));

                const minSeparation = spawnCount > 1 ? 600 : 0;
                if (spawnCount > 1) {
                    maxDistance = Math.max(maxDistance, minDistance + minSeparation);
                }
                const desiredDistance = (minDistance + maxDistance) * 0.5;
                const minSeparationSq = minSeparation > 0 ? minSeparation * minSeparation : 0;
                const appleAvoidSq = avoidApplePadding * avoidApplePadding;
                const pendingPositions = [];

                const selectSpawnCandidate = () => {
                    let bestCandidate = null;

                    const evaluateCandidate = (rawX, rawY, paddingMultiplier = 1) => {
                        const x = clampX(rawX);
                        const y = clampY(rawY);
                        if (x < bounds.left || x > bounds.right || y < bounds.top || y > bounds.bottom) return null;
                        const dxPlayer = x - originX;
                        const dyPlayer = y - originY;
                        const distToPlayer = Math.hypot(dxPlayer, dyPlayer);
                        if (distToPlayer < minDistance * 0.75 || distToPlayer > maxDistance * 1.2) return null;

                        const snakePadding = baseSnakePadding * paddingMultiplier;
                        let minSnakeGapSq = Infinity;
                        for (let i = 0; i < this.segments.length; i++) {
                            const seg = this.segments[i];
                            const dxSeg = x - seg.x;
                            const dySeg = y - seg.y;
                            const limit = (seg.radius || segmentRadius) + snakePadding;
                            const limitSq = limit * limit;
                            const distSq = dxSeg * dxSeg + dySeg * dySeg;
                            if (distSq <= limitSq) {
                                return null;
                            }
                            const gapSq = distSq - limitSq;
                            if (gapSq < minSnakeGapSq) minSnakeGapSq = gapSq;
                        }

                        for (let j = 0; j < this.apples.length; j++) {
                            const other = this.apples[j];
                            const dxApple = x - other.x;
                            const dyApple = y - other.y;
                            if (dxApple * dxApple + dyApple * dyApple <= appleAvoidSq) {
                                return null;
                            }
                        }

                        for (let k = 0; k < pendingPositions.length; k++) {
                            const pending = pendingPositions[k];
                            const dxPending = x - pending.x;
                            const dyPending = y - pending.y;
                            const distSqPending = dxPending * dxPending + dyPending * dyPending;
                            if (distSqPending <= appleAvoidSq) {
                                return null;
                            }
                            if (minSeparationSq > 0 && distSqPending < minSeparationSq) {
                                return null;
                            }
                        }

                        const distanceScore = Math.abs(distToPlayer - desiredDistance);
                        return { x, y, distToPlayer, distanceScore, snakeGapScore: minSnakeGapSq };
                    };

                    const considerCandidate = (x, y, paddingMultiplier = 1) => {
                        const evaluated = evaluateCandidate(x, y, paddingMultiplier);
                        if (!evaluated) return;
                        if (!bestCandidate) {
                            bestCandidate = evaluated;
                            return;
                        }
                        if (evaluated.distanceScore + 2 < bestCandidate.distanceScore) {
                            bestCandidate = evaluated;
                            return;
                        }
                        if (Math.abs(evaluated.distanceScore - bestCandidate.distanceScore) <= 2 && evaluated.snakeGapScore > bestCandidate.snakeGapScore) {
                            bestCandidate = evaluated;
                        }
                    };

                    const randomAttempts = 24;
                    for (let attempt = 0; attempt < randomAttempts; attempt++) {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = minDistance + Math.random() * (maxDistance - minDistance);
                        considerCandidate(originX + Math.cos(angle) * distance, originY + Math.sin(angle) * distance, 1);
                    }

                    if (!bestCandidate) {
                        const samples = 12;
                        for (let i = 0; i < samples; i++) {
                            const angle = (Math.PI * 2 * i) / samples;
                            const distance = desiredDistance;
                            considerCandidate(originX + Math.cos(angle) * distance, originY + Math.sin(angle) * distance, 0.9);
                            if (bestCandidate) break;
                        }
                    }

                    if (!bestCandidate) {
                        const offsets = [
                            { dx: minDistance, dy: 0 },
                            { dx: -minDistance, dy: 0 },
                            { dx: 0, dy: minDistance },
                            { dx: 0, dy: -minDistance }
                        ];
                        for (let i = 0; i < offsets.length && !bestCandidate; i++) {
                            const off = offsets[i];
                            considerCandidate(originX + off.dx, originY + off.dy, 0.75);
                        }
                    }

                    if (!bestCandidate && minSeparationSq > 0 && pendingPositions.length > 0) {
                        for (let i = 0; i < pendingPositions.length && !bestCandidate; i++) {
                            const reference = pendingPositions[i];
                            const baseAngle = Math.atan2(reference.y - originY, reference.x - originX);
                            const angles = [
                                baseAngle,
                                baseAngle + Math.PI,
                                0,
                                Math.PI / 2,
                                Math.PI,
                                (3 * Math.PI) / 2
                            ];
                            for (let ai = 0; ai < angles.length && !bestCandidate; ai++) {
                                const angle = angles[ai];
                                const candidateX = reference.x + Math.cos(angle) * minSeparation;
                                const candidateY = reference.y + Math.sin(angle) * minSeparation;
                                considerCandidate(candidateX, candidateY, 0.85);
                            }
                        }
                    }

                    if (!bestCandidate) {
                        const fallbackX = clampX(originX + desiredDistance);
                        const fallbackY = clampY(originY);
                        const fallbackCandidate = evaluateCandidate(fallbackX, fallbackY, 0.6);
                        if (fallbackCandidate) {
                            bestCandidate = fallbackCandidate;
                        } else if (minSeparationSq === 0) {
                            bestCandidate = { x: fallbackX, y: fallbackY, distToPlayer: Math.hypot(fallbackX - originX, fallbackY - originY) };
                        }
                    }

                    return bestCandidate;
                };

                for (let i = 0; i < spawnCount; i++) {
                    const candidate = selectSpawnCandidate();
                    if (!candidate) break;
                    pendingPositions.push(candidate);
                }

                for (let i = 0; i < pendingPositions.length; i++) {
                    const pos = pendingPositions[i];
                    this._createAppleAt(pos.x, pos.y);
                }

                return pendingPositions.length;
            }

            _updateApples(now) {
                const lifeMs = this.settings.appleLifetimeMs || 12000;
                const timeScale = getTimeScale();
                for (let i = this.apples.length - 1; i >= 0; i--) {
                    const apple = this.apples[i];
                    apple.pulse = (apple.pulse + 0.12 * timeScale) % (Math.PI * 2);
                    if (now - apple.spawnTime >= lifeMs) {
                        this.apples.splice(i, 1);
                        continue;
                    }
                    this._maybeShootApple(apple, now);
                }
            }

            _checkAppleConsumption() {
                for (let ai = this.apples.length - 1; ai >= 0; ai--) {
                    const apple = this.apples[ai];
                    let consumed = false;
                    for (let si = 0; si < this.segments.length; si++) {
                        const seg = this.segments[si];
                        const dx = seg.x - apple.x;
                        const dy = seg.y - apple.y;
                        const limit = seg.radius + apple.radius;
                        if (dx * dx + dy * dy <= limit * limit) {
                            consumed = true;
                            break;
                        }
                    }
                    if (consumed) {
                        this._consumeApple(ai, false);
                    }
                }
            }

            _consumeApple(index, deniedByPlayer) {
                const apple = this.apples[index];
                if (!apple) return;
                this.apples.splice(index, 1);
                if (deniedByPlayer) {
                    if (this.game.effects) {
                        this.game.effects.createExplosion(apple.x, apple.y, 'square', apple.radius * 1.2);
                    }
                    return;
                }
                this.applesConsumedBySnake = (this.applesConsumedBySnake || 0) + 1;
                this._grow(this.settings.growthPerApple || 3);
                this._triggerAppleBlast(apple.x, apple.y);
                if (this.game && typeof this.game.triggerGridBlink === 'function') {
                    this.game.triggerGridBlink(1.25, 640);
                }
                if (this.game.effects) {
                    this.game.effects.createExplosion(apple.x, apple.y, 'square', apple.radius * 1.5);
                }
                if (this.game.audio) {
                    this.game.audio.playSound('SnakeEatsApple');
                }
            }

            _triggerAppleBlast(x, y) {
                const settings = this.settings;
                const blastRadius = settings.appleBlastRadius || 100;
                if (this.game.effects && typeof this.game.effects.createSnakeAppleBlast === 'function') {
                    this.game.effects.createSnakeAppleBlast(x, y, blastRadius);
                }
                const player = this.game.player;
                if (!player || player.invulnerable) return;
                const dx = player.x - x;
                const dy = player.y - y;
                if (dx * dx + dy * dy > blastRadius * blastRadius) return;
                const damage = settings.appleBlastDamage || 25;
                const hitX = (player.x + x) / 2;
                const hitY = (player.y + y) / 2;
                player.takeDamage(damage, hitX, hitY, this.game.effects, this.game.audio);
            }

            _grow(count) {
                if (!count || count <= 0) return;
                const tail = this.segments[this.segments.length - 1] || this.segments[0];
                const settings = this.settings;
                for (let i = 0; i < count; i++) {
                    const seg = {
                        type: 'body',
                        x: tail ? tail.x : 0,
                        y: tail ? tail.y : 0,
                        radius: settings.segmentRadius || (settings.segmentSize || 40) / 2,
                        size: settings.segmentSize || (settings.segmentRadius || 20) * 2,
                        hp: settings.segmentHp,
                        maxHp: settings.segmentHp,
                        damageFlash: 0
                    };
                    this.segments.push(seg);
                    if (tail) {
                        this.pathPoints.push({ x: Math.round(tail.x), y: Math.round(tail.y) });
                    }
                }
            }

            handlePlayerBullet(bullet, effects, audio) {
                if (!this.alive) return false;
                const radius = bullet.radius || 6;
                for (let i = 0; i < this.segments.length; i++) {
                    const seg = this.segments[i];
                    const dx = bullet.x - seg.x;
                    const dy = bullet.y - seg.y;
                    const limit = radius + seg.radius;
                    if (dx * dx + dy * dy <= limit * limit) {
                        this._applyDamageToSegment(seg, bullet.damage || 0, effects, audio);
                        return true;
                    }
                }
                for (let i = 0; i < this.apples.length; i++) {
                    const apple = this.apples[i];
                    const dx = bullet.x - apple.x;
                    const dy = bullet.y - apple.y;
                    const limit = radius + apple.radius;
                    if (dx * dx + dy * dy <= limit * limit) {
                        this._applyDamageToApple(i, bullet.damage || 0, effects, audio);
                        return true;
                    }
                }
                return false;
            }

            handleRailgunBeam(effect, effects, audio) {
                if (!this.alive) return false;
                if (!effect) return false;
                if (this._beamHitSet && this._beamHitSet.has(effect)) return false;
                let hit = false;
                let blocked = false;
                let headDamaged = false;
                if (typeof effect.intersectsCircle === 'function') {
                    for (let i = 0; i < this.segments.length; i++) {
                        const seg = this.segments[i];
                        if (effect.intersectsCircle(seg.x, seg.y, seg.radius, seg)) {
                            blocked = true;
                            if (effects && typeof effects.createHitEffect === 'function') {
                                const stampKey = '_vectorSnakeRailgunSpark';
                                if (!effect[stampKey]) {
                                    effect[stampKey] = true;
                                    effects.createHitEffect(seg.x, seg.y);
                                }
                            }
                            if (seg.type === 'head') {
                                const damage = Math.max(0, effect.damage || 0);
                                if (damage > 0) {
                                    this._applyDamageToSegment(seg, damage, effects, audio);
                                    headDamaged = true;
                                    if (!this.alive) break;
                                }
                            }
                        }
                    }
                    for (let i = this.apples.length - 1; i >= 0; i--) {
                        const apple = this.apples[i];
                        if (effect.intersectsCircle(apple.x, apple.y, apple.radius, apple)) {
                            hit = true;
                            this._applyDamageToApple(i, effect.damage || 0, effects, audio);
                        }
                    }
                }
                if (headDamaged) hit = true;
                if (hit && this._beamHitSet) {
                    this._beamHitSet.add(effect);
                }
                return hit || blocked;
            }

            handleAoeDamage(x, y, radius, damage, effects, audio) {
                if (!this.alive) return;
                const limitSq = radius * radius;
                for (let i = this.segments.length - 1; i >= 0; i--) {
                    const seg = this.segments[i];
                    const dx = seg.x - x;
                    const dy = seg.y - y;
                    if (dx * dx + dy * dy <= limitSq) {
                        this._applyDamageToSegment(seg, damage, effects, audio);
                        if (!this.alive) break;
                    }
                }
                for (let i = this.apples.length - 1; i >= 0; i--) {
                    const apple = this.apples[i];
                    const dx = apple.x - x;
                    const dy = apple.y - y;
                    if (dx * dx + dy * dy <= limitSq) {
                        this._applyDamageToApple(i, damage, effects, audio);
                    }
                }
            }

            _applyDamageToSegment(segment, damage, effects, audio) {
                if (!segment || damage <= 0) return;
                segment.hp = Math.max(0, segment.hp - damage);
                segment.damageFlash = 12;
                if (effects) {
                    effects.createHitEffect(segment.x, segment.y);
                    effects.createDamageLabel(segment.x, segment.y - segment.radius - 18, damage, false);
                }
                if (segment.type === 'head') {
                    this.headRecentDamage = damage;
                    this.headRecentDamageFade = 45;
                    if (audio) audio.playSound('boss_hit');
                    if (segment.hp <= 0) {
                        this._onHeadKilled();
                    }
                } else {
                    if (audio) audio.playSound('enemyHit');
                    if (segment.hp <= 0) {
                        this._removeSegment(segment, effects);
                    }
                }
            }

            _applyDamageToApple(index, damage, effects, audio) {
                const apple = this.apples[index];
                if (!apple || damage <= 0) return;
                apple.hp = Math.max(0, apple.hp - damage);
                apple.damageFlash = 12;
                if (effects) {
                    effects.createHitEffect(apple.x, apple.y);
                    effects.createDamageLabel(apple.x, apple.y - apple.radius - 16, damage, false);
                }
                if (apple.hp <= 0) {
                    if (audio) audio.playSound('enemyDeath');
                    this._consumeApple(index, true);
                }
            }

            _removeSegment(segment, effects) {
                const idx = this.segments.indexOf(segment);
                if (idx <= 0) return;
                const removed = this.segments.splice(idx, 1)[0];
                if (removed && effects) {
                    effects.createExplosion(removed.x, removed.y, 'square', removed.radius * 1.3);
                }
            }

            _onHeadKilled() {
                if (!this.alive) return;
                this.alive = false;
                if (this.game.audio) this.game.audio.playSound('bossDefeated');
                if (this.game.effects) {
                    for (let i = 0; i < this.segments.length; i++) {
                        const seg = this.segments[i];
                        this.game.effects.createExplosion(seg.x, seg.y, 'square', seg.radius * 1.4);
                    }
                    const head = this.segments[0];
                    if (head) {
                        this.game.effects.createXPRing(head.x, head.y, 28, 240);
                    }
                }
                if (this.game) {
                    const config = ENEMY_TYPES['vector_snake_boss'] || {};
                    if (config.points) {
                        this.game.score += config.points;
                        if (this.game.uiManager && this.game.uiManager.showScoreAddition) {
                            this.game.uiManager.showScoreAddition(config.points);
                        }
                    }
                    this.game.enemiesKilled = (this.game.enemiesKilled || 0) + 1;
                }
                this.apples.length = 0;
            }

            checkPlayerCollision(player, effects, audio) {
                if (!this.alive || !player || player.invulnerable) return;
                const head = this.segments[0];
                if (head) {
                    const dx = player.x - head.x;
                    const dy = player.y - head.y;
                    const limit = player.radius + head.radius;
                    if (dx * dx + dy * dy <= limit * limit) {
                        player.takeDamage(this.settings.headCollisionDamage || 100, (player.x + head.x) / 2, (player.y + head.y) / 2, effects, audio);
                        return;
                    }
                }
                const bodyDamage = this.settings.segmentCollisionDamage || 25;
                for (let i = 1; i < this.segments.length; i++) {
                    const seg = this.segments[i];
                    const dx = player.x - seg.x;
                    const dy = player.y - seg.y;
                    const limit = player.radius + seg.radius;
                    if (dx * dx + dy * dy <= limit * limit) {
                        player.takeDamage(bodyDamage, (player.x + seg.x) / 2, (player.y + seg.y) / 2, effects, audio);
                        return;
                    }
                }
            }

            draw(ctx) {
                if (!ctx) return;
                this._drawApples(ctx);
                this._drawSnake(ctx);
                this._drawHeadHealthBar(ctx);
            }

            _drawApples(ctx) {
                for (let i = 0; i < this.apples.length; i++) {
                    const apple = this.apples[i];
                    ctx.save();
                    const pulseScale = 0.9 + 0.1 * Math.sin(apple.pulse);
                    const color = apple.damageFlash > 0 ? '#ffffff' : '#ff2244';
                    ctx.shadowBlur = 18;
                    ctx.shadowColor = '#ff2244';
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(apple.x, apple.y, apple.radius * pulseScale, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = '#ff6688';
                    ctx.stroke();
                    ctx.restore();
                }
            }

            _drawSnake(ctx) {
                for (let i = this.segments.length - 1; i >= 0; i--) {
                    const seg = this.segments[i];
                    if (!seg) continue;
                    ctx.save();
                    const isHead = seg.type === 'head';
                    const baseSize = seg.size || (seg.radius ? seg.radius * 2 : 40);
                    const drawSize = Math.max(6, baseSize - 1);
                    const half = drawSize / 2;
                    const startX = Math.round(seg.x - half);
                    const startY = Math.round(seg.y - half);
                    const bodyFill = '#8b0000';
                    const headFill = '#ff2b2b';
                    ctx.shadowBlur = isHead ? 28 : 18;
                    ctx.shadowColor = isHead ? 'rgba(255, 40, 40, 0.85)' : 'rgba(120, 0, 0, 0.6)';
                    ctx.fillStyle = seg.damageFlash > 0 ? '#ffffff' : (isHead ? headFill : bodyFill);
                    ctx.strokeStyle = isHead ? '#ff5757' : '#4c0000';
                    ctx.lineWidth = 1;
                    ctx.fillRect(startX, startY, drawSize, drawSize);
                    ctx.strokeRect(startX, startY, drawSize, drawSize);

                    if (isHead) {
                        const eyeRadius = Math.max(3, drawSize * 0.14);
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = 'rgba(255, 80, 80, 0.95)';
                        ctx.fillStyle = '#ff4444';
                        ctx.beginPath();
                        ctx.arc(seg.x, seg.y, eyeRadius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.restore();
                }
            }

            _drawHeadHealthBar(ctx) {
                const head = this.segments[0];
                if (!head) return;
                const width = 160;
                const height = 8;
                const yOffset = head.radius + 34;
                ctx.save();
                ctx.fillStyle = 'rgba(40, 0, 40, 0.7)';
                ctx.fillRect(head.x - width / 2, head.y - yOffset, width, height);
                const pct = head.maxHp > 0 ? Math.max(0, Math.min(1, head.hp / head.maxHp)) : 0;
                ctx.fillStyle = '#ff2a70';
                ctx.fillRect(head.x - width / 2, head.y - yOffset, width * pct, height);
                if (this.headRecentDamageFade > 0 && head.maxHp > 0) {
                    this.headRecentDamageFade = Math.max(0, this.headRecentDamageFade - getTimeScale());
                    const recentPct = Math.min(1, this.headRecentDamage / head.maxHp);
                    const overlayStart = head.x - width / 2 + width * pct;
                    const overlayWidth = width * recentPct;
                    const alpha = Math.max(0, this.headRecentDamageFade / 45);
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.9 * alpha})`;
                    ctx.fillRect(overlayStart, head.y - yOffset, overlayWidth, height);
                }
                ctx.restore();
            }

            isDefeated() {
                return !this.alive;
            }
        }

        class PlayerTwoBoss {
            constructor(game) {
                this.game = game;
                this.config = ENEMY_TYPES['player_2_boss'] || {};
                this.maxHealth = this.config.health || 6000;
                this.health = this.maxHealth;
                this.speed = this.config.speed || 5;
                this.radius = (this.config.size || 40) / 2;
                this.x = game.canvas.width / 2;
                const safeMinY = game.getBossSafeMinCenterY ? game.getBossSafeMinCenterY() : 120;
                this.y = Math.max(safeMinY + this.radius, game.canvas.height * 0.28);
                this.mode = 'orbit';
                this.modeExpiresAt = Date.now() + this._randomModeDuration();
                this.orbitAngle = Math.random() * Math.PI * 2;
                this.velocity = { x: 0, y: 0 };
                this.preferredDistance = this.config.preferredDistance || 380;
                this.preferredDistanceBase = this.preferredDistance;
                this.preferredDistanceVariance = this.config.preferredDistanceVariance || 80;
                this.minDistanceFromPlayer = this.config.minDistanceFromPlayer || 320;
                this.maxDistanceFromPlayer = this.config.maxDistanceFromPlayer || 500;
                this.bulletSpeed = this.config.bulletSpeed || 9.4;
                this.bulletIntervalMs = this.config.bulletIntervalMs != null ? this.config.bulletIntervalMs : 180;
                this.bulletSprayRadians = this.config.bulletSprayRadians || Math.PI / 16;
                this.orbitLerp = this.config.orbitLerp != null ? this.config.orbitLerp : 0.1;
                this.mirrorLerp = this.config.mirrorLerp != null ? this.config.mirrorLerp : 0.12;
                this.mirrorFollowFactor = this.config.mirrorFollowFactor != null ? this.config.mirrorFollowFactor : 1.02;
                this.fleeAcceleration = this.config.fleeAcceleration != null ? this.config.fleeAcceleration : 0.18;
                this.fleeBraking = this.config.fleeBraking != null ? this.config.fleeBraking : 0.12;
                this.fleeFriction = this.config.fleeFriction != null ? this.config.fleeFriction : 0.94;
                this.fleeMaxSpeedMultiplier = this.config.fleeMaxSpeedMultiplier != null ? this.config.fleeMaxSpeedMultiplier : 1.25;
                this.damageFlash = 0;
                this.recentDamage = 0;
                this.recentDamageFade = 0;
                this.alive = true;
                this.invulnerable = false;
                this.pulse = 0;
                this.glowPulse = 0;
                this.contactDamage = this.config.contactDamage || 35;
                this.bulletDamage = this.config.enemyBulletDamage || 15;
                this.rocketDamage = this.config.rocketDamage || 25;
                this.rocketPredictionSpeed = this.config.rocketPredictionSpeed || 7;
                this.mineDamage = this.config.mineDamage || 25;
                this.dashDistance = this.config.dashDistance || 280;
                this.dashDuration = Math.max(1, this.config.dashDuration || 18);
                this.dashState = {
                    active: false,
                    progress: 0,
                    duration: this.dashDuration,
                    startX: this.x,
                    startY: this.y,
                    endX: this.x,
                    endY: this.y
                };
                this._beamHitSet = new WeakSet();
                const now = Date.now();
                this.orbitRadius = this._randomPreferredRadius();
                this.nextDashTime = now + 2600 + Math.random() * 1800;
                this.nextBulletTime = now + this.bulletIntervalMs * 3;
                this.nextRocketTime = now + 2800;
                this.nextMineTime = now + 4200;
                this._lastBulletSoundTime = 0;
                this._lastPlayerX = game.player ? game.player.x : this.x;
                this._lastPlayerY = game.player ? game.player.y : this.y;
                this.distancePulsePhase = Math.random() * Math.PI * 2;
                const pulseSpeedBase = this.config.distancePulseSpeed || 0.012;
                this.distancePulseSpeed = pulseSpeedBase * (0.75 + Math.random() * 0.4);
                const maxDistanceSwing = Math.max(0, this.maxDistanceFromPlayer - this.minDistanceFromPlayer);
                const defaultAmplitude = this.preferredDistanceVariance || 60;
                const configuredAmplitude = this.config.distancePulseAmplitude;
                this.distancePulseAmplitude = Math.min(
                    maxDistanceSwing * 0.45,
                    Math.max(20, configuredAmplitude != null ? configuredAmplitude : defaultAmplitude * 0.9)
                );
                this._lastPlayerSampleTime = now;
            }

            _randomModeDuration() {
                return 5200 + Math.random() * 3800;
            }

            _randomPreferredRadius() {
                const variance = this.preferredDistanceVariance || 0;
                const randomOffset = (Math.random() - 0.5) * 2 * variance;
                const radius = this.preferredDistance + randomOffset;
                return Math.max(this.minDistanceFromPlayer, Math.min(this.maxDistanceFromPlayer, radius));
            }

            _updateDistancePulse(timeScale) {
                if (!Number.isFinite(timeScale) || timeScale <= 0) timeScale = 1;
                this.distancePulsePhase = (this.distancePulsePhase + this.distancePulseSpeed * timeScale) % (Math.PI * 2);
                const base = this.preferredDistanceBase;
                const amplitude = this.distancePulseAmplitude;
                const dynamic = base + Math.sin(this.distancePulsePhase) * amplitude;
                const clamped = Math.max(this.minDistanceFromPlayer, Math.min(this.maxDistanceFromPlayer, dynamic));
                this.preferredDistance = clamped;
                if (typeof this.orbitRadius === 'number') {
                    const lerp = Math.min(1, 0.05 * timeScale);
                    this.orbitRadius += (clamped - this.orbitRadius) * lerp;
                } else {
                    this.orbitRadius = clamped;
                }
            }

            _easeInOutCubic(t) {
                if (t <= 0) return 0;
                if (t >= 1) return 1;
                return t < 0.5
                    ? 4 * t * t * t
                    : 1 - Math.pow(-2 * t + 2, 3) / 2;
            }

            _predictTargetPosition(player, projectileSpeed, now, options = {}) {
                if (!player || !Number.isFinite(projectileSpeed) || projectileSpeed <= 0) return null;
                const prevX = this._lastPlayerX;
                const prevY = this._lastPlayerY;
                if (!Number.isFinite(prevX) || !Number.isFinite(prevY)) {
                    return { x: player.x, y: player.y, leadFrames: 0 };
                }
                const nominalFrameMs = options.nominalFrameMs || (1000 / 60);
                const lastSampleTime = this._lastPlayerSampleTime || now;
                const dtMs = Math.max(1, now - lastSampleTime);
                const frameFactor = dtMs / nominalFrameMs;
                const invFrame = frameFactor > 0 ? 1 / frameFactor : 1;
                let targetVx = (player.x - prevX) * invFrame;
                let targetVy = (player.y - prevY) * invFrame;
                const maxTargetSpeed = options.maxTargetSpeed || 14;
                const targetSpeed = Math.hypot(targetVx, targetVy);
                if (targetSpeed > maxTargetSpeed && targetSpeed > 0) {
                    const clamp = maxTargetSpeed / targetSpeed;
                    targetVx *= clamp;
                    targetVy *= clamp;
                }
                const relX = player.x - this.x;
                const relY = player.y - this.y;
                const projectileSpeedSq = projectileSpeed * projectileSpeed;
                const targetSpeedSq = targetVx * targetVx + targetVy * targetVy;
                const a = targetSpeedSq - projectileSpeedSq;
                const b = 2 * (relX * targetVx + relY * targetVy);
                const c = relX * relX + relY * relY;
                let t = 0;
                if (Math.abs(a) < 1e-6) {
                    if (Math.abs(b) > 1e-6) t = -c / b;
                } else {
                    const discriminant = b * b - 4 * a * c;
                    if (discriminant >= 0) {
                        const sqrtDisc = Math.sqrt(discriminant);
                        const t1 = (-b - sqrtDisc) / (2 * a);
                        const t2 = (-b + sqrtDisc) / (2 * a);
                        t = Math.min(t1, t2);
                        if (t < 0) t = Math.max(t1, t2);
                    }
                }
                if (!Number.isFinite(t) || t < 0) t = 0;
                const maxLead = options.maxLeadFrames || 120;
                t = Math.min(maxLead, t);
                const predictedX = player.x + targetVx * t;
                const predictedY = player.y + targetVy * t;
                if (options.clampBounds === false) {
                    return { x: predictedX, y: predictedY, leadFrames: t };
                }
                const bounds = this._getBounds();
                return {
                    x: Math.max(bounds.minX, Math.min(bounds.maxX, predictedX)),
                    y: Math.max(bounds.minY, Math.min(bounds.maxY, predictedY)),
                    leadFrames: t
                };
            }

            _chooseNextMode(now) {
                const modes = ['orbit', 'mirror', 'flee'];
                let candidate = this.mode;
                for (let attempt = 0; attempt < 5 && candidate === this.mode; attempt++) {
                    candidate = modes[Math.floor(Math.random() * modes.length)];
                }
                this.mode = candidate;
                this.modeExpiresAt = now + this._randomModeDuration();
                if (this.mode === 'orbit') {
                    this.orbitRadius = this._randomPreferredRadius();
                } else if (this.mode === 'flee') {
                    this.velocity.x *= 0.5;
                    this.velocity.y *= 0.5;
                }
            }

            _getBounds() {
                const canvas = this.game.canvas;
                const safeMinY = this.game.getBossSafeMinCenterY ? this.game.getBossSafeMinCenterY() : 120;
                const minY = Math.max(this.radius, safeMinY + this.radius * 0.25);
                return {
                    minX: this.radius,
                    maxX: canvas.width - this.radius,
                    minY,
                    maxY: canvas.height - this.radius
                };
            }

            _clampToBounds() {
                const bounds = this._getBounds();
                this.x = Math.max(bounds.minX, Math.min(bounds.maxX, this.x));
                this.y = Math.max(bounds.minY, Math.min(bounds.maxY, this.y));
            }

            _enforceDistanceFromPlayer(player) {
                if (!player) return;
                const dx = this.x - player.x;
                const dy = this.y - player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (!distance) return;
                let targetDistance = distance;
                if (distance < this.minDistanceFromPlayer) {
                    targetDistance = this.minDistanceFromPlayer;
                } else if (distance > this.maxDistanceFromPlayer) {
                    targetDistance = this.maxDistanceFromPlayer;
                }
                if (targetDistance === distance) return;
                const scale = targetDistance / distance;
                const bounds = this._getBounds();
                const targetX = player.x + dx * scale;
                const targetY = player.y + dy * scale;
                this.x = Math.max(bounds.minX, Math.min(bounds.maxX, targetX));
                this.y = Math.max(bounds.minY, Math.min(bounds.maxY, targetY));
            }

            _startDash(now, player) {
                if (!player) return false;
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const len = Math.sqrt(dx * dx + dy * dy) || 1;
                const distance = this.dashDistance;
                const targetX = this.x + (dx / len) * distance;
                const targetY = this.y + (dy / len) * distance;
                const canvas = this.game.canvas;
                const safeMinY = this.game.getBossSafeMinCenterY ? this.game.getBossSafeMinCenterY() : 120;
                const minY = Math.max(this.radius, safeMinY + this.radius * 0.25);
                const endX = Math.max(this.radius, Math.min(canvas.width - this.radius, targetX));
                const endY = Math.max(minY, Math.min(canvas.height - this.radius, targetY));
                this.dashState.active = true;
                this.dashState.progress = 0;
                this.dashState.startX = this.x;
                this.dashState.startY = this.y;
                this.dashState.endX = endX;
                this.dashState.endY = endY;
                this.dashState.duration = this.dashDuration;
                this.invulnerable = true;
                this.nextDashTime = now + 3200 + Math.random() * 2400;
                if (this.game.effects && this.game.effects.createEnemyDashEffect) {
                    this.game.effects.createEnemyDashEffect(this.x, this.y, endX, endY);
                }
                if (this.game.audio) this.game.audio.playSound('enemyDash');
                this.velocity.x = 0;
                this.velocity.y = 0;
                return true;
            }

            _updateOrbit(player, timeScale) {
                if (!player) return;
                this.orbitAngle = (this.orbitAngle + 0.02 * timeScale) % (Math.PI * 2);
                let radius = this.orbitRadius + Math.sin(this.orbitAngle * 2.3) * 24;
                radius = Math.max(this.minDistanceFromPlayer, Math.min(this.maxDistanceFromPlayer, radius));
                const targetX = player.x + Math.cos(this.orbitAngle) * radius;
                const targetY = player.y + Math.sin(this.orbitAngle) * radius;
                const bounds = this._getBounds();
                const clampedTargetX = Math.max(bounds.minX, Math.min(bounds.maxX, targetX));
                const clampedTargetY = Math.max(bounds.minY, Math.min(bounds.maxY, targetY));
                const baseLerp = this.orbitLerp != null ? this.orbitLerp : 0.1;
                const lerp = Math.min(1, Math.max(0.01, baseLerp) * timeScale);
                const startX = this.x;
                const startY = this.y;
                this.x += (clampedTargetX - this.x) * lerp;
                this.y += (clampedTargetY - this.y) * lerp;
                this.velocity.x = this.x - startX;
                this.velocity.y = this.y - startY;
            }

            _updateMirror(player, timeScale = 1) {
                if (!player) return;
                const playerDx = player.x - this._lastPlayerX;
                const playerDy = player.y - this._lastPlayerY;
                const factor = this.mirrorFollowFactor != null ? this.mirrorFollowFactor : 1.02;
                const startX = this.x;
                const startY = this.y;
                const mirroredX = this.x - playerDx * factor;
                const mirroredY = this.y - playerDy * factor;
                const offsetX = mirroredX - player.x;
                const offsetY = mirroredY - player.y;
                const dist = Math.sqrt(offsetX * offsetX + offsetY * offsetY) || 1;
                let targetDistance = this.preferredDistance;
                if (dist < this.minDistanceFromPlayer) {
                    targetDistance = this.minDistanceFromPlayer;
                } else if (dist > this.maxDistanceFromPlayer) {
                    targetDistance = this.maxDistanceFromPlayer;
                }
                const adjust = (targetDistance - dist) * 0.12;
                const bounds = this._getBounds();
                let targetX = mirroredX + (offsetX / dist) * adjust;
                let targetY = mirroredY + (offsetY / dist) * adjust;
                targetX = Math.max(bounds.minX, Math.min(bounds.maxX, targetX));
                targetY = Math.max(bounds.minY, Math.min(bounds.maxY, targetY));
                const moveLerp = Math.min(1, Math.max(0.01, this.mirrorLerp != null ? this.mirrorLerp : 0.12) * timeScale);
                this.x += (targetX - this.x) * moveLerp;
                this.y += (targetY - this.y) * moveLerp;
                this.velocity.x = this.x - startX;
                this.velocity.y = this.y - startY;
            }

            _updateFlee(player, timeScale, motion) {
                if (!player) return;
                const dx = this.x - player.x;
                const dy = this.y - player.y;
                const len = Math.sqrt(dx * dx + dy * dy) || 1;
                const awayX = dx / len;
                const awayY = dy / len;
                let accel = (this.fleeAcceleration != null ? this.fleeAcceleration : 0.25) * timeScale;
                if (len < this.minDistanceFromPlayer) {
                    accel *= 1.6;
                }
                this.velocity.x += awayX * accel;
                this.velocity.y += awayY * accel;
                if (len > this.maxDistanceFromPlayer) {
                    const braking = (this.fleeBraking != null ? this.fleeBraking : 0.18) * timeScale;
                    this.velocity.x -= awayX * braking;
                    this.velocity.y -= awayY * braking;
                }
                const speedMultiplier = this.fleeMaxSpeedMultiplier != null ? this.fleeMaxSpeedMultiplier : 1.4;
                const maxSpeed = (this.speed || 5) * speedMultiplier;
                const velLen = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y);
                if (velLen > maxSpeed) {
                    const s = maxSpeed / velLen;
                    this.velocity.x *= s;
                    this.velocity.y *= s;
                }
                const bounds = this._getBounds();
                let nextX = this.x + this.velocity.x * motion;
                let nextY = this.y + this.velocity.y * motion;
                const buffer = Math.max(12, this.radius * 0.4);
                if (nextX < bounds.minX + buffer) {
                    nextX = Math.max(bounds.minX, nextX);
                    this.velocity.x = Math.max(0, this.velocity.x * 0.4);
                } else if (nextX > bounds.maxX - buffer) {
                    nextX = Math.min(bounds.maxX, nextX);
                    this.velocity.x = Math.min(0, this.velocity.x * 0.4);
                }
                if (nextY < bounds.minY + buffer) {
                    nextY = Math.max(bounds.minY, nextY);
                    this.velocity.y = Math.max(0, this.velocity.y * 0.4);
                } else if (nextY > bounds.maxY - buffer) {
                    nextY = Math.min(bounds.maxY, nextY);
                    this.velocity.y = Math.min(0, this.velocity.y * 0.4);
                }
                this.x = Math.max(bounds.minX, Math.min(bounds.maxX, nextX));
                this.y = Math.max(bounds.minY, Math.min(bounds.maxY, nextY));
                const frictionBase = this.fleeFriction != null ? this.fleeFriction : 0.92;
                const friction = Math.pow(frictionBase, timeScale);
                this.velocity.x *= friction;
                this.velocity.y *= friction;
            }

            _maybeFireBullet(now, player) {
                if (!player || now < this.nextBulletTime || !Array.isArray(this.game.enemyBullets)) return;
                const speed = this.bulletSpeed;
                const prediction = this._predictTargetPosition(player, speed, now, { maxLeadFrames: 110 });
                const targetX = prediction ? prediction.x : player.x;
                const targetY = prediction ? prediction.y : player.y;
                const baseAngle = Math.atan2(targetY - this.y, targetX - this.x);
                const leadBasedSpray = prediction && prediction.leadFrames > 0 ? 0.6 : 1;
                const spray = (Math.random() - 0.5) * this.bulletSprayRadians * leadBasedSpray;
                const angle = baseAngle + spray;
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;
                this.game.enemyBullets.push(new EnemyBullet(
                    this.x,
                    this.y,
                    vx,
                    vy,
                    this.bulletDamage,
                    {
                        fillColor: '#ff4a4a',
                        strokeColor: '#ff1c1c',
                        glowColor: 'rgba(255, 56, 56, 0.9)',
                        trailColor: '#ff5f5f'
                    }
                ));
                if (this.game.audio) {
                    if (!this._lastBulletSoundTime || now - this._lastBulletSoundTime > 360) {
                        this.game.audio.playSound('enemyShoot');
                        this._lastBulletSoundTime = now;
                    }
                }
                this.nextBulletTime = now + this.bulletIntervalMs;
            }

            _maybeFireRocket(now, player) {
                if (!player || now < this.nextRocketTime || !Array.isArray(this.game.enemyRockets)) return;
                const prediction = this._predictTargetPosition(player, this.rocketPredictionSpeed, now, {
                    maxLeadFrames: 180
                });
                const aimX = prediction ? prediction.x : player.x;
                const aimY = prediction ? prediction.y : player.y;
                const rocket = new EnemyRocket(this.x, this.y, aimX, aimY, this.rocketDamage, {
                    trailColor: '#FFA500',
                    glowColor: 'rgba(255, 64, 64, 0.9)',
                    aoeRadius: 110
                });
                this.game.enemyRockets.push(rocket);
                if (this.game.audio) this.game.audio.playSound('RocketLaunch');
                this.nextRocketTime = now + 6000;
            }

            _maybePlaceMine(now) {
                if (now < this.nextMineTime || !Array.isArray(this.game.enemyMines)) return;
                const mine = new EnemyMine(this.x, this.y, this.radius, this.mineDamage, {
                    glowColor: 'rgba(255, 60, 60, 0.9)',
                    aoeRadius: 110
                });
                this.game.enemyMines.push(mine);
                if (this.game.audio) this.game.audio.playSound('mine_placed');
                this.nextMineTime = now + 10000;
            }

            update() {
                if (!this.alive) return;
                const player = this.game.player;
                const now = Date.now();
                const timeScale = getTimeScale();
                const motion = getMotionScale();
                this._updateDistancePulse(timeScale);
                if (this.damageFlash > 0) this.damageFlash = Math.max(0, this.damageFlash - timeScale);
                if (this.recentDamageFade > 0) this.recentDamageFade = Math.max(0, this.recentDamageFade - timeScale);
                this.pulse = (this.pulse + 0.04 * timeScale) % (Math.PI * 2);
                this.glowPulse = (this.glowPulse + 0.03 * timeScale) % (Math.PI * 2);
                if (!this.dashState.active && now >= this.nextDashTime) {
                    this._startDash(now, player);
                }
                if (this.dashState.active) {
                    const prevX = this.x;
                    const prevY = this.y;
                    this.dashState.progress += timeScale;
                    const ratio = Math.min(1, this.dashState.progress / this.dashState.duration);
                    const easedRatio = this._easeInOutCubic(ratio);
                    this.x = this.dashState.startX + (this.dashState.endX - this.dashState.startX) * easedRatio;
                    this.y = this.dashState.startY + (this.dashState.endY - this.dashState.startY) * easedRatio;
                    this.velocity.x = this.x - prevX;
                    this.velocity.y = this.y - prevY;
                    if (ratio >= 1) {
                        this.dashState.active = false;
                        this.invulnerable = false;
                        this.dashState.progress = 0;
                    }
                } else {
                    if (now >= this.modeExpiresAt) {
                        this._chooseNextMode(now);
                    }
                    if (this.mode === 'orbit') {
                        this._updateOrbit(player, timeScale);
                    } else if (this.mode === 'mirror') {
                        this._updateMirror(player, timeScale);
                    } else {
                        this._updateFlee(player, timeScale, motion);
                    }
                }
                this._clampToBounds();
                if (!this.dashState.active && player) {
                    this._enforceDistanceFromPlayer(player);
                    this._clampToBounds();
                }
                if (player) {
                    this._maybeFireBullet(now, player);
                    this._maybeFireRocket(now, player);
                    this._maybePlaceMine(now);
                    this._lastPlayerX = player.x;
                    this._lastPlayerY = player.y;
                    this._lastPlayerSampleTime = now;
                }
            }

            takeDamage(amount, effects, audio, metadata = {}) {
                if (!this.alive || this.invulnerable || amount <= 0) return false;
                this.health = Math.max(0, this.health - amount);
                this.damageFlash = 12;
                this.recentDamage = amount;
                this.recentDamageFade = 45;
                const impactX = metadata.impactX != null ? metadata.impactX : this.x;
                const impactY = metadata.impactY != null ? metadata.impactY : this.y;
                if (effects && typeof effects.createHitEffect === 'function') {
                    effects.createHitEffect(impactX, impactY);
                    if (typeof effects.createDamageLabel === 'function') {
                        effects.createDamageLabel(impactX, impactY - this.radius - 18, amount, false);
                    }
                }
                if (audio) audio.playSound('boss_hit');
                if (this.health <= 0) {
                    this._onDefeated(effects, audio);
                    return false;
                }
                return true;
            }

            handlePlayerBullet(bullet, effects, audio) {
                if (!bullet) return false;
                const radius = (bullet.radius || 6) + this.radius;
                const dx = bullet.x - this.x;
                const dy = bullet.y - this.y;
                if (dx * dx + dy * dy <= radius * radius) {
                    this.takeDamage(bullet.damage || 0, effects, audio, { impactX: bullet.x, impactY: bullet.y });
                    return true;
                }
                return false;
            }

            handleRailgunBeam(effect, effects, audio) {
                if (!effect || !this.alive || typeof effect.intersectsCircle !== 'function') return false;
                if (this._beamHitSet && this._beamHitSet.has(effect)) return false;
                if (effect.intersectsCircle(this.x, this.y, this.radius, this)) {
                    if (this._beamHitSet) this._beamHitSet.add(effect);
                    this.takeDamage(effect.damage || 0, effects, audio, { impactX: this.x, impactY: this.y });
                    return true;
                }
                return false;
            }

            handleAoeDamage(x, y, radius, damage, effects, audio) {
                if (!this.alive || damage <= 0) return;
                const limit = this.radius + radius;
                const dx = this.x - x;
                const dy = this.y - y;
                if (dx * dx + dy * dy <= limit * limit) {
                    this.takeDamage(damage, effects, audio, { impactX: (this.x + x) / 2, impactY: (this.y + y) / 2 });
                }
            }

            checkPlayerCollision(player, effects, audio) {
                if (!this.alive || !player || player.invulnerable || player.isDashing) return;
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const limit = player.radius + this.radius;
                if (dx * dx + dy * dy <= limit * limit) {
                    const impactX = (player.x + this.x) / 2;
                    const impactY = (player.y + this.y) / 2;
                    player.takeDamage(this.contactDamage, impactX, impactY, effects, audio);
                }
            }

            _onDefeated(effects, audio) {
                if (!this.alive) return;
                this.alive = false;
                if (audio) audio.playSound('bossDefeated');
                if (effects) {
                    if (typeof effects.createExplosion === 'function') {
                        const explosionType = (this.config && this.config.bossBaseType && ENEMY_TYPES[this.config.bossBaseType])
                            ? this.config.bossBaseType
                            : (ENEMY_TYPES['player_2_boss'] ? 'player_2_boss' : 'square');
                        effects.createExplosion(this.x, this.y, explosionType, this.radius * 2.2);
                    }
                    if (typeof effects.createEnemyRocketExplosionRing === 'function') {
                        effects.createEnemyRocketExplosionRing(this.x, this.y, this.radius * 3);
                    }
                    const xpAmount = this.config.xp || 0;
                    if (xpAmount > 0 && typeof effects.createXPRing === 'function') {
                        effects.createXPRing(this.x, this.y, this.radius * 1.2, xpAmount);
                    }
                }
                if (this.game) {
                    const points = this.config.points || 0;
                    this.game.score += points;
                    if (this.game.uiManager && this.game.uiManager.showScoreAddition) {
                        this.game.uiManager.showScoreAddition(points);
                    }
                    this.game.enemiesKilled = (this.game.enemiesKilled || 0) + 1;
                    if (Array.isArray(this.game.enemyRockets)) this.game.enemyRockets.length = 0;
                    if (Array.isArray(this.game.enemyMines)) this.game.enemyMines.length = 0;
                }
            }

            draw(ctx) {
                if (!ctx) return;
                ctx.save();
                const glowColor = this.config.glowColor || 'rgba(255, 64, 64, 0.85)';
                const pulseScale = 1 + 0.05 * Math.sin(this.pulse);
                const drawRadius = this.radius * pulseScale;
                const isDashing = this.dashState.active;
                const dashAlpha = isDashing ? 0.42 : 1;
                if (dashAlpha < 1) {
                    ctx.globalAlpha = dashAlpha;
                }
                ctx.shadowColor = glowColor;
                ctx.shadowBlur = 24 + 6 * Math.sin(this.glowPulse * 1.6);
                ctx.beginPath();
                ctx.arc(this.x, this.y, drawRadius, 0, Math.PI * 2);
                ctx.fillStyle = this.damageFlash > 0 ? '#ffffff' : (this.config.fillColor || '#ff2e2e');
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.lineWidth = 3;
                ctx.strokeStyle = this.config.strokeColor || '#c40000';
                ctx.stroke();
                ctx.restore();
                this._drawHealthBar(ctx);
            }

            _drawHealthBar(ctx) {
                const width = 180;
                const height = 10;
                const offset = this.radius + 38;
                ctx.save();
                ctx.fillStyle = 'rgba(40, 0, 0, 0.65)';
                ctx.fillRect(this.x - width / 2, this.y - offset, width, height);
                const pct = this.maxHealth > 0 ? Math.max(0, Math.min(1, this.health / this.maxHealth)) : 0;
                ctx.fillStyle = '#ff4242';
                ctx.fillRect(this.x - width / 2, this.y - offset, width * pct, height);
                if (this.recentDamageFade > 0 && this.maxHealth > 0) {
                    const alpha = this.recentDamageFade / 45;
                    const recentPct = Math.min(1, (this.recentDamage || 0) / this.maxHealth);
                    const overlayStart = this.x - width / 2 + width * pct;
                    const overlayWidth = width * recentPct;
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.85 * alpha})`;
                    ctx.fillRect(overlayStart, this.y - offset, overlayWidth, height);
                }
                ctx.restore();
            }

            isDefeated() {
                return !this.alive;
            }
        }

        class PingAndPongBoss {
            constructor(game) {
                this.game = game;
                this.config = ENEMY_TYPES['ping_and_pong_boss'] || {};
                this.type = 'ping_and_pong_boss';
                const canvas = game.canvas;
                const radius = this.config.ballRadius || Math.max(40, (this.config.size || 80) / 2);
                const safeMinY = this._getSafeMinY();
                const startY = Math.max(safeMinY + radius, canvas.height * 0.35);
                const ballHealth = this.config.ballHealth || this.config.health || 5000;
                const baseSpeed = this.config.ballBaseSpeed || 6;
                this.ballMinHorizontalRatio = this.config.ballMinHorizontalRatio != null
                    ? Math.min(0.98, Math.max(0.5, this.config.ballMinHorizontalRatio))
                    : 0.78;
                const derivedMaxVertical = Math.sqrt(Math.max(0.0001, 1 - this.ballMinHorizontalRatio * this.ballMinHorizontalRatio));
                if (this.config.ballMaxVerticalRatio != null) {
                    const candidate = Math.max(0.05, this.config.ballMaxVerticalRatio);
                    this.ballMaxVerticalRatio = Math.min(derivedMaxVertical, Math.min(0.99, candidate));
                } else {
                    this.ballMaxVerticalRatio = derivedMaxVertical;
                }
                this.ballInitialAngleMax = this.config.ballInitialMaxAngle != null
                    ? Math.min(Math.PI / 2 - 0.01, Math.max(0.01, this.config.ballInitialMaxAngle))
                    : Math.PI / 7;
                const horizontalDirection = Math.random() < 0.5 ? -1 : 1;
                const angleRange = this.ballInitialAngleMax;
                const initialAngle = (Math.random() * 2 - 1) * angleRange;
                const initialVx = Math.cos(initialAngle) * baseSpeed * horizontalDirection;
                const initialVy = Math.sin(initialAngle) * baseSpeed;
                this.ball = {
                    x: canvas.width / 2,
                    y: startY,
                    radius,
                    speed: baseSpeed,
                    maxSpeed: this.config.ballMaxSpeed || Math.max(baseSpeed, 14),
                    vx: initialVx,
                    vy: initialVy,
                    health: ballHealth,
                    maxHealth: ballHealth,
                    damageFlash: 0,
                    recentDamage: 0,
                    recentDamageFade: 0
                };
                const norm = Math.hypot(this.ball.vx, this.ball.vy) || 1;
                if (norm > 0) {
                    this.ball.vx = (this.ball.vx / norm) * baseSpeed;
                    this.ball.vy = (this.ball.vy / norm) * baseSpeed;
                }
                this._enforceBallAngle(this.ball);
                const paddleWidth = this.config.paddleWidth || 20;
                const paddleHeight = this.config.paddleHeight || 80;
                const inset = Math.max(24, this.config.barrierInset || 56);
                this.leftPaddle = {
                    x: inset + paddleWidth / 2,
                    y: this.ball.y,
                    width: paddleWidth,
                    height: paddleHeight,
                    damageFlash: 0
                };
                this.rightPaddle = {
                    x: canvas.width - inset - paddleWidth / 2,
                    y: this.ball.y,
                    width: paddleWidth,
                    height: paddleHeight,
                    damageFlash: 0
                };
                this.extraBalls = [];
                this.alive = true;
                this.energyWaveInterval = Math.max(500, this.config.energyWaveIntervalMs || 4000);
                this.energyWaveDamage = this.config.energyWaveDamage != null ? this.config.energyWaveDamage : (this.config.ballContactDamage || 25);
                this.lastEnergyWaveTime = Date.now();
                this.nextExtraBallTime = null;
                this.lastPaddleHitTime = 0;
                this.extraBallMaxBounces = this.config.extraBallMaxBounces || 8;
                this.maxExtraBalls = this.config.maxExtraBalls || 4;
                this.extraBallExplosionRadius = this.config.extraBallExplosionRadius || 120;
                this.extraBallExplosionDamage = this.config.extraBallExplosionDamage || 25;
                this.extraBallContactDamage = this.config.extraBallContactDamage || 25;
                this.paddleDamage = this.config.paddleDamage || 300;
                this.ballContactDamage = this.config.ballContactDamage || 25;
                this._beamHitRegistry = new WeakMap();
                this.x = this.ball.x;
                this.y = this.ball.y;
                this.radius = this.ball.radius;
                this.extraBallSpawnDelayMs = Math.max(1000, this.config.extraBallSpawnDelayMs || 10000);
                this.paddleDesyncMs = this.config.paddleDesyncMs != null ? Math.max(0, this.config.paddleDesyncMs) : 320;
                this.ballHistory = [];
                this.paddleNoisePhaseLeft = Math.random() * Math.PI * 2;
                this.paddleNoisePhaseRight = Math.random() * Math.PI * 2;
                this.paddleNoiseAmplitude = this.config.paddleNoiseAmplitude != null ? this.config.paddleNoiseAmplitude : 12;
                this.paddleNoiseSpeed = this.config.paddleNoiseSpeed != null ? this.config.paddleNoiseSpeed : 0.022;
                this.rocketIntervalMs = Math.max(800, this.config.paddleRocketIntervalMs || 3000);
                this.nextRocketTime = Date.now() + (this.config.paddleRocketInitialDelayMs || 1500);
                this.nextRocketSide = Math.random() < 0.5 ? 'left' : 'right';
                this.paddleRocketDamage = this.config.paddleRocketDamage || 22;
                this.paddleRocketOptions = {
                    initialSpeed: this.config.paddleRocketInitialSpeed != null ? this.config.paddleRocketInitialSpeed : 4.2,
                    acceleration: this.config.paddleRocketAcceleration != null ? this.config.paddleRocketAcceleration : 0.15,
                    radius: this.config.paddleRocketRadius != null ? this.config.paddleRocketRadius : 9,
                    aoeRadius: this.config.paddleRocketAoe != null ? this.config.paddleRocketAoe : 110,
                    life: this.config.paddleRocketLife != null ? this.config.paddleRocketLife : 240,
                    trailColor: this.config.paddleRocketTrailColor || '#ff5b5b',
                    glowColor: this.config.paddleRocketGlowColor || (this.config.paddleGlowColor || 'rgba(255, 32, 32, 0.9)')
                };
            }

            _getSafeMinY() {
                if (this.game && typeof this.game.getBossSafeMinCenterY === 'function') {
                    return this.game.getBossSafeMinCenterY();
                }
                return 120;
            }

            _clamp(value, min, max) {
                return Math.max(min, Math.min(max, value));
            }

            _enforceBallAngle(ball) {
                if (!ball) return;
                let targetSpeed = Number.isFinite(ball.speed) && ball.speed > 0 ? ball.speed : Math.hypot(ball.vx, ball.vy);
                if (!Number.isFinite(targetSpeed) || targetSpeed <= 0) return;
                const minRatio = Math.min(0.98, Math.max(0.2, this.ballMinHorizontalRatio || 0.7));
                const derivedMax = Math.sqrt(Math.max(0, 1 - minRatio * minRatio));
                const configuredMax = this.ballMaxVerticalRatio != null ? Math.max(0.05, Math.min(0.99, this.ballMaxVerticalRatio)) : derivedMax;
                const maxRatio = Math.min(configuredMax, derivedMax);
                const horizontalSign = ball.vx >= 0 ? 1 : -1;
                const verticalSign = ball.vy === 0 ? (Math.random() < 0.5 ? -1 : 1) : (ball.vy > 0 ? 1 : -1);
                let vx = Math.abs(ball.vx);
                let vy = Math.abs(ball.vy);
                const minHorizontal = minRatio * targetSpeed;
                const maxVertical = maxRatio * targetSpeed;
                if (vx < minHorizontal) vx = minHorizontal;
                if (vx > targetSpeed) vx = targetSpeed;
                if (vy > maxVertical) vy = maxVertical;
                const remaining = targetSpeed * targetSpeed - vx * vx;
                const maxVyFromRemaining = remaining > 0 ? Math.sqrt(remaining) : 0;
                if (vy > maxVyFromRemaining) vy = maxVyFromRemaining;
                const magnitude = Math.hypot(vx, vy);
                if (magnitude <= 0) {
                    vx = targetSpeed;
                    vy = 0;
                }
                const scale = magnitude > 0 ? targetSpeed / magnitude : 1;
                ball.vx = vx * horizontalSign * scale;
                ball.vy = vy * verticalSign * scale;
                ball.speed = targetSpeed;
            }

            _playBounceSound() {
                if (this.game && this.game.audio && typeof this.game.audio.playSound === 'function') {
                    this.game.audio.playSound('PongBossBallBounce');
                }
            }

            _recordBallHistory(now) {
                if (!this.ball || !Number.isFinite(this.ball.y)) return;
                if (!Number.isFinite(now)) now = Date.now();
                if (!this.ballHistory) this.ballHistory = [];
                this.ballHistory.push({ time: now, y: this.ball.y });
                const retentionMs = Math.max(1200, (this.paddleDesyncMs || 0) + 600);
                while (this.ballHistory.length > 0 && now - this.ballHistory[0].time > retentionMs) {
                    this.ballHistory.shift();
                }
            }

            _getHistoricalBallY(targetTime) {
                if (!this.ballHistory || this.ballHistory.length === 0) {
                    return this.ball && Number.isFinite(this.ball.y) ? this.ball.y : 0;
                }
                if (!Number.isFinite(targetTime)) {
                    return this.ballHistory[0].y;
                }
                for (let i = this.ballHistory.length - 1; i >= 0; i--) {
                    const entry = this.ballHistory[i];
                    if (entry.time <= targetTime) {
                        return entry.y;
                    }
                }
                return this.ballHistory[0].y;
            }

            _computePaddleNoise(side, timeScale) {
                if (!this.paddleNoiseAmplitude || this.paddleNoiseAmplitude === 0) return 0;
                const phaseProp = side === 'right' ? 'paddleNoisePhaseRight' : 'paddleNoisePhaseLeft';
                const currentPhase = Number.isFinite(this[phaseProp]) ? this[phaseProp] : 0;
                const speed = this.paddleNoiseSpeed || 0;
                const scaledTime = Number.isFinite(timeScale) ? Math.max(0, timeScale) : 1;
                const updatedPhase = (currentPhase + speed * scaledTime) % (Math.PI * 2);
                this[phaseProp] = updatedPhase;
                const offset = side === 'right' ? Math.PI / 3 : 0;
                return Math.sin(updatedPhase + offset) * this.paddleNoiseAmplitude;
            }

            _updateRocketAttacks(now) {
                if (!this.alive || !this.game || !Array.isArray(this.game.enemyRockets)) return;
                if (!Number.isFinite(this.rocketIntervalMs) || this.rocketIntervalMs <= 0) return;
                if (!Number.isFinite(now)) now = Date.now();
                if (!this.nextRocketTime) {
                    this.nextRocketTime = now + this.rocketIntervalMs;
                }
                if (now < this.nextRocketTime) return;
                const side = this.nextRocketSide === 'right' ? 'right' : 'left';
                const fired = this._firePaddleRocket(side);
                if (fired) {
                    this.nextRocketSide = side === 'left' ? 'right' : 'left';
                    this.nextRocketTime = now + this.rocketIntervalMs;
                } else {
                    this.nextRocketTime = now + 600;
                }
            }

            _firePaddleRocket(side) {
                if (!this.game || !Array.isArray(this.game.enemyRockets)) return false;
                const player = this.game.player;
                if (!player || !Number.isFinite(player.x) || !Number.isFinite(player.y)) return false;
                const paddle = side === 'right' ? this.rightPaddle : this.leftPaddle;
                if (!paddle) return false;
                const originX = paddle.x;
                const originY = paddle.y;
                const options = Object.assign({}, this.paddleRocketOptions);
                const rocket = new EnemyRocket(originX, originY, player.x, player.y, this.paddleRocketDamage, options);
                this.game.enemyRockets.push(rocket);
                if (this.game.audio && typeof this.game.audio.playSound === 'function') {
                    this.game.audio.playSound('RocketLaunch');
                }
                if (this.game.effects && typeof this.game.effects.createRocketTrail === 'function') {
                    this.game.effects.createRocketTrail(originX, originY, options.trailColor || '#ff5b5b');
                }
                return true;
            }

            _circleCircleIntersect(ax, ay, ar, bx, by, br) {
                const dx = ax - bx;
                const dy = ay - by;
                const limit = ar + br;
                return dx * dx + dy * dy <= limit * limit;
            }

            _circleRectIntersect(cx, cy, radius, rect) {
                if (!rect) return false;
                const halfW = rect.width / 2;
                const halfH = rect.height / 2;
                const minX = rect.x - halfW;
                const maxX = rect.x + halfW;
                const minY = rect.y - halfH;
                const maxY = rect.y + halfH;
                const closestX = this._clamp(cx, minX, maxX);
                const closestY = this._clamp(cy, minY, maxY);
                const dx = cx - closestX;
                const dy = cy - closestY;
                return dx * dx + dy * dy <= radius * radius;
            }

            _closestPointOnRect(cx, cy, rect) {
                const halfW = rect.width / 2;
                const halfH = rect.height / 2;
                const minX = rect.x - halfW;
                const maxX = rect.x + halfW;
                const minY = rect.y - halfH;
                const maxY = rect.y + halfH;
                return {
                    x: this._clamp(cx, minX, maxX),
                    y: this._clamp(cy, minY, maxY)
                };
            }

            _getVerticalBounds() {
                const canvas = this.game.canvas;
                const safeMin = this._getSafeMinY();
                const half = (this.config.paddleHeight || 80) / 2;
                const top = Math.max(safeMin, half + 10);
                const bottom = canvas.height - 10;
                return { top, bottom };
            }

            _isBallAlignedWithPaddle(ball, paddle) {
                if (!paddle) return false;
                const effectiveHalf = paddle.height / 2 + ball.radius * 0.7;
                return Math.abs(ball.y - paddle.y) <= effectiveHalf;
            }

            _bounceBallFromPaddle(paddle, ball, direction, now) {
                if (!paddle || !ball) return;
                paddle.damageFlash = 10;
                const offset = this._clamp((ball.y - paddle.y) / (paddle.height / 2), -1, 1);
                ball.x = paddle.x + direction * (paddle.width / 2 + ball.radius + 1);
                ball.vx = Math.abs(ball.vx) * direction;
                ball.vy += offset * ball.speed * 0.55;
                const increment = this.config.ballSpeedIncrement || 0.4;
                const maxSpeed = this.ball.maxSpeed || (ball.speed + increment);
                ball.speed = this._clamp(ball.speed + increment, increment, maxSpeed);
                const norm = Math.hypot(ball.vx, ball.vy) || 1;
                ball.vx = (ball.vx / norm) * ball.speed;
                ball.vy = (ball.vy / norm) * ball.speed;
                this._enforceBallAngle(ball);
                this.lastPaddleHitTime = now;
                if (!this.nextExtraBallTime) {
                    this.nextExtraBallTime = now + this.extraBallSpawnDelayMs;
                }
                if (this.game.effects && typeof this.game.effects.createShieldImpact === 'function') {
                    this.game.effects.createShieldImpact(ball.x - direction * ball.radius * 0.6, ball.y, Math.max(30, paddle.height * 0.6), 'paddle');
                }
                this._playBounceSound();
            }

            _handlePaddleCollisions(ball, now) {
                if (!ball) return;
                const leftPlane = this.leftPaddle.x + this.leftPaddle.width / 2;
                if (ball.vx < 0 && ball.x - ball.radius <= leftPlane) {
                    if (this._isBallAlignedWithPaddle(ball, this.leftPaddle)) {
                        this._bounceBallFromPaddle(this.leftPaddle, ball, 1, now);
                    } else {
                        ball.x = leftPlane + ball.radius;
                        ball.vx = Math.abs(ball.vx);
                        this._playBounceSound();
                    }
                }
                const rightPlane = this.rightPaddle.x - this.rightPaddle.width / 2;
                if (ball.vx > 0 && ball.x + ball.radius >= rightPlane) {
                    if (this._isBallAlignedWithPaddle(ball, this.rightPaddle)) {
                        this._bounceBallFromPaddle(this.rightPaddle, ball, -1, now);
                    } else {
                        ball.x = rightPlane - ball.radius;
                        ball.vx = -Math.abs(ball.vx);
                        this._playBounceSound();
                    }
                }
            }

            _updateBall(now, motion, timeScale) {
                const ball = this.ball;
                ball.x += ball.vx * motion;
                ball.y += ball.vy * motion;
                const canvas = this.game.canvas;
                const safeTop = this._getSafeMinY() + ball.radius;
                const topLimit = Math.max(ball.radius, safeTop);
                const bottomLimit = canvas.height - ball.radius;
                if (ball.y < topLimit) {
                    ball.y = topLimit;
                    ball.vy = Math.abs(ball.vy);
                    this._playBounceSound();
                } else if (ball.y > bottomLimit) {
                    ball.y = bottomLimit;
                    ball.vy = -Math.abs(ball.vy);
                    this._playBounceSound();
                }
                this._handlePaddleCollisions(ball, now);
                const leftLimit = ball.radius;
                const rightLimit = canvas.width - ball.radius;
                if (ball.x < leftLimit) {
                    ball.x = leftLimit;
                    ball.vx = Math.abs(ball.vx);
                    this._playBounceSound();
                } else if (ball.x > rightLimit) {
                    ball.x = rightLimit;
                    ball.vx = -Math.abs(ball.vx);
                    this._playBounceSound();
                }
                this._enforceBallAngle(ball);
                this._recordBallHistory(now);
                if (ball.damageFlash > 0) ball.damageFlash = Math.max(0, ball.damageFlash - timeScale);
                if (ball.recentDamageFade > 0) ball.recentDamageFade = Math.max(0, ball.recentDamageFade - timeScale);
            }

            _updatePaddles(timeScale, now) {
                const lerpBase = this.config.paddleFollowLerp || 0.18;
                const rightBase = this.config.paddleFollowLerpRight != null ? this.config.paddleFollowLerpRight : lerpBase * 0.72;
                const lerpFactorLeft = 1 - Math.pow(Math.max(0, 1 - lerpBase), Math.max(1, timeScale));
                const lerpFactorRight = 1 - Math.pow(Math.max(0, 1 - rightBase), Math.max(1, timeScale));
                const bounds = this._getVerticalBounds();
                const leftHalf = this.leftPaddle.height / 2;
                const rightHalf = this.rightPaddle.height / 2;
                const leftNoise = this._computePaddleNoise('left', timeScale);
                const rightNoise = this._computePaddleNoise('right', timeScale);
                const leftTarget = this.ball.y + leftNoise;
                const desyncMs = this.paddleDesyncMs || 0;
                const historicalY = desyncMs > 0 ? this._getHistoricalBallY((now || Date.now()) - desyncMs) : this.ball.y;
                const rightTarget = historicalY + rightNoise;
                this.leftPaddle.y += (leftTarget - this.leftPaddle.y) * lerpFactorLeft;
                this.rightPaddle.y += (rightTarget - this.rightPaddle.y) * lerpFactorRight;
                this.leftPaddle.y = this._clamp(this.leftPaddle.y, bounds.top + leftHalf, bounds.bottom - leftHalf);
                this.rightPaddle.y = this._clamp(this.rightPaddle.y, bounds.top + rightHalf, bounds.bottom - rightHalf);
                if (this.leftPaddle.damageFlash > 0) this.leftPaddle.damageFlash = Math.max(0, this.leftPaddle.damageFlash - timeScale);
                if (this.rightPaddle.damageFlash > 0) this.rightPaddle.damageFlash = Math.max(0, this.rightPaddle.damageFlash - timeScale);
            }

            _spawnExtraBall() {
                if (!this.alive) return;
                if (this.extraBalls.length >= this.maxExtraBalls) return;
                const radius = this.config.extraBallRadius || 26;
                const speed = this.config.extraBallSpeed || 7.5;
                const baseAngle = Math.atan2(this.ball.vy, this.ball.vx);
                const angle = baseAngle + (Math.random() - 0.5) * (Math.PI / 3);
                const extra = {
                    x: this.ball.x,
                    y: this.ball.y,
                    radius,
                    speed,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    health: this.config.extraBallHealth || 100,
                    maxHealth: this.config.extraBallHealth || 100,
                    bounceCount: 0,
                    damageFlash: 0,
                    recentDamage: 0,
                    recentDamageFade: 0
                };
                this.extraBalls.push(extra);
                if (this.game.effects) {
                    this._createLaunchEffect(extra.x, extra.y);
                }
                if (this.game.audio) this.game.audio.playSound('enemyShoot');
            }

            _createLaunchEffect(x, y) {
                if (!this.game || !this.game.effects || !this.game.effects.effects) return;
                const life = 22;
                this.game.effects.effects.push(new Effect('pingPongLaunch', x, y, {
                    life,
                    maxLife: life,
                    radius: 12,
                    opacity: 0.8,
                    typeSpecificUpdate: function() {
                        const t = getTimeScale();
                        this.life -= t;
                        const progress = 1 - (this.life / this.maxLife);
                        this.radius = 12 + 28 * progress;
                        this.opacity = Math.max(0, 0.8 - progress * 0.8);
                        return this.life > 0;
                    },
                    typeSpecificDraw: function(ctx) {
                        if (!ctx) return;
                        ctx.save();
                        ctx.globalAlpha = Math.max(0, this.opacity);
                        ctx.strokeStyle = '#ff4455';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.restore();
                    }
                }));
            }

            _updateExtraBalls(motion, timeScale) {
                const canvas = this.game.canvas;
                const safeMinY = this._getSafeMinY();
                for (let i = this.extraBalls.length - 1; i >= 0; i--) {
                    const extra = this.extraBalls[i];
                    extra.x += extra.vx * motion;
                    extra.y += extra.vy * motion;
                    let bounced = false;
                    if (extra.x - extra.radius <= 0) {
                        extra.x = extra.radius;
                        extra.vx = Math.abs(extra.vx);
                        extra.bounceCount++;
                        bounced = true;
                    } else if (extra.x + extra.radius >= canvas.width) {
                        extra.x = canvas.width - extra.radius;
                        extra.vx = -Math.abs(extra.vx);
                        extra.bounceCount++;
                        bounced = true;
                    }
                    const topLimit = Math.max(extra.radius, safeMinY + extra.radius);
                    const bottomLimit = canvas.height - extra.radius;
                    if (extra.y - extra.radius <= topLimit) {
                        extra.y = topLimit;
                        extra.vy = Math.abs(extra.vy);
                        extra.bounceCount++;
                        bounced = true;
                    } else if (extra.y + extra.radius >= bottomLimit) {
                        extra.y = bottomLimit;
                        extra.vy = -Math.abs(extra.vy);
                        extra.bounceCount++;
                        bounced = true;
                    }
                    if (bounced && extra.bounceCount >= this.extraBallMaxBounces) {
                        this._explodeExtraBall(extra, { withDamage: true });
                        this.extraBalls.splice(i, 1);
                        continue;
                    }
                    if (extra.damageFlash > 0) extra.damageFlash = Math.max(0, extra.damageFlash - timeScale);
                    if (extra.recentDamageFade > 0) extra.recentDamageFade = Math.max(0, extra.recentDamageFade - timeScale);
                }
            }

            _emitEnergyWave() {
                const radius = this.config.energyWaveRadius || 150;
                this._createEnergyWaveEffect(this.ball.x, this.ball.y, radius);
                const player = this.game.player;
                if (player && !player.invulnerable && !player.isDashing) {
                    const dx = player.x - this.ball.x;
                    const dy = player.y - this.ball.y;
                    if (dx * dx + dy * dy <= radius * radius) {
                        const impactX = (player.x + this.ball.x) / 2;
                        const impactY = (player.y + this.ball.y) / 2;
                        player.takeDamage(this.energyWaveDamage, impactX, impactY, this.game.effects, this.game.audio);
                    }
                }
                if (this.game.audio) this.game.audio.playSound('enemyDash');
            }

            _createEnergyWaveEffect(x, y, maxRadius) {
                if (!this.game || !this.game.effects || !this.game.effects.effects) return;
                const life = 30;
                this.game.effects.effects.push(new Effect('pingPongEnergyWave', x, y, {
                    life,
                    maxLife: life,
                    radius: 0,
                    maxRadius,
                    opacity: 1,
                    lineWidth: 5,
                    typeSpecificUpdate: function() {
                        const t = getTimeScale();
                        this.life -= t;
                        const progress = 1 - (this.life / this.maxLife);
                        this.radius = this.maxRadius * Math.pow(progress, 0.78);
                        this.opacity = Math.max(0, 0.9 - progress * 0.9);
                        this.lineWidth = Math.max(1.5, 5 - 3.5 * progress);
                        return this.life > 0;
                    },
                    typeSpecificDraw: function(ctx) {
                        if (!ctx) return;
                        ctx.save();
                        ctx.globalAlpha = Math.max(0, this.opacity);
                        ctx.strokeStyle = '#ff3344';
                        ctx.lineWidth = this.lineWidth || 2;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.restore();
                    }
                }));
            }

            _blockProjectile(x, y, effects, audio) {
                const fx = effects || (this.game ? this.game.effects : null);
                if (fx && typeof fx.createShieldImpact === 'function') {
                    fx.createShieldImpact(x, y, Math.max(30, this.ball.radius * 0.9), 'shield');
                } else if (fx && typeof fx.createBulletExplosion === 'function') {
                    fx.createBulletExplosion(x, y, '#ff3344');
                }
                if (audio) audio.playSound('enemyDash');
            }

            blockCircularProjectile(circle, effects, audio) {
                if (!circle) return false;
                const fx = effects || (this.game ? this.game.effects : null);
                const au = audio || (this.game ? this.game.audio : null);
                if (this._circleRectIntersect(circle.x, circle.y, circle.radius, this.leftPaddle)) {
                    this.leftPaddle.damageFlash = 10;
                    this._blockProjectile(circle.x, circle.y, fx, au);
                    return true;
                }
                if (this._circleRectIntersect(circle.x, circle.y, circle.radius, this.rightPaddle)) {
                    this.rightPaddle.damageFlash = 10;
                    this._blockProjectile(circle.x, circle.y, fx, au);
                    return true;
                }
                return false;
            }

            interceptPlayerRocket(rocket, effects, audio) {
                if (!rocket || !this.alive) return null;
                const fx = effects || (this.game ? this.game.effects : null);
                const au = audio || (this.game ? this.game.audio : null);
                const circle = { x: rocket.x, y: rocket.y, radius: rocket.radius };
                if (this.blockCircularProjectile(circle, fx, au)) {
                    return {
                        consumed: true,
                        explosion: true,
                        x: rocket.x,
                        y: rocket.y,
                        radius: rocket.aoeRadius,
                        damage: rocket.damage,
                        applyDamageToBoss: false
                    };
                }
                if (this._circleCircleIntersect(rocket.x, rocket.y, rocket.radius, this.ball.x, this.ball.y, this.ball.radius)) {
                    return {
                        consumed: true,
                        explosion: true,
                        x: rocket.x,
                        y: rocket.y,
                        radius: rocket.aoeRadius,
                        damage: rocket.damage,
                        applyDamageToBoss: true
                    };
                }
                for (let i = this.extraBalls.length - 1; i >= 0; i--) {
                    const extra = this.extraBalls[i];
                    if (!extra) continue;
                    if (this._circleCircleIntersect(rocket.x, rocket.y, rocket.radius, extra.x, extra.y, extra.radius)) {
                        const destroyed = this._damageExtraBall(extra, rocket.damage || 0, fx, au, rocket.x, rocket.y);
                        if (destroyed) {
                            this._explodeExtraBall(extra, { withDamage: false });
                            this.extraBalls.splice(i, 1);
                        }
                        return {
                            consumed: true,
                            explosion: true,
                            x: rocket.x,
                            y: rocket.y,
                            radius: rocket.aoeRadius,
                            damage: rocket.damage,
                            applyDamageToBoss: false
                        };
                    }
                }
                return null;
            }

            interceptPlayerMine(mine, effects, audio) {
                if (!mine || !this.alive) return null;
                const fx = effects || (this.game ? this.game.effects : null);
                const au = audio || (this.game ? this.game.audio : null);
                const circle = { x: mine.x, y: mine.y, radius: mine.radius };
                if (this.blockCircularProjectile(circle, fx, au)) {
                    return {
                        consumed: true,
                        explosion: true,
                        x: mine.x,
                        y: mine.y,
                        radius: mine.aoeRadius,
                        damage: mine.damage,
                        applyDamageToBoss: false
                    };
                }
                if (this._circleCircleIntersect(mine.x, mine.y, mine.radius, this.ball.x, this.ball.y, this.ball.radius)) {
                    return {
                        consumed: true,
                        explosion: true,
                        x: mine.x,
                        y: mine.y,
                        radius: mine.aoeRadius,
                        damage: mine.damage,
                        applyDamageToBoss: true
                    };
                }
                for (let i = this.extraBalls.length - 1; i >= 0; i--) {
                    const extra = this.extraBalls[i];
                    if (!extra) continue;
                    if (this._circleCircleIntersect(mine.x, mine.y, mine.radius, extra.x, extra.y, extra.radius)) {
                        const destroyed = this._damageExtraBall(extra, mine.damage || 0, fx, au, mine.x, mine.y);
                        if (destroyed) {
                            this._explodeExtraBall(extra, { withDamage: false });
                            this.extraBalls.splice(i, 1);
                        }
                        return {
                            consumed: true,
                            explosion: true,
                            x: mine.x,
                            y: mine.y,
                            radius: mine.aoeRadius,
                            damage: mine.damage,
                            applyDamageToBoss: false
                        };
                    }
                }
                return null;
            }

            _damageExtraBall(extra, damage, effects, audio, impactX, impactY) {
                if (!extra || damage <= 0) return false;
                extra.health = Math.max(0, extra.health - damage);
                extra.damageFlash = 10;
                extra.recentDamage = damage;
                extra.recentDamageFade = 35;
                const fxX = impactX != null ? impactX : extra.x;
                const fxY = impactY != null ? impactY : extra.y;
                if (effects && typeof effects.createHitEffect === 'function') {
                    effects.createHitEffect(fxX, fxY);
                }
                if (effects && typeof effects.createDamageLabel === 'function') {
                    effects.createDamageLabel(extra.x, extra.y - extra.radius - 14, damage, false);
                }
                if (audio) audio.playSound('enemyHit');
                return extra.health <= 0;
            }

            _explodeExtraBall(extra, options = {}) {
                if (!extra) return;
                const fx = this.game && this.game.effects;
                const au = this.game && this.game.audio;
                if (fx && typeof fx.createExplosion === 'function') {
                    fx.createExplosion(extra.x, extra.y, 'ping_and_pong_boss', extra.radius * 1.5);
                }
                if (fx && fx.effects) {
                    const life = 22;
                    fx.effects.push(new Effect('pingPongExtraBlast', extra.x, extra.y, {
                        life,
                        maxLife: life,
                        radius: 0,
                        maxRadius: this.extraBallExplosionRadius,
                        opacity: 0.9,
                        typeSpecificUpdate: function() {
                            const t = getTimeScale();
                            this.life -= t;
                            const progress = 1 - (this.life / this.maxLife);
                            this.radius = this.maxRadius * Math.pow(progress, 0.8);
                            this.opacity = Math.max(0, 0.9 - progress * 0.9);
                            return this.life > 0;
                        },
                        typeSpecificDraw: function(ctx) {
                            if (!ctx) return;
                            ctx.save();
                            ctx.globalAlpha = Math.max(0, this.opacity);
                            ctx.fillStyle = 'rgba(255, 64, 64, 0.2)';
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.globalAlpha = Math.max(0, this.opacity);
                            ctx.strokeStyle = '#ff5566';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.restore();
                        }
                    }));
                }
                if (!options.silent && au) {
                    au.playSound('enemyDeath');
                }
                if (options.withDamage) {
                    const player = this.game && this.game.player;
                    if (player && !player.invulnerable && !player.isDashing) {
                        const dx = player.x - extra.x;
                        const dy = player.y - extra.y;
                        if (dx * dx + dy * dy <= this.extraBallExplosionRadius * this.extraBallExplosionRadius) {
                            const impactX = (player.x + extra.x) / 2;
                            const impactY = (player.y + extra.y) / 2;
                            player.takeDamage(this.extraBallExplosionDamage, impactX, impactY, this.game.effects, au);
                        }
                    }
                }
            }

            takeDamage(amount, effects, audio, metadata = {}) {
                if (!this.alive || amount <= 0) return false;
                this.ball.health = Math.max(0, this.ball.health - amount);
                this.ball.damageFlash = 12;
                this.ball.recentDamage = amount;
                this.ball.recentDamageFade = 45;
                const impactX = metadata.impactX != null ? metadata.impactX : this.ball.x;
                const impactY = metadata.impactY != null ? metadata.impactY : this.ball.y;
                if (effects && typeof effects.createHitEffect === 'function') {
                    effects.createHitEffect(impactX, impactY);
                }
                if (effects && typeof effects.createDamageLabel === 'function') {
                    effects.createDamageLabel(this.ball.x, this.ball.y - this.ball.radius - 22, amount, false);
                }
                if (audio) audio.playSound('boss_hit');
                if (this.ball.health <= 0) {
                    this._onDefeated(effects, audio);
                    return false;
                }
                return true;
            }

            handlePlayerBullet(bullet, effects, audio) {
                if (!bullet || !this.alive) return false;
                const fx = effects || (this.game ? this.game.effects : null);
                const au = audio || (this.game ? this.game.audio : null);
                const radius = bullet.radius || 6;
                if (this.blockCircularProjectile({ x: bullet.x, y: bullet.y, radius }, fx, au)) {
                    return true;
                }
                if (this._circleCircleIntersect(bullet.x, bullet.y, radius, this.ball.x, this.ball.y, this.ball.radius)) {
                    this.takeDamage(bullet.damage || 0, fx, au, { impactX: bullet.x, impactY: bullet.y });
                    return true;
                }
                for (let i = this.extraBalls.length - 1; i >= 0; i--) {
                    const extra = this.extraBalls[i];
                    if (this._circleCircleIntersect(bullet.x, bullet.y, radius, extra.x, extra.y, extra.radius)) {
                        const destroyed = this._damageExtraBall(extra, bullet.damage || 0, fx, au, bullet.x, bullet.y);
                        if (destroyed) {
                            this._explodeExtraBall(extra, { withDamage: false });
                            this.extraBalls.splice(i, 1);
                        }
                        return true;
                    }
                }
                return false;
            }

            _hasBeamHit(effect, target) {
                const registry = this._beamHitRegistry.get(effect);
                return registry ? registry.has(target) : false;
            }

            _markBeamHit(effect, target) {
                let registry = this._beamHitRegistry.get(effect);
                if (!registry) {
                    registry = new WeakSet();
                    this._beamHitRegistry.set(effect, registry);
                }
                registry.add(target);
            }

            handleRailgunBeam(effect, effects, audio) {
                if (!effect || !this.alive || typeof effect.intersectsCircle !== 'function') return false;
                const fx = effects || (this.game ? this.game.effects : null);
                const au = audio || (this.game ? this.game.audio : null);
                if (effect.intersectsCircle(this.ball.x, this.ball.y, this.ball.radius, this.ball) && !this._hasBeamHit(effect, this.ball)) {
                    this._markBeamHit(effect, this.ball);
                    this.takeDamage(effect.damage || 0, fx, au, { impactX: this.ball.x, impactY: this.ball.y });
                }
                for (let i = this.extraBalls.length - 1; i >= 0; i--) {
                    const extra = this.extraBalls[i];
                    if (effect.intersectsCircle(extra.x, extra.y, extra.radius, extra) && !this._hasBeamHit(effect, extra)) {
                        this._markBeamHit(effect, extra);
                        const destroyed = this._damageExtraBall(extra, effect.damage || 0, fx, au, extra.x, extra.y);
                        if (destroyed) {
                            this._explodeExtraBall(extra, { withDamage: false });
                            this.extraBalls.splice(i, 1);
                        }
                    }
                }
                return false;
            }

            handleAoeDamage(x, y, radius, damage, effects, audio) {
                if (!this.alive || damage <= 0) return;
                const fx = effects || (this.game ? this.game.effects : null);
                const au = audio || (this.game ? this.game.audio : null);
                if (this._circleCircleIntersect(this.ball.x, this.ball.y, this.ball.radius, x, y, radius)) {
                    this.takeDamage(damage, fx, au, { impactX: (this.ball.x + x) / 2, impactY: (this.ball.y + y) / 2 });
                }
                for (let i = this.extraBalls.length - 1; i >= 0; i--) {
                    const extra = this.extraBalls[i];
                    if (this._circleCircleIntersect(extra.x, extra.y, extra.radius, x, y, radius)) {
                        const destroyed = this._damageExtraBall(extra, damage, fx, au, (extra.x + x) / 2, (extra.y + y) / 2);
                        if (destroyed) {
                            this._explodeExtraBall(extra, { withDamage: false });
                            this.extraBalls.splice(i, 1);
                        }
                    }
                }
            }

            checkPlayerCollision(player, effects, audio) {
                if (!this.alive || !player || player.invulnerable || player.isDashing) return;
                const fx = effects || (this.game ? this.game.effects : null);
                const au = audio || (this.game ? this.game.audio : null);
                const radius = player.radius || 20;
                if (this._circleRectIntersect(player.x, player.y, radius, this.leftPaddle)) {
                    const point = this._closestPointOnRect(player.x, player.y, this.leftPaddle);
                    player.takeDamage(this.paddleDamage, point.x, point.y, fx, au);
                    this.leftPaddle.damageFlash = 10;
                    return;
                }
                if (this._circleRectIntersect(player.x, player.y, radius, this.rightPaddle)) {
                    const point = this._closestPointOnRect(player.x, player.y, this.rightPaddle);
                    player.takeDamage(this.paddleDamage, point.x, point.y, fx, au);
                    this.rightPaddle.damageFlash = 10;
                    return;
                }
                if (this._circleCircleIntersect(player.x, player.y, radius, this.ball.x, this.ball.y, this.ball.radius)) {
                    const impactX = (player.x + this.ball.x) / 2;
                    const impactY = (player.y + this.ball.y) / 2;
                    player.takeDamage(this.ballContactDamage, impactX, impactY, fx, au);
                    return;
                }
                for (let i = 0; i < this.extraBalls.length; i++) {
                    const extra = this.extraBalls[i];
                    if (this._circleCircleIntersect(player.x, player.y, radius, extra.x, extra.y, extra.radius)) {
                        const impactX = (player.x + extra.x) / 2;
                        const impactY = (player.y + extra.y) / 2;
                        player.takeDamage(this.extraBallContactDamage, impactX, impactY, fx, au);
                        return;
                    }
                }
            }

            _drawPaddle(ctx, paddle) {
                if (!paddle) return;
                ctx.save();
                ctx.shadowColor = this.config.paddleGlowColor || 'rgba(255, 32, 32, 0.9)';
                ctx.shadowBlur = 20;
                ctx.fillStyle = paddle.damageFlash > 0 ? '#ffffff' : 'rgba(255, 70, 70, 0.95)';
                ctx.fillRect(paddle.x - paddle.width / 2, paddle.y - paddle.height / 2, paddle.width, paddle.height);
                ctx.shadowBlur = 0;
                ctx.lineWidth = 2;
                ctx.strokeStyle = 'rgba(120, 0, 0, 0.9)';
                ctx.strokeRect(paddle.x - paddle.width / 2, paddle.y - paddle.height / 2, paddle.width, paddle.height);
                ctx.restore();
            }

            _drawExtraBall(ctx, extra) {
                if (!extra) return;
                ctx.save();
                ctx.shadowColor = this.config.glowColor || 'rgba(255, 48, 48, 0.85)';
                ctx.shadowBlur = 18;
                ctx.fillStyle = extra.damageFlash > 0 ? '#ffffff' : '#ff5566';
                ctx.beginPath();
                ctx.arc(extra.x, extra.y, extra.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#aa0011';
                ctx.stroke();
                ctx.restore();
            }

            _drawHealthBar(ctx) {
                const width = 220;
                const height = 12;
                const offset = this.ball.radius + 60;
                ctx.save();
                ctx.fillStyle = 'rgba(60, 0, 0, 0.65)';
                ctx.fillRect(this.ball.x - width / 2, this.ball.y - offset, width, height);
                const pct = this.ball.maxHealth > 0 ? Math.max(0, Math.min(1, this.ball.health / this.ball.maxHealth)) : 0;
                ctx.fillStyle = '#ff4242';
                ctx.fillRect(this.ball.x - width / 2, this.ball.y - offset, width * pct, height);
                if (this.ball.recentDamageFade > 0 && this.ball.maxHealth > 0) {
                    const alpha = this.ball.recentDamageFade / 45;
                    const recentPct = Math.min(1, (this.ball.recentDamage || 0) / this.ball.maxHealth);
                    const overlayStart = this.ball.x - width / 2 + width * pct;
                    const overlayWidth = width * recentPct;
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.85 * alpha})`;
                    ctx.fillRect(overlayStart, this.ball.y - offset, overlayWidth, height);
                }
                ctx.restore();
            }

            draw(ctx) {
                if (!ctx) return;
                const now = Date.now();
                const waveRatio = this.energyWaveInterval > 0 ? this._clamp((now - this.lastEnergyWaveTime) / this.energyWaveInterval, 0, 1) : 0;
                const telegraphRadius = (this.config.energyWaveRadius || 150) * (0.45 + 0.35 * waveRatio);
                ctx.save();
                ctx.globalAlpha = 0.25 + 0.25 * Math.sin(waveRatio * Math.PI * 2);
                ctx.strokeStyle = 'rgba(255, 80, 80, 0.9)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.ball.x, this.ball.y, telegraphRadius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
                this._drawPaddle(ctx, this.leftPaddle);
                this._drawPaddle(ctx, this.rightPaddle);
                ctx.save();
                ctx.shadowColor = this.config.glowColor || 'rgba(255, 48, 48, 0.85)';
                ctx.shadowBlur = 26;
                ctx.fillStyle = this.ball.damageFlash > 0 ? '#ffffff' : (this.config.fillColor || '#ff3344');
                ctx.beginPath();
                ctx.arc(this.ball.x, this.ball.y, this.ball.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.lineWidth = 3;
                ctx.strokeStyle = this.config.strokeColor || '#aa0011';
                ctx.stroke();
                ctx.restore();
                for (let i = 0; i < this.extraBalls.length; i++) {
                    this._drawExtraBall(ctx, this.extraBalls[i]);
                }
                this._drawHealthBar(ctx);
            }

            update() {
                if (!this.alive) return;
                const timeScale = getTimeScale();
                const motion = getMotionScale();
                const now = Date.now();
                this._updateBall(now, motion, timeScale);
                this._updatePaddles(timeScale, now);
                this._updateExtraBalls(motion, timeScale);
                this._updateRocketAttacks(now);
                const scaledInterval = this.energyWaveInterval / Math.max(0.0001, timeScale);
                if (now - this.lastEnergyWaveTime >= scaledInterval) {
                    this._emitEnergyWave();
                    this.lastEnergyWaveTime = now;
                }
                if (this.nextExtraBallTime && now >= this.nextExtraBallTime) {
                    this._spawnExtraBall();
                    this.nextExtraBallTime = null;
                }
                this.x = this.ball.x;
                this.y = this.ball.y;
                this.radius = this.ball.radius;
            }

            isDefeated() {
                return !this.alive;
            }

            _onDefeated(effects, audio) {
                if (!this.alive) return;
                this.alive = false;
                const fx = effects || (this.game ? this.game.effects : null);
                const au = audio || (this.game ? this.game.audio : null);
                if (fx && typeof fx.createExplosion === 'function') {
                    fx.createExplosion(this.ball.x, this.ball.y, 'ping_and_pong_boss', this.ball.radius * 2.4);
                }
                if (fx && typeof fx.createEnemyRocketExplosionRing === 'function') {
                    fx.createEnemyRocketExplosionRing(this.ball.x, this.ball.y, (this.config.energyWaveRadius || 150) * 1.1);
                }
                if (fx && typeof fx.createXPRing === 'function') {
                    const xp = this.config.xp || 0;
                    if (xp > 0) fx.createXPRing(this.ball.x, this.ball.y, this.ball.radius * 1.4, xp);
                }
                for (let i = this.extraBalls.length - 1; i >= 0; i--) {
                    const extra = this.extraBalls[i];
                    this._explodeExtraBall(extra, { withDamage: false, silent: true });
                }
                this.extraBalls.length = 0;
                if (au) au.playSound('bossDefeated');
                if (this.game) {
                    const points = this.config.points || 0;
                    this.game.score += points;
                    if (this.game.uiManager && this.game.uiManager.showScoreAddition) {
                        this.game.uiManager.showScoreAddition(points);
                    }
                    this.game.enemiesKilled = (this.game.enemiesKilled || 0) + 1;
                }
            }
        }

        // UI Manager for handling UI visibility
        class UIManager {
            constructor() {
                // Cache DOM nodes once
                this.enemiesEl = document.querySelector('.enemies');
                this.timerEl = document.querySelector('.timer');
                this.scoreEl = document.querySelector('.score');
                this.waveEl = document.querySelector('.wave');
                this.controlsEl = document.querySelector('.controls');
                this.xpLabelEl = document.querySelector('.xp-label');
                this.xpBarEl = document.querySelector('.xp-bar');
                this.xpLevelEl = document.querySelector('.xp-level');
                this.uiElements = [
                    this.enemiesEl,
                    this.timerEl,
                    this.scoreEl,
                    this.waveEl,
                    this.controlsEl,
                    this.xpLabelEl,
                    this.xpBarEl,
                    this.xpLevelEl
                ];
                this.nextWaveElement = document.querySelector('#nextWave');
                this.bossNameLabelElement = document.querySelector('#bossNameLabel');
                this.currentBossLabel = '';
                this.currentBossSoundKey = '';
                this.scoreAdditionElement = document.querySelector('#scoreAddition');
                this.scoreAdditionTimeout = null;
                this.xpFill = document.getElementById('xpFill');
                this.xpLevel = document.getElementById('xpLevel');
                // DEV: FPS indicator element
                this.fpsEl = document.getElementById('fps');
                this.bossWarningShown = false;
                // XP gain overlay
                this.xpGainOverlayWidth = 0; // percent [0..1]
                this.xpGainFade = 0; // frames left
                // Cache overlay element and width as needed
                this.xpOverlayEl = null;
                this._cachedXpBarClientWidth = 0;
                // Cached value spans
                this.scoreValueEl = document.getElementById('score');
                this.enemiesValueEl = document.getElementById('enemies');
                this.timerValueEl = document.getElementById('timer');
                this.waveValueEl = document.getElementById('wave');
                this._lastFpsLabelTs = 0;
            }

            updateFPS(fps) {
                if (!this.fpsEl) return;
                const value = Math.round(fps);
                const nowTs = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
                if (this._lastFpsLabelTs && (nowTs - this._lastFpsLabelTs) < 250) return;
                this._lastFpsLabelTs = nowTs;
                let color = '#00ff00'; // green
                if (value < 30) color = '#ff4444'; // red
                else if (value < 50) color = '#ffcc00'; // yellow
                this.fpsEl.textContent = `FPS: ${value}`;
                this.fpsEl.style.color = color;
            }

            updateStats(score, kills, timeText, wave) {
                if (this.scoreValueEl) this.scoreValueEl.textContent = score;
                if (this.enemiesValueEl) this.enemiesValueEl.textContent = kills;
                if (this.timerValueEl) this.timerValueEl.textContent = timeText;
                if (this.waveValueEl) this.waveValueEl.textContent = wave;
            }

            hideUI() {
                this.uiElements.forEach(element => {
                    if (element) {
                        element.classList.add('hidden');
                    }
                });
                this.hideNextWaveTimer();
                  this.clearBossNameLabel();
            }

            showUI() {
                this.uiElements.forEach(element => {
                    if (element) {
                        element.classList.remove('hidden');
                    }
                });
            }
            
            showControlsInfo() {
                if (this.controlsEl) {
                    this.controlsEl.classList.remove('controls-hidden');
                }
            }

            hideControlsInfo() {
                if (this.controlsEl) {
                    this.controlsEl.classList.add('controls-hidden');
                }
            }

            showNextWaveTimer(seconds) {
                if (this.nextWaveElement) {
                    this.nextWaveElement.textContent = `Next Wave in ${seconds}`;
                    this.nextWaveElement.style.display = 'block';
                }
            }
            
              hideNextWaveTimer() {
                  if (this.nextWaveElement) {
                      this.nextWaveElement.style.display = 'none';
                  }
              }

              clearBossNameLabel() {
                  this.currentBossLabel = '';
                  if (!this.bossNameLabelElement) return;
                  this.bossNameLabelElement.classList.remove('boss-name-show');
                  this.bossNameLabelElement.style.display = 'none';
                  this.bossNameLabelElement.textContent = '';
                  this.currentBossSoundKey = '';
              }

              playBossSpawnCue(bossKey) {
                  if (!bossKey || typeof BOSS_SPAWN_SOUND_MAP !== 'object') return;
                  const soundKey = BOSS_SPAWN_SOUND_MAP[bossKey];
                  if (!soundKey || this.currentBossSoundKey === soundKey) return;
                  if (typeof window === 'undefined' || !window.game || !window.game.audio) return;
                  this.currentBossSoundKey = soundKey;
                  window.game.audio.playSound(soundKey);
              }

              showBossWarning(bossLabelText = '', bossKey = '') {
                  if (!this.nextWaveElement) return;
                  this.nextWaveElement.textContent = 'Boss is Approaching';
                  this.nextWaveElement.classList.add('boss-warning');
                  this.nextWaveElement.style.display = 'block';

                  if (this.bossNameLabelElement) {
                      const incomingLabel = typeof bossLabelText === 'string' ? bossLabelText.trim() : '';
                      const effectiveLabel = incomingLabel || this.currentBossLabel;
                      if (effectiveLabel) {
                          const needsRefresh = this.currentBossLabel !== effectiveLabel || this.bossNameLabelElement.style.display !== 'block';
                          if (needsRefresh) {
                              this.currentBossLabel = effectiveLabel;
                              this.bossNameLabelElement.textContent = effectiveLabel;
                              this.bossNameLabelElement.style.display = 'block';
                              this.bossNameLabelElement.classList.remove('boss-name-show');
                              void this.bossNameLabelElement.offsetWidth;
                              this.bossNameLabelElement.classList.add('boss-name-show');
                              this.playBossSpawnCue(bossKey);
                          }
                      } else {
                          this.clearBossNameLabel();
                      }
                  }

                  if (!this.bossWarningShown && typeof window !== 'undefined' && window.game && window.game.audio) {
                      // Start looped alert sound while warning is visible
                      window.game.audio.startLoopingSound('BossAlertSound');
                      this.bossWarningShown = true;
                  }
              }

              hideBossWarning() {
                  if (!this.nextWaveElement) return;
                  this.nextWaveElement.classList.remove('boss-warning');
                  this.nextWaveElement.style.display = 'none';
                  this.clearBossNameLabel();
                  if (typeof window !== 'undefined' && window.game && window.game.audio) {
                      window.game.audio.stopLoopingSound('BossAlertSound');
                  }
                  this.bossWarningShown = false;
              }
            
            showScoreAddition(points) {
                if (this.scoreAdditionElement) {
                    // Clear any existing timeout
                    if (this.scoreAdditionTimeout) {
                        clearTimeout(this.scoreAdditionTimeout);
                    }
                    
                    // Show the addition
                    this.scoreAdditionElement.textContent = ` +${points}`;
                    
                    // Hide after 2 seconds
                    this.scoreAdditionTimeout = setTimeout(() => {
                        this.scoreAdditionElement.textContent = '';
                    }, 2000);
                }
            }

            updateXPBar(currentXp, requiredXp, level) {
                if (!this.xpFill || !this.xpLevel) return;
                const pct = Math.max(0, Math.min(1, requiredXp > 0 ? currentXp / requiredXp : 0));
                this.xpFill.style.width = `${pct * 100}%`;
                this.xpLevel.textContent = `Level ${level}`;
                // Apply overlay fading using cached elements and width
                if (!this.xpOverlayEl && this.xpBarEl) {
                    this.xpOverlayEl = document.createElement('div');
                    this.xpOverlayEl.className = 'xp-gain-overlay';
                    this.xpBarEl.appendChild(this.xpOverlayEl);
                    this._cachedXpBarClientWidth = this.xpBarEl.clientWidth;
                }
                const overlay = this.xpOverlayEl;
                if (overlay) {
                    if (this.xpGainFade > 0) {
                        this.xpGainFade = Math.max(0, this.xpGainFade - getTimeScale());
                        const alpha = Math.max(0, this.xpGainFade / 45);
                        const overlayPct = Math.max(0, Math.min(1, this.xpGainOverlayWidth));
                        // Use cached width to avoid reflow; refresh occasionally when overlay starts
                        if (this._cachedXpBarClientWidth === 0 || (this.xpGainFade === 45 && this.xpBarEl)) {
                            this._cachedXpBarClientWidth = this.xpBarEl.clientWidth;
                        }
                        const basePx = pct * this._cachedXpBarClientWidth;
                        const overlayPx = overlayPct * this._cachedXpBarClientWidth;
                        overlay.style.left = `${basePx}px`;
                        overlay.style.width = `${overlayPx}px`;
                        overlay.style.opacity = `${0.85 * alpha}`;
                        if (this.xpGainFade === 0) {
                            overlay.style.opacity = '0';
                            overlay.style.width = '0px';
                        }
                    } else {
                        overlay.style.opacity = '0';
                        overlay.style.width = '0px';
                    }
                }
            }

            showXPGainOverlay(amount, requiredXp) {
                if (!requiredXp || requiredXp <= 0) return;
                // width proportional to required XP
                this.xpGainOverlayWidth = Math.max(0, Math.min(1, amount / requiredXp));
                this.xpGainFade = 45; // ~0.75s
            }

            resetXPBar() {
                if (!this.xpFill || !this.xpLevel) return;
                this.xpFill.style.width = '0%';
                this.xpLevel.textContent = 'Level 1';
            }
        }

        // Main game class
        class Game {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.input = new InputManager();
                this.audio = new AudioManager();
                this.uiManager = new UIManager();
                this.tutorialOverlay = null;
                this.isTutorialOpen = false;
                this.openTutorial = () => {};
                this.closeTutorial = () => {};
                this.shootDelay = 250;
                this.lastShot = 0;
                this.rocketCooldownMs = 1500;
                this.lastRocketShot = 0;
                this.mineCooldownMs = 2000;
                this.lastMinePlaced = 0;
                this.inLobby = true;
                this.setupCanvas();
                // Expose && initialize scaling
                if (typeof window !== 'undefined') { window.game = this; }
                this.speedScale = 1; // fixed internal resolution; keep motion scale 1
                // Theme state
                this.playerTheme = 'default';
                try {
                    const savedTheme = localStorage.getItem('geometry_rush_theme');
                    if (savedTheme === 'cyan' || savedTheme === 'rainbow' || savedTheme === 'default') {
                        this.playerTheme = savedTheme;
                    }
                } catch (e) { /* ignore storage errors */ }
                this.controlsInfoAutoHideDelay = 20000;
                this.controlsInfoAutoHideTriggered = false;
                this.reset();
                this.setupEventListeners();
                this.setupAudio();
                this.backgroundBinary = new BackgroundBinaryManager(this.canvas);
                this.fallingNumbers = new FallingNumbersManager(this.canvas);
                this.gameOverRain = new FallingNumbersManager(this.canvas, {
                    color: '#ff3333',
                    digits: ['0', '1'],
                    digitChangeMode: 'random'
                });
                this.gameOverVoiceTimeoutId = null;
                this.gameOverVoiceCooldownMs = 1200;
                this.gameOverVoiceKeys = ['n1-keep-trying', 'n3-try-harder', 'n4-you-can-do-better'];
                this.tetrisManager = new TetrisManager(this);
                // Lobby radial lines config (precompute base directions)
                this.lobbyRadial = { lineCount: 36, innerR: 80, baseDirs: [] };
                for (let i = 0; i < this.lobbyRadial.lineCount; i++) {
                    const a = (Math.PI * 2 * i) / this.lobbyRadial.lineCount;
                    this.lobbyRadial.baseDirs.push({ x: Math.cos(a), y: Math.sin(a) });
                }
                this.lobbyRadialCenterX = this.canvas.width / 2;
                this.lobbyRadialCenterY = this.canvas.height / 3;
                this.lobbyRadialOuterR = Math.sqrt(this.canvas.width * this.canvas.width + this.canvas.height * this.canvas.height) / 2 + 20;
                // FPS tracking state
                this._lastFpsTime = 0;
                this._fps = 60;
                this._fpsSamples = [];
                this._fpsSum = 0;
                this._fpsWindow = 60; // average over last N frames
                // Helper to update radial center from logo position
                this.updateLobbyRadialCenterFromLogo = () => {
                    const logo = document.getElementById('lobbyLogo');
                    const rect = logo && logo.getBoundingClientRect ? logo.getBoundingClientRect() : null;
                    const canvasRect = this.canvas.getBoundingClientRect();
                    if (rect) {
                        const centerX = rect.left + rect.width / 2 - canvasRect.left;
                        const centerY = rect.top + rect.height / 2 - canvasRect.top;
                        this.lobbyRadialCenterX = centerX * (this.canvas.width / canvasRect.width);
                        this.lobbyRadialCenterY = centerY * (this.canvas.height / canvasRect.height);
                    }
                };
                // Offscreen grid pattern cache
                this.gridPatternCanvas = null;
                this.gridPattern = null;
                
                // Persistent best stats
                this.bestScore = 0;
                this.maxWave = 0;
                this.isNewBestScore = false;
                this.isNewMaxWave = false;
                this.loadBestStats();
                this.setupLobby();
                
                // Upgrades state
                this.upgradeManager = null; // Initialized on first game start
                this.upgradePause = false;
                this.upgradeOverlayHiddenByPause = false;
                
                // Grid movement for infinite background effect
                this.gridOffsetX = 0;
                this.gridOffsetY = 0;
                this.gridSpeed = 0.5; // Speed of grid movement

                // Background grid blink state
                this.gridBlink = {
                    startTime: 0,
                    activeUntil: 0,
                    durationMs: 520,
                    intensity: 0
                };
                
                // Track player position for parallax effect
                this.lastPlayerX = 0;
                this.lastPlayerY = 0;
                
                // Initially hide UI since we start in lobby
                this.uiManager.hideUI();

                // Boss state initialization
                this.inBossPhase = false;
                this.bossWarningEndTime = 0;
                this.activeBoss = null;
                  this.pendingBossKey = null;
                  this.pendingBossDisplayName = '';
                this.usedBossTypes = new Set();
                this.defeatedBossCount = 0;
                this.totalBossTimeExcluded = 0;
                this.bossTimerPauseStart = 0;

                // Helpers for UI-to-canvas mapping
                // Cache boss-safe Y derived from XP bar on resize
                this._cachedBossSafeMinCenterY = 120;
                this.screenToCanvasY = (screenY) => {
                    const rect = this.canvas.getBoundingClientRect();
                    return (screenY - rect.top) * (this.canvas.height / rect.height);
                };
                this.getBossSafeMinCenterY = () => {
                    return this._cachedBossSafeMinCenterY;
                };
            }

            // Boss management
            getAvailableBossTypes() {
                const bosses = Object.keys(ENEMY_TYPES).filter(key => {
                    const config = ENEMY_TYPES[key];
                    return config && (config.isBoss || config.role === 'boss');
                });
                const enabled = bosses.filter(key => {
                    const config = ENEMY_TYPES[key];
                    return config && config.bossRotationEnabled !== false;
                });
                if (enabled.length > 0) return enabled;
                return bosses.length > 0 ? bosses : ['rhombus_boss'];
            }

                determineNextBossKey() {
                    const firstBossKey = getFirstBossOverride();
                    if (this.defeatedBossCount === 0 && firstBossKey) {
                        return firstBossKey;
                    }
                    const bossTypes = this.getAvailableBossTypes();
                    if (!Array.isArray(bossTypes) || bossTypes.length === 0) {
                        return firstBossKey || 'vector_snake_boss';
                    }
                    if (!this.usedBossTypes) this.usedBossTypes = new Set();
                    let unused = bossTypes.filter(b => !this.usedBossTypes.has(b));
                    if (unused.length === 0) {
                        this.usedBossTypes.clear();
                        unused = bossTypes.slice();
                    }
                    const pool = unused.length > 0 ? unused : bossTypes;
                    const randomBoss = pool[Math.floor(Math.random() * pool.length)];
                    return randomBoss || bossTypes[0] || firstBossKey || 'vector_snake_boss';
                }

              triggerBossPhase() {
                  if (this.inBossPhase) return;
                  this.inBossPhase = true;
                  this.activeBoss = null;
                  this.waveStarted = false;
                  this.pendingBossKey = this.determineNextBossKey();
                  this.pendingBossDisplayName = getBossDisplayName(this.pendingBossKey);
                  if (this.uiManager && this.uiManager.showBossWarning) this.uiManager.showBossWarning(this.pendingBossDisplayName, this.pendingBossKey);
                    const now = Date.now();
                    this.bossWarningEndTime = now + Math.round(5000 / Math.max(0.001, getTimeScale()));
                    this.bossTimerPauseStart = now;
              }

                spawnBoss() {
                    const firstBossKey = getFirstBossOverride();
                    let chosen = this.pendingBossKey;
                    if (!chosen) {
                        chosen = this.determineNextBossKey();
                    }
                    if (!chosen) {
                        const bossTypes = this.getAvailableBossTypes();
                        if (Array.isArray(bossTypes) && bossTypes.length > 0) {
                            chosen = bossTypes[Math.floor(Math.random() * bossTypes.length)];
                        }
                    }
                    if (!chosen) {
                        chosen = firstBossKey || 'vector_snake_boss';
                    }
                    if (!this.usedBossTypes) this.usedBossTypes = new Set();
                    this.usedBossTypes.add(chosen);

                  const clearPendingBoss = () => {
                      this.pendingBossKey = null;
                      this.pendingBossDisplayName = '';
                  };

                if (chosen === 'vector_snake_boss') {
                    this.activeBoss = new VectorSnakeBoss(this);
                      clearPendingBoss();
                    if (this.uiManager && this.uiManager.hideBossWarning) this.uiManager.hideBossWarning();
                    return;
                }

                  if (chosen === 'player_2_boss') {
                      this.activeBoss = new PlayerTwoBoss(this);
                        clearPendingBoss();
                      if (this.uiManager && this.uiManager.hideBossWarning) this.uiManager.hideBossWarning();
                      return;
                  }

                if (chosen === 'tetris_cross_boss') {
                    // Custom boss instantiation
                    this.activeBoss = new TetrisCrossBoss(this);
                    // Ensure tetromino manager reset at boss start
                    if (this.tetrisManager) this.tetrisManager.reset();
                      clearPendingBoss();
                    if (this.uiManager && this.uiManager.hideBossWarning) this.uiManager.hideBossWarning();
                    return;
                }

                if (chosen === 'ping_and_pong_boss') {
                    this.activeBoss = new PingAndPongBoss(this);
                    clearPendingBoss();
                    if (this.uiManager && this.uiManager.hideBossWarning) this.uiManager.hideBossWarning();
                    return;
                }

                // default spawn for classic enemy bosses
                const side = Math.floor(Math.random() * 4);
                const margin = 60;
                let x, y;
                switch (side) {
                    case 0: x = Math.random() * this.canvas.width; y = -margin; break;
                    case 1: x = this.canvas.width + margin; y = Math.random() * this.canvas.height; break;
                    case 2: x = Math.random() * this.canvas.width; y = this.canvas.height + margin; break;
                    default: x = -margin; y = Math.random() * this.canvas.height; break;
                }
                const config = ENEMY_TYPES[chosen] || ENEMY_TYPES['rhombus_boss'];
                const boss = new Enemy(x, y, chosen, config);
                boss.spawnShieldUntil = Date.now() + 1500;
                this.enemies.push(boss);
                this.activeBoss = boss;
                  clearPendingBoss();
                if (this.uiManager && this.uiManager.hideBossWarning) this.uiManager.hideBossWarning();
            }

            onBossDefeated() {
                this.defeatedBossCount = (this.defeatedBossCount || 0) + 1;
                if (this.bossTimerPauseStart) {
                    const bossEndTime = Date.now();
                    const duration = Math.max(0, bossEndTime - this.bossTimerPauseStart);
                    this.totalBossTimeExcluded = (this.totalBossTimeExcluded || 0) + duration;
                    this.bossTimerPauseStart = 0;
                }
                this.inBossPhase = false;
                this.activeBoss = null;
                if (this.shakeCanvas) this.shakeCanvas(8, 350);
                // Start pause before next group like regular wave pause
                this.inWavePause = true;
                this.wavePauseEndTime = Date.now() + Math.round(3000 / Math.max(0.001, getTimeScale()));
                // Advance to next wave group
                this.currentGroupIndex++;
                if (this.currentGroupIndex < this.waveGroupsPrepared.length) {
                    this.currentGroupQueue = this.waveGroupsPrepared[this.currentGroupIndex].slice();
                }
            }

            setupCanvas() {
                // Fixed internal resolution; uniform CSS scale to preserve aspect ratio (letterbox)
                const baseW = SPEED_SETTINGS.baseWidth;
                const baseH = SPEED_SETTINGS.baseHeight;
                this.canvas.width = baseW;
                this.canvas.height = baseH;
                const scale = Math.min(window.innerWidth / baseW, window.innerHeight / baseH);
                const cssW = Math.floor(baseW * scale);
                const cssH = Math.floor(baseH * scale);
                const offsetX = Math.floor((window.innerWidth - cssW) / 2);
                const offsetY = Math.floor((window.innerHeight - cssH) / 2);
                this.canvas.style.width = cssW + 'px';
                this.canvas.style.height = cssH + 'px';
                this.canvas.style.position = 'absolute';
                this.canvas.style.left = offsetX + 'px';
                this.canvas.style.top = offsetY + 'px';
                // Initialize cached rect/scales for mouse mapping immediately
                const rect = this.canvas.getBoundingClientRect();
                this._cachedRectLeft = rect.left;
                this._cachedRectTop = rect.top;
                this._cachedScaleX = this.canvas.width / (rect.width || 1);
                this._cachedScaleY = this.canvas.height / (rect.height || 1);
                this._cachedRectTime = Date.now();
            }

            refreshCanvasRectCache() {
                const rect = this.canvas.getBoundingClientRect();
                this._cachedRectLeft = rect.left;
                this._cachedRectTop = rect.top;
                this._cachedScaleX = this.canvas.width / (rect.width || 1);
                this._cachedScaleY = this.canvas.height / (rect.height || 1);
                this._cachedRectTime = Date.now();
            }

            // Subtle camera shake using CSS transform on the canvas element
            shakeCanvas(intensity = 5, duration = 300) {
                if (!this.canvas) return;
                const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
                this._shakeEnd = Math.max(this._shakeEnd || 0, now + duration);
                this._shakeIntensity = Math.max(this._shakeIntensity || 0, intensity);
                if (this._shakeRaf) return;
                const animate = () => {
                    const t = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
                    if (!this._shakeEnd || t >= this._shakeEnd) {
                        this.canvas.style.transform = '';
                        this._shakeRaf = null;
                        this._shakeEnd = 0;
                        this._shakeIntensity = 0;
                        return;
                    }
                    const dx = (Math.random() - 0.5) * this._shakeIntensity;
                    const dy = (Math.random() - 0.5) * this._shakeIntensity;
                    this.canvas.style.transform = `translate(${dx}px, ${dy}px)`;
                    this._shakeRaf = requestAnimationFrame(animate);
                };
                this._shakeRaf = requestAnimationFrame(animate);
            }

            async setupAudio() {
                console.log('Initializing audio system...');
                await this.audio.initialize();
                console.log('âœ“ Audio preloading complete');
            }

            _clearGameOverVoiceTimeout() {
                if (this.gameOverVoiceTimeoutId) {
                    clearTimeout(this.gameOverVoiceTimeoutId);
                    this.gameOverVoiceTimeoutId = null;
                }
            }

            scheduleGameOverVoiceLine() {
                if (!this.gameOver || !Array.isArray(this.gameOverVoiceKeys) || this.gameOverVoiceKeys.length === 0) {
                    return;
                }
                this._clearGameOverVoiceTimeout();
                const delay = Number.isFinite(this.gameOverVoiceCooldownMs) ? this.gameOverVoiceCooldownMs : 2000;
                this.gameOverVoiceTimeoutId = setTimeout(() => {
                    this.gameOverVoiceTimeoutId = null;
                    if (!this.gameOver) return;
                    if (!this.audio || typeof this.audio.playSound !== 'function') return;
                    const keys = Array.isArray(this.gameOverVoiceKeys) ? this.gameOverVoiceKeys : [];
                    if (keys.length === 0) return;
                    const available = keys.filter(key => this.audio.audios && this.audio.audios[key]);
                    const pool = available.length > 0 ? available : keys;
                    const choice = pool[Math.floor(Math.random() * pool.length)];
                    if (choice) {
                        this.audio.playSound(choice);
                    }
                }, Math.max(0, delay));
            }
            
            setupLobby() {
                const startButton = document.getElementById('startButton');
                const musicToggle = document.getElementById('musicToggle');
                const musicIcon = document.getElementById('musicIcon');
                const sfxToggle = document.getElementById('sfxToggle');
                const sfxIcon = document.getElementById('sfxIcon');
                const quitButton = document.getElementById('quitButton');
                // DEV: Wipe button in lobby
                const wipeButton = document.getElementById('wipeButton');
                const lobby = document.getElementById('lobby');
                const buttonRain = document.getElementById('buttonRain');
                const lobbyTitle = document.getElementById('lobbyTitle');
                const lobbyLogo = document.getElementById('lobbyLogo');
                const bestStatsEl = document.getElementById('bestStats');
                const themeSelector = document.getElementById('themeSelector');
                const themeOptions = themeSelector ? Array.from(themeSelector.querySelectorAll('.theme-option')) : [];
                const themeCyanNameEl = document.getElementById('themeCyanName');
                const themeRainbowNameEl = document.getElementById('themeRainbowName');
                const tutorialButton = document.getElementById('tutorialButton');
                const tutorialOverlay = document.getElementById('tutorialOverlay');
                const tutorialCloseButton = document.getElementById('tutorialCloseButton');
                const lobbyCharacterImage = document.getElementById('lobbyCharacter');
                const LOBBY_THEME_IMAGES = {
                    default: { src: 'Character_1_lobby.png', alt: 'White theme lobby character' },
                    cyan: { src: 'Character_2_lobby.png', alt: 'Cyan theme lobby character' },
                    rainbow: { src: 'Character_3_lobby.png', alt: 'Rainbow theme lobby character' }
                };
                const resolveThemeKey = (theme) => {
                    return (theme === 'cyan' || theme === 'rainbow') ? theme : 'default';
                };
                const updateLobbyCharacterImage = (theme) => {
                    if (!lobbyCharacterImage) return;
                    const key = resolveThemeKey(theme);
                    const asset = LOBBY_THEME_IMAGES[key] || LOBBY_THEME_IMAGES.default;
                    if (!asset) return;
                    if (lobbyCharacterImage.getAttribute('src') !== asset.src) {
                        lobbyCharacterImage.src = asset.src;
                    }
                    lobbyCharacterImage.alt = asset.alt;
                    lobbyCharacterImage.dataset.theme = key;
                };
                this.updateLobbyCharacterImage = updateLobbyCharacterImage;
                
                if (lobbyLogo) {
                    const handleLogoReady = () => {
                        lobbyLogo.style.display = 'block';
                        if (this.updateLobbyRadialCenterFromLogo) {
                            this.updateLobbyRadialCenterFromLogo();
                        }
                    };
                    
                    if (lobbyLogo.complete && lobbyLogo.naturalWidth > 0) {
                        handleLogoReady();
                    } else {
                        lobbyLogo.addEventListener('load', handleLogoReady, { once: true });
                    }
                    
                    lobbyLogo.addEventListener('error', () => {
                        console.error('Failed to load lobby logo asset:', lobbyLogo.src);
                    });
                }
                
                let rainInterval;
                
                startButton.addEventListener('click', () => {
                    this.audio.playSound('buttonClick');
                    this.startGame();
                });
                
                startButton.addEventListener('mouseenter', () => {
                    this.startButtonRain(buttonRain);
                    rainInterval = setInterval(() => {
                        this.startButtonRain(buttonRain);
                    }, 100);
                });
                
                startButton.addEventListener('mouseleave', () => {
                    clearInterval(rainInterval);
                    setTimeout(() => {
                        buttonRain.innerHTML = '';
                    }, 1000);
                });
                
                quitButton.addEventListener('click', () => {
                    this.returnToLobby();
                });
                
                // DEV: Wipe button handler - clears local data and reloads
                if (wipeButton) {
                    const doWipe = () => {
                        try {
                            localStorage.removeItem('geometry_rush_best');
                        } catch (e) {}
                        try {
                            localStorage.removeItem('geometry_rush_theme');
                        } catch (e) {}
                        try {
                            localStorage.removeItem('geometry_rush_settings');
                        } catch (e) {}
                        try {
                            localStorage.removeItem('geometry_rush_audio_settings');
                        } catch (e) {}
                        // Full clear as fallback
                        try {
                            localStorage.clear();
                        } catch (e) {}
                        // Refresh page to ensure clean state
                        try {
                            location.reload();
                        } catch (e) {}
                    };
                    wipeButton.addEventListener('click', (ev) => {
                        ev.stopPropagation();
                        this.audio.playSound('buttonClick');
                        doWipe();
                    });
                }
                
                const updateMusicIcon = (enabled) => {
                    if (musicIcon) {
                        musicIcon.src = enabled ? 'sound-on.png' : 'sound-off.png';
                        musicIcon.alt = enabled ? 'Music On' : 'Music Off';
                    }
                    if (musicToggle) {
                        musicToggle.setAttribute('aria-pressed', enabled ? 'true' : 'false');
                        musicToggle.title = enabled ? 'Disable Music' : 'Enable Music';
                    }
                };

                updateMusicIcon(this.audio.musicEnabled);

                if (musicToggle) {
                    musicToggle.addEventListener('click', () => {
                        const musicEnabled = this.audio.toggleMusic();
                        updateMusicIcon(musicEnabled);
                        if (musicEnabled) {
                            // Ensure the correct track plays based on current state
                            if (this.inLobby) {
                                this.audio.stopGameMusic();
                                this.audio.playLobbyMusic();
                            } else if (this.gameOver) {
                                // No music in game over
                                this.audio.stopGameMusic();
                                this.audio.stopLobbyMusic();
                            } else if (!this.paused) {
                                // In active gameplay
                                this.audio.stopLobbyMusic();
                                this.audio.playGameMusic();
                            }
                        } else {
                            // toggleMusic already pauses all music
                        }
                    });
                }

                const updateSfxIcon = (enabled) => {
                    if (sfxIcon) {
                        sfxIcon.src = enabled ? 'sound-fx-on.png' : 'sound-fx-off.png';
                        sfxIcon.alt = enabled ? 'Sound Effects On' : 'Sound Effects Off';
                    }
                    if (sfxToggle) {
                        sfxToggle.setAttribute('aria-pressed', enabled ? 'true' : 'false');
                        sfxToggle.title = enabled ? 'Disable Sound Effects' : 'Enable Sound Effects';
                    }
                };

                updateSfxIcon(this.audio.soundEffectsEnabled);

                if (sfxToggle) {
                    sfxToggle.addEventListener('click', () => {
                        const soundEffectsEnabled = this.audio.toggleSoundEffects();
                        updateSfxIcon(soundEffectsEnabled);
                    });
                }
                // Theme unlock state based on best score
                const THEME_UNLOCKS = {
                    default: 0,
                    cyan: 2500,
                    rainbow: 5000
                };
                const isThemeUnlocked = (themeKey) => {
                    const required = THEME_UNLOCKS[themeKey] || 0;
                    return (this.bestScore || 0) >= required;
                };
                const updateThemeLocksUI = () => {
                    themeOptions.forEach(opt => {
                        const t = opt.getAttribute('data-theme');
                        const unlocked = isThemeUnlocked(t);
                        if (!unlocked) opt.classList.add('locked'); else opt.classList.remove('locked');
                    });
                    if (themeCyanNameEl) themeCyanNameEl.textContent = isThemeUnlocked('cyan') ? 'Glow' : '2500 Pts.';
                    if (themeRainbowNameEl) themeRainbowNameEl.textContent = isThemeUnlocked('rainbow') ? 'Rainbow' : '5000 Pts.';
                };
                // Ensure currently selected theme is valid; fallback if locked
                if (!isThemeUnlocked(this.playerTheme)) {
                    this.playerTheme = 'default';
                    try { localStorage.setItem('geometry_rush_theme', this.playerTheme); } catch (e) {}
                }
                updateLobbyCharacterImage(this.playerTheme);
                // Theme option handlers
                const applyThemeSelectionUI = () => {
                    themeOptions.forEach(opt => {
                        const t = opt.getAttribute('data-theme');
                        if (t === this.playerTheme) opt.classList.add('selected');
                        else opt.classList.remove('selected');
                    });
                };
                const setTheme = (theme) => {
                    if (!theme || (theme !== 'default' && theme !== 'cyan' && theme !== 'rainbow')) return;
                    if (!isThemeUnlocked(theme)) return; // block selecting locked themes
                    this.playerTheme = theme;
                    try { localStorage.setItem('geometry_rush_theme', theme); } catch (e) {}
                    updateLobbyCharacterImage(theme);
                    applyThemeSelectionUI();
                    if (this.player) this.player.theme = theme;
                };
                themeOptions.forEach(opt => {
                    opt.addEventListener('click', () => {
                        const theme = opt.getAttribute('data-theme');
                        if (isThemeUnlocked(theme)) {
                            this.audio.playSound('buttonClick');
                            setTheme(theme);
                        } else {
                            // Optional: provide a subtle feedback without selecting
                            opt.classList.add('shake');
                            setTimeout(() => opt.classList.remove('shake'), 300);
                        }
                    });
                });
                // Initialize theme UI from saved theme
                updateThemeLocksUI();
                applyThemeSelectionUI();
                updateLobbyCharacterImage(this.playerTheme);
                
                const openTutorial = () => {
                    if (!tutorialOverlay) return;
                    if (tutorialOverlay.classList.contains('visible')) return;
                    tutorialOverlay.classList.add('visible');
                    tutorialOverlay.setAttribute('aria-hidden', 'false');
                    this.isTutorialOpen = true;
                    this.tutorialOverlay = tutorialOverlay;
                    if (tutorialCloseButton) {
                        tutorialCloseButton.focus({ preventScroll: true });
                    }
                };
                
                const closeTutorial = ({ restoreFocus = true } = {}) => {
                    if (!tutorialOverlay) return;
                    if (!tutorialOverlay.classList.contains('visible')) {
                        this.isTutorialOpen = false;
                        return;
                    }
                    tutorialOverlay.classList.remove('visible');
                    tutorialOverlay.setAttribute('aria-hidden', 'true');
                    this.isTutorialOpen = false;
                    if (restoreFocus && tutorialButton && this.inLobby) {
                        tutorialButton.focus({ preventScroll: true });
                    }
                };
                
                this.openTutorial = openTutorial;
                this.closeTutorial = closeTutorial;
                this.tutorialOverlay = tutorialOverlay;
                
                if (tutorialButton) {
                    tutorialButton.addEventListener('click', () => {
                        if (!this.inLobby) return;
                        this.audio.playSound('buttonClick');
                        openTutorial();
                    });
                }
                
                if (tutorialCloseButton) {
                    tutorialCloseButton.addEventListener('click', () => {
                        this.audio.playSound('buttonClick');
                        closeTutorial();
                    });
                }
                
                if (tutorialOverlay) {
                    tutorialOverlay.addEventListener('click', (event) => {
                        if (event.target === tutorialOverlay) {
                            closeTutorial();
                        }
                    });
                }
                 
                // Auto-start audio on any interaction (only while in lobby)
                const initAudio = async () => {
                    if (this.audio.musicEnabled && this.inLobby) {
                        await this.audio.playLobbyMusic();
                    }
                    document.removeEventListener('click', initAudio);
                    document.removeEventListener('keydown', initAudio);
                    document.removeEventListener('touchstart', initAudio);
                };
                document.addEventListener('click', initAudio);
                document.addEventListener('keydown', initAudio);
                document.addEventListener('touchstart', initAudio);
                
                // Initialize best stats label
                this.updateBestStatsLabel();
            }
            
            startButtonRain(container) {
                const buttonWidth = 120; // Approximate button width
                for (let i = 0; i < 3; i++) {
                    const digit = document.createElement('div');
                    digit.className = 'rain-digit';
                    digit.textContent = Math.random() < 0.5 ? '0' : '1';
                    digit.style.left = Math.random() * buttonWidth + 'px';
                    digit.style.animationDelay = Math.random() * 0.5 + 's';
                    container.appendChild(digit);
                    
                    // Remove digit after animation
                    setTimeout(() => {
                        if (digit.parentNode) {
                            digit.parentNode.removeChild(digit);
                        }
                    }, 1500);
                }
            }
            
            updateGridMovement() {
                // Move grid continuously for infinite scroll effect
                this.gridOffsetX += this.gridSpeed * 0.7; // Slower horizontal movement
                this.gridOffsetY += this.gridSpeed; // Normal vertical movement
                
                const gridSize = 40;
                // Keep offsets within grid bounds to prevent overflow
                this.gridOffsetX = this.gridOffsetX % gridSize;
                this.gridOffsetY = this.gridOffsetY % gridSize;
            }
            
            updateBackgroundParallax() {
                // Calculate player movement delta
                const playerDeltaX = this.player.x - this.lastPlayerX;
                const playerDeltaY = this.player.y - this.lastPlayerY;
                
                // Only update background binary numbers with parallax (not the grid)
                this.backgroundBinary.updateParallax(playerDeltaX, playerDeltaY);
                
                // Store current player position for next frame
                this.lastPlayerX = this.player.x;
                this.lastPlayerY = this.player.y;
            }

              triggerGridBlink(intensity = 1, durationMs = null) {
                  if (!this.gridBlink) {
                      this.gridBlink = {
                          startTime: 0,
                          activeUntil: 0,
                          durationMs: 520,
                          intensity: 0
                      };
                  }
                  const now = Date.now();
                  const duration = Math.max(120, Number.isFinite(durationMs) && durationMs > 0 ? durationMs : (this.gridBlink.durationMs || 520));
                  const safeIntensity = Math.max(0, intensity);
                  this.gridBlink.startTime = now;
                  this.gridBlink.activeUntil = now + duration;
                  this.gridBlink.durationMs = duration;
                  const previousIntensity = this.gridBlink.intensity || 0;
                  this.gridBlink.intensity = Math.min(1.75, Math.max(previousIntensity, safeIntensity));
              }
            
            drawInfiniteGrid() {
                const gridSize = 40;
                const timeMs = Date.now();
                const periodMs = this.inBossPhase ? 1800 : 4200;
                const phase = (timeMs % periodMs) / periodMs;
                const pulse = 0.5 + 0.5 * Math.sin(phase * Math.PI * 2);

                // Build or rebuild pattern if missing or canvas resized
                const needBuild = !this.gridPatternCanvas || this.gridPatternCanvas.width !== gridSize * 2 || this.gridPatternCanvas.height !== gridSize * 2;
                if (needBuild) {
                    this.gridPatternCanvas = document.createElement('canvas');
                    this.gridPatternCanvas.width = gridSize * 2;
                    this.gridPatternCanvas.height = gridSize * 2;
                    const gctx = this.gridPatternCanvas.getContext('2d');
                    // Slightly stronger base visibility for grid
                    gctx.strokeStyle = 'rgba(255, 135, 135, 0.35)';
                    gctx.lineWidth = 1;
                    // One vertical and one horizontal line per grid
                    for (let x = 0; x <= this.gridPatternCanvas.width; x += gridSize) {
                        gctx.beginPath();
                        gctx.moveTo(x, 0);
                        gctx.lineTo(x, this.gridPatternCanvas.height);
                        gctx.stroke();
                    }
                    for (let y = 0; y <= this.gridPatternCanvas.height; y += gridSize) {
                        gctx.beginPath();
                        gctx.moveTo(0, y);
                        gctx.lineTo(this.gridPatternCanvas.width, y);
                        gctx.stroke();
                    }
                    this.gridPattern = this.ctx.createPattern(this.gridPatternCanvas, 'repeat');
                }
                this.ctx.save();
                // Base alpha slightly toned down; still ramps during boss presence
                const basePulseAlpha = 0.14 + 0.08 * pulse;
                this.ctx.globalAlpha = this.inBossPhase && this.activeBoss
                    ? Math.min(0.3, basePulseAlpha + 0.06)
                    : Math.min(0.22, basePulseAlpha);
                this.ctx.fillStyle = this.gridPattern;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.restore();

                // Gentle red pulsation overlay on top of the base grid
                const pulsationLineAlpha = 0.035 + 0.07 * pulse;
                if (pulsationLineAlpha > 0.01) {
                    this.ctx.save();
                    this.ctx.strokeStyle = `rgba(255, 70, 70, ${pulsationLineAlpha.toFixed(3)})`;
                    this.ctx.lineWidth = 0.6 + 0.35 * pulse;
                    this.ctx.globalCompositeOperation = 'lighter';
                    for (let x = -gridSize; x <= this.canvas.width + gridSize; x += gridSize) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(x, 0);
                        this.ctx.lineTo(x, this.canvas.height);
                        this.ctx.stroke();
                    }
                    for (let y = -gridSize; y <= this.canvas.height + gridSize; y += gridSize) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, y);
                        this.ctx.lineTo(this.canvas.width, y);
                        this.ctx.stroke();
                    }
                    this.ctx.restore();
                }

                  const blinkState = this.gridBlink;
                  const blinkActive = blinkState && blinkState.activeUntil && timeMs < blinkState.activeUntil;
                  if (blinkActive) {
                      const duration = Math.max(1, blinkState.durationMs || 520);
                      const startTime = blinkState.startTime || (blinkState.activeUntil - duration);
                      const elapsed = Math.max(0, timeMs - startTime);
                      const progress = Math.min(1, elapsed / duration);
                      const fade = 1 - progress;
                      const oscillation = 0.5 + 0.5 * Math.sin(progress * Math.PI * 4);
                      const baseIntensity = Math.min(1.75, Math.max(0, blinkState.intensity || 0));
                      const intensity = baseIntensity * oscillation * fade;
                      const overlayAlpha = Math.min(0.4, 0.12 + 0.28 * intensity);
                      if (overlayAlpha > 0.005) {
                          this.ctx.save();
                          this.ctx.fillStyle = `rgba(120, 0, 0, ${overlayAlpha.toFixed(3)})`;
                          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                          this.ctx.restore();
                      }
                      const lineAlpha = Math.min(0.85, 0.35 + 0.45 * intensity);
                      const lineWidth = 1 + 1.5 * intensity;
                      if (lineAlpha > 0.01) {
                          this.ctx.save();
                          this.ctx.lineWidth = lineWidth;
                          this.ctx.strokeStyle = `rgba(255, 60, 60, ${lineAlpha.toFixed(3)})`;
                          this.ctx.globalCompositeOperation = 'lighter';
                          for (let x = -gridSize; x <= this.canvas.width + gridSize; x += gridSize) {
                              this.ctx.beginPath();
                              this.ctx.moveTo(x, 0);
                              this.ctx.lineTo(x, this.canvas.height);
                              this.ctx.stroke();
                          }
                          for (let y = -gridSize; y <= this.canvas.height + gridSize; y += gridSize) {
                              this.ctx.beginPath();
                              this.ctx.moveTo(0, y);
                              this.ctx.lineTo(this.canvas.width, y);
                              this.ctx.stroke();
                          }
                          this.ctx.restore();
                      }
                  }

                // During boss alert (warning before spawn), overlay red blinking grid lines for visibility
                const alertPhase = this.inBossPhase && !this.activeBoss;
                if (alertPhase) {
                    const alpha = 0.25 + 0.25 * (0.5 + 0.5 * Math.sin(phase * Math.PI * 2));
                    this.ctx.save();
                    this.ctx.strokeStyle = `rgba(255, 60, 60, ${alpha.toFixed(3)})`;
                    this.ctx.lineWidth = 1;
                    // Vertical lines
                    for (let x = 0; x <= this.canvas.width; x += gridSize) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(x, 0);
                        this.ctx.lineTo(x, this.canvas.height);
                        this.ctx.stroke();
                    }
                    // Horizontal lines
                    for (let y = 0; y <= this.canvas.height; y += gridSize) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, y);
                        this.ctx.lineTo(this.canvas.width, y);
                        this.ctx.stroke();
                    }
                    this.ctx.restore();
                }
            }
            
            startGame() {
                if (typeof this.closeTutorial === 'function') {
                    this.closeTutorial({ restoreFocus: false });
                }
                this.inLobby = false;
                document.getElementById('lobby').classList.add('hidden');
                this.uiManager.showUI();
                this.toggleRedBorder(true);
                
                // Initialize upgrades on first game start; reset afterwards
                if (!this.upgradeManager) {
                    this.upgradeManager = new UpgradeManager(this);
                } else {
                    this.upgradeManager.reset();
                }

                this.reset();
                // UI layout changed: refresh canvas rect cache for accurate mouse mapping
                this.refreshCanvasRectCache();
                
                // Switch from lobby music to game music
                this.audio.stopLobbyMusic();
                if (this.audio.musicEnabled) {
                    this.audio.playGameMusic();
                }
            }
            
            returnToLobby() {
                this.inLobby = true;
                this.gameOver = false;
                this.paused = false;
                
                // Hide quit button && show lobby
                document.getElementById('quitButton').classList.remove('visible');
                document.getElementById('lobby').classList.remove('hidden');
                
                // Hide game UI && clear input
                this.uiManager.hideUI();
                this.toggleRedBorder(false);
                this.input.clear();
                
                // Stop game music && start lobby music
                this.audio.stopGameMusic();
                if (this.audio.musicEnabled) {
                    this.audio.playLobbyMusic();
                }
                
                // Reset game state
                this.reset();
                // Update lobby best stats label when returning
                this.updateBestStatsLabel();
                // UI layout changed: refresh rect cache
                this.refreshCanvasRectCache();
                // Refresh theme locks in the lobby based on latest best score
                try {
                    const themeSelector = document.getElementById('themeSelector');
                    if (themeSelector) {
                        const themeOptions = Array.from(themeSelector.querySelectorAll('.theme-option'));
                        const THEME_UNLOCKS = { default: 0, cyan: 2500, rainbow: 5000 };
                        const best = this.bestScore || 0;
                        themeOptions.forEach(opt => {
                            const t = opt.getAttribute('data-theme');
                            const required = THEME_UNLOCKS[t] || 0;
                            if (best < required) opt.classList.add('locked'); else opt.classList.remove('locked');
                        });
                        const themeCyanNameEl = document.getElementById('themeCyanName');
                        const themeRainbowNameEl = document.getElementById('themeRainbowName');
                        if (themeCyanNameEl) themeCyanNameEl.textContent = (best >= 2500) ? 'Glow' : '2500 Pts.';
                        if (themeRainbowNameEl) themeRainbowNameEl.textContent = (best >= 5000) ? 'Rainbow' : '5000 Pts.';
                    }
                } catch (e) {}
                if (typeof this.updateLobbyCharacterImage === 'function') {
                    this.updateLobbyCharacterImage(this.playerTheme || 'default');
                }
            }

            toggleRedBorder(isActive) {
                if (!this.redBorderElement) {
                    this.redBorderElement = document.querySelector('.red-gradient-border');
                }
                if (!this.redBorderElement) return;
                this.redBorderElement.classList.toggle('active', Boolean(isActive));
            }

            reset() {
                this._clearGameOverVoiceTimeout();
                this.input.clear();
                this.upgradePause = false;
                this.upgradeOverlayHiddenByPause = false;
                const overlay = document.getElementById('upgradeOverlay');
                if (overlay) {
                        overlay.classList.remove('visible');
                    }
                  this.player = new Player(this.canvas);
                  // Apply selected theme to new player instance
                  this.player.theme = this.playerTheme || 'default';
                  if (this.gridBlink) {
                      this.gridBlink.startTime = 0;
                      this.gridBlink.activeUntil = 0;
                      this.gridBlink.intensity = 0;
                  }
                  this.bullets = [];
                  this.rockets = [];
                  this.mines = [];
                  this.enemyBullets = [];
                    this.enemyRockets = [];
                    this.enemyMines = [];
                  this.enemies = [];
                this.effects = new EffectsManager();
                this.score = 0;
                this.enemiesKilled = 0;
                this.startTime = Date.now();
                this.currentWave = 0;
                this.waveStarted = false;
                this.waveStartTime = 0;
                this.enemiesToSpawn = [];
                this.spawnedEnemies = 0;
                this.waveSpawnInterval = 0;
                this.eliteSpawnSchedules = [];
                this.totalEliteToSpawn = 0;
                this.spawnedEliteEnemies = 0;
                this.initialSpawnDelayUntil = Date.now() + INITIAL_ENEMY_SPAWN_DELAY_MS;
                this.gameOver = false;
                this.paused = false;
                  // Boss state
                  this.inBossPhase = false;
                  this.bossWarningEndTime = 0;
                  this.activeBoss = null;
                  this.pendingBossKey = null;
                  this.pendingBossDisplayName = '';
                  this.usedBossTypes = new Set();
                  this.defeatedBossCount = 0;
                  this.totalBossTimeExcluded = 0;
                  this.bossTimerPauseStart = 0;
                if (!this.tetrisManager) this.tetrisManager = new TetrisManager(this);
                this.tetrisManager.reset();
                
                // Reset best flags for new session
                this.isNewBestScore = false;
                this.isNewMaxWave = false;

                // Player XP state
                this.playerLevel = 1;
                this.playerXp = 0;
                this.playerXpRequired = getRequiredXpForLevel(this.playerLevel);
                if (this.uiManager && this.uiManager.resetXPBar) this.uiManager.resetXPBar();
                // Reset upgrades
                if (this.upgradeManager) this.upgradeManager.reset();
                // Reset upgrade multipliers
                this.player.speedMultiplier = 1;
                this.player.bulletDamageMultiplier = 1;
                this.player.railgunChargeSpeedMultiplier = 1;
                this.player.explosionAreaMultiplier = 1;
                if (this.player) {
                    this.player.maxHealth = 100;
                    this.player.health = 100;
                    this.player.speedMultiplier = 1;
                    this.player.bulletDamageMultiplier = 1;
                    this.player.railgunChargeSpeedMultiplier = 1;
                    this.player.explosionAreaMultiplier = 1;
                }
                
                // Grouped wave state
                if (USE_WAVE_GROUPS) {
                    this.waveGroupsPrepared = WAVE_GROUPS.map(group => shuffleArray(group));
                    this.currentGroupIndex = 0;
                    this.currentGroupQueue = this.waveGroupsPrepared.length > 0 ? this.waveGroupsPrepared[0].slice() : [];
                } else {
                    this.waveGroupsPrepared = [];
                    this.currentGroupIndex = 0;
                    this.currentGroupQueue = [];
                }
                this.pauseTime = 0;
                this.gameOverTime = 0;
                this.lastShot = 0;
                this.gameOverBlinkFrame = 0;
                this.pauseBlinkFrame = 0;
                this.player.stopRailgunCharge(this.audio);
                this.wavePauseEndTime = 0;
                this.inWavePause = false;
                this.controlsInfoAutoHideTriggered = false;
                if (this.uiManager && this.uiManager.showControlsInfo) {
                    this.uiManager.showControlsInfo();
                }
                
                // Reset grid position when game resets
                this.gridOffsetX = 0;
                this.gridOffsetY = 0;
                
                // Reset player tracking for parallax
                if (!this.inLobby) {
                    this.lastPlayerX = this.player.x;
                    this.lastPlayerY = this.player.y;
                }
                
                // Hide UI when in lobby, show when in game
                if (this.inLobby) {
                    this.uiManager.hideUI();
                } else {
                    this.uiManager.showUI();
                }
            }

            setupEventListeners() {
                window.addEventListener('resize', () => {
                    // Recompute uniform scale and letterbox offsets
                    const baseW = SPEED_SETTINGS.baseWidth;
                    const baseH = SPEED_SETTINGS.baseHeight;
                    const scale = Math.min(window.innerWidth / baseW, window.innerHeight / baseH);
                    const cssW = Math.floor(baseW * scale);
                    const cssH = Math.floor(baseH * scale);
                    const offsetX = Math.floor((window.innerWidth - cssW) / 2);
                    const offsetY = Math.floor((window.innerHeight - cssH) / 2);
                    this.canvas.style.width = cssW + 'px';
                    this.canvas.style.height = cssH + 'px';
                    this.canvas.style.left = offsetX + 'px';
                    this.canvas.style.top = offsetY + 'px';
                    this.speedScale = 1;
                    // Cache canvas rect-derived scales for mouse mapping
                    this.refreshCanvasRectCache();
                    this.backgroundBinary.canvas = this.canvas;
                    this.fallingNumbers.canvas = this.canvas;
                    if (this.gameOverRain) {
                        this.gameOverRain.canvas = this.canvas;
                    }
                    if (this.player.health === 100 && this.score === 0) {
                        this.player.x = this.canvas.width / 2;
                        this.player.y = this.canvas.height / 2;
                    }
                    // Update cached lobby radial center and outer radius
                    this.lobbyRadialOuterR = Math.sqrt(this.canvas.width * this.canvas.width + this.canvas.height * this.canvas.height) / 2 + 20;
                    if (this.updateLobbyRadialCenterFromLogo) {
                        this.updateLobbyRadialCenterFromLogo();
                    } else {
                        this.lobbyRadialCenterX = this.canvas.width / 2;
                        this.lobbyRadialCenterY = this.canvas.height / 3;
                    }
                    // Refresh cached boss-safe min center Y from XP bar position
                    const xpEl = document.querySelector('.xp-bar');
                    if (xpEl) {
                        const xpRect = xpEl.getBoundingClientRect();
                        const canvasRect = this.canvas.getBoundingClientRect();
                        if (xpRect.bottom <= canvasRect.top) {
                            this._cachedBossSafeMinCenterY = 120;
                        } else {
                            const xpBottomCanvasY = this.screenToCanvasY(xpRect.bottom);
                            const margin = 8;
                            this._cachedBossSafeMinCenterY = xpBottomCanvasY + 74 + margin;
                        }
                    }
                });

                document.addEventListener('keydown', e => {
                    const code = e.code;
                    if (['Escape', 'Space', 'KeyW', 'KeyA', 'KeyS', 'KeyD', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ShiftLeft', 'ShiftRight'].includes(code)) {
                        e.preventDefault();
                    }
                    if (code === 'Space' && this.inLobby) {
                        if (this.input.preventSpam('startGame', 200)) {
                            this.audio.playSound('buttonClick');
                            this.startGame();
                        }
                        return;
                    }
                    if (code === 'Escape' && this.isTutorialOpen) {
                        if (typeof this.closeTutorial === 'function') {
                            this.closeTutorial();
                        }
                        return;
                    }
                    if (code === 'Escape' && this.input.preventSpam('pause', 200)) {
                        if (this.gameOver) {
                            // ESC in game over screen returns to lobby
                            this.returnToLobby();
                        } else if (!this.inLobby) {
                            if (this.upgradePause) {
                                if (this.upgradeOverlayHiddenByPause) {
                                    if (this.restoreUpgradeOverlayAfterPause()) {
                                        return;
                                    }
                                } else {
                                    this.enterPause();
                                    return;
                                }
                            }
                            // ESC in game toggles pause
                            const shouldPause = !this.paused;
                            this.paused = shouldPause;
                            if (shouldPause) {
                                this.enterPause();
                            } else {
                                this.exitPause();
                            }
                        }
                    }
                    if (code === 'Space' && !this.gameOver && !this.inLobby && this.upgradePause && this.upgradeOverlayHiddenByPause) {
                        if (this.input.preventSpam('pause', 200)) {
                            this.restoreUpgradeOverlayAfterPause();
                        }
                        return;
                    }
                    if (code === 'Space' && this.paused && !this.gameOver && !this.inLobby) {
                        if (this.input.preventSpam('pause', 200)) {
                            this.paused = false;
                            this.exitPause();
                        }
                        return;
                    }
                    if (code === 'Space' && this.input.preventSpam('restart', 100)) {
                        if (this.gameOver) {
                            this.reset();
                            if (this.audio.musicEnabled) {
                                this.audio.playGameMusic();
                            }
                            // Prevent the same SPACE keydown from placing a mine immediately after restart
                            return;
                        }
                    }
                    // Place mine on SPACE during gameplay
                    if (!this.gameOver && !this.paused && !this.inLobby) {
                        if (code === 'Space') {
                            this.placeMine();
                        }
                    }
                    if (!this.gameOver && !this.paused && !this.inLobby) {
                        const moveKeys = {
                            'KeyW': 'w', 'ArrowUp': 'w',
                            'KeyS': 's', 'ArrowDown': 's',
                            'KeyA': 'a', 'ArrowLeft': 'a',
                            'KeyD': 'd', 'ArrowRight': 'd',
                            'ShiftLeft': 'shift', 'ShiftRight': 'shift'
                        };
                        if (moveKeys[code]) this.input.keys[moveKeys[code]] = true;
                        if (code === 'ShiftLeft' || code === 'ShiftRight') {
                            if (this.input.preventSpam('dash', 500)) {
                                this.player.startDash(this.input.keys, this.effects, this.audio);
                            }
                        }
                    }
                });

                document.addEventListener('keyup', e => {
                    const moveKeys = {
                        'KeyW': 'w', 'ArrowUp': 'w',
                        'KeyS': 's', 'ArrowDown': 's',
                        'KeyA': 'a', 'ArrowLeft': 'a',
                        'KeyD': 'd', 'ArrowRight': 'd',
                        'ShiftLeft': 'shift', 'ShiftRight': 'shift'
                    };
                    if (moveKeys[e.code]) {
                        e.preventDefault();
                        this.input.keys[moveKeys[e.code]] = false;
                    }
                });

                this.canvas.addEventListener('mousemove', e => {
                    if (this.gameOver || this.inLobby) return;
                    // Use cached rect/scales to avoid repeated DOM reads
                    // If cache is missing or stale (first movement), refresh once
                    if (!isFinite(this._cachedRectLeft) || !isFinite(this._cachedRectTop) || !isFinite(this._cachedScaleX) || !isFinite(this._cachedScaleY)) {
                        this.refreshCanvasRectCache();
                    }
                    const left = this._cachedRectLeft;
                    const top = this._cachedRectTop;
                    const scaleX = this._cachedScaleX || 1;
                    const scaleY = this._cachedScaleY || 1;
                    const mx = (e.clientX - left) * scaleX;
                    const my = (e.clientY - top) * scaleY;
                    if (isFinite(mx) && isFinite(my)) {
                        this.input.mouse.x = mx;
                        this.input.mouse.y = my;
                    }
                });

                this.canvas.addEventListener('mousedown', e => {
                    if (this.gameOver || this.inLobby) return;
                    if (!this.paused) {
                        if (e.button === 0) this.input.mouse.down = true;
                        else if (e.button === 1) { this.input.mouse.middleDown = true; if (this.launchRocket) this.launchRocket(); e.preventDefault(); }
                        else if (e.button === 2) this.input.mouse.rightDown = true;
                    }
                });

                this.canvas.addEventListener('mouseup', e => {
                    if (e.button === 0) this.input.mouse.down = false;
                    else if (e.button === 1) this.input.mouse.middleDown = false;
                    else if (e.button === 2) this.input.mouse.rightDown = false;
                });

                this.canvas.addEventListener('contextmenu', e => e.preventDefault());
                // Prevent right-click menu globally as a safeguard
                document.addEventListener('contextmenu', e => {
                    if (!this.inLobby) e.preventDefault();
                });

                window.addEventListener('blur', () => this.input.clear());
                window.addEventListener('focus', () => this.input.clear());
            }

            enterPause() {
                const quitButton = document.getElementById('quitButton');
                this.pauseTime = Date.now();
                this.input.clear();
                this.suspendUpgradeOverlayForPause();
                this.audio.pauseMusic();
                this.player.stopRailgunCharge(this.audio);
                this.audio.playSound('pauseActivate');
                if (this.effects && this.effects.disableRailgunAura) {
                    this.effects.disableRailgunAura();
                }
                if (quitButton) {
                    quitButton.classList.add('visible');
                }
                if (this.uiManager && this.uiManager.showControlsInfo) {
                    this.uiManager.showControlsInfo();
                }
            }

            exitPause(options = {}) {
                const { playSound = true } = options;
                const now = Date.now();
                const pauseStart = Number.isFinite(this.pauseTime) && this.pauseTime > 0 ? this.pauseTime : now;
                const pauseDelta = now - pauseStart;
                
                if (Number.isFinite(this.startTime)) {
                    this.startTime += pauseDelta;
                }
                if (Number.isFinite(this.waveStartTime)) {
                    this.waveStartTime += pauseDelta;
                }
                if (Number.isFinite(this.initialSpawnDelayUntil)) {
                    this.initialSpawnDelayUntil += pauseDelta;
                }
                if (Number.isFinite(this.wavePauseEndTime) && this.wavePauseEndTime > 0) {
                    this.wavePauseEndTime += pauseDelta;
                }
                if (Number.isFinite(this.bossWarningEndTime) && this.bossWarningEndTime > 0) {
                    this.bossWarningEndTime += pauseDelta;
                }
                if (this.inBossPhase && Number.isFinite(this.bossTimerPauseStart) && this.bossTimerPauseStart > 0) {
                    this.bossTimerPauseStart += pauseDelta;
                }
                
                if (this.audio && typeof this.audio.resumeMusic === 'function') {
                    this.audio.resumeMusic();
                    if (playSound && typeof this.audio.playSound === 'function') {
                        this.audio.playSound('pauseDeactivate');
                    }
                }
                
                const quitButton = document.getElementById('quitButton');
                if (quitButton) {
                    quitButton.classList.remove('visible');
                }
                
                if (this.uiManager && typeof this.uiManager.hideControlsInfo === 'function') {
                    const elapsed = this.getEffectiveElapsedTime();
                    if (this.controlsInfoAutoHideTriggered || elapsed >= this.controlsInfoAutoHideDelay) {
                        this.uiManager.hideControlsInfo();
                        this.controlsInfoAutoHideTriggered = true;
                    }
                }
                
                this.pauseTime = 0;
            }

            suspendUpgradeOverlayForPause() {
                if (!this.upgradePause) return false;
                const overlay = document.getElementById('upgradeOverlay');
                if (!overlay) return false;
                if (overlay.classList.contains('visible')) {
                    overlay.classList.remove('visible');
                    this.upgradeOverlayHiddenByPause = true;
                    return true;
                }
                return false;
            }

            restoreUpgradeOverlayAfterPause() {
                if (!this.upgradePause || !this.upgradeOverlayHiddenByPause) return false;
                const overlay = document.getElementById('upgradeOverlay');
                if (overlay && !overlay.classList.contains('visible')) {
                    overlay.classList.add('visible');
                }
                this.upgradeOverlayHiddenByPause = false;
                this.exitPause({ playSound: false });
                this.paused = true;
                this.pauseTime = Date.now();
                return true;
            }

            placeMine() {
                const now = Date.now();
                const t = Math.max(0.001, getTimeScale());
                if (now - this.lastMinePlaced < this.mineCooldownMs / t) return;
                const dmgMul = this.player.bulletDamageMultiplier || 1;
                const baseDamage = PLAYER_WEAPON_BASE_DAMAGE.mine;
                const dmg = Math.floor(baseDamage * dmgMul);
                const areaMul = this.player.explosionAreaMultiplier || 1;
                this.mines.push(new Mine(this.player.x, this.player.y, this.player.radius, dmg, areaMul));
                this.lastMinePlaced = now;
                if (this.audio) this.audio.playSound('mine_placed');
            }

            shoot() {
                const now = Date.now();
                if (now - this.lastShot < this.shootDelay / Math.max(0.001, getTimeScale())) return;
                const dx = this.input.mouse.x - this.player.x;
                const dy = this.input.mouse.y - this.player.y;
                const dist = Math.sqrt(dx * dx + dy * dy) || 0.1;
                const baseDamage = PLAYER_WEAPON_BASE_DAMAGE.bullet;
                const dmgMul = this.player.bulletDamageMultiplier || 1;
                this.bullets.push(new Bullet(
                    this.player.x,
                    this.player.y,
                    (dx / dist) * 8,
                    (dy / dist) * 8,
                    Math.floor(baseDamage * dmgMul)
                ));
                this.lastShot = now;
                this.audio.playSound('bulletShoot');
            }

            launchRocket() {
                const now = Date.now();
                const t = Math.max(0.001, getTimeScale());
                if (now - this.lastRocketShot < this.rocketCooldownMs / t) {
                    this.audio.playSound('RocketReload');
                    return;
                }
                const dx = this.input.mouse.x - this.player.x;
                const dy = this.input.mouse.y - this.player.y;
                const baseDamage = PLAYER_WEAPON_BASE_DAMAGE.rocket;
                const dmg = Math.floor(baseDamage * (this.player.bulletDamageMultiplier || 1));
                const areaMul = this.player.explosionAreaMultiplier || 1;
                this.rockets.push(new Rocket(this.player.x, this.player.y, dx, dy, dmg, areaMul));
                this.lastRocketShot = now;
                this.audio.playSound('RocketLaunch');
            }

            spawnEnemy(type) {
                const side = Math.floor(Math.random() * 4);
                const margin = 30;
                let x, y;
                switch (side) {
                    case 0: x = Math.random() * this.canvas.width; y = -margin; break;
                    case 1: x = this.canvas.width + margin; y = Math.random() * this.canvas.height; break;
                    case 2: x = Math.random() * this.canvas.width; y = this.canvas.height + margin; break;
                    case 3: x = -margin; y = Math.random() * this.canvas.height; break;
                }
                this.enemies.push(new Enemy(x, y, type, ENEMY_TYPES[type]));
            }

            spawnTrianglesAround(cx, cy, sourceEnemy = null) {
                const count = 3;
                const minRadius = 70;
                const extraRadius = 40; // spawn a bit further out for spacing
                const now = Date.now();
                const fromRhombusBoss = !!(sourceEnemy && (sourceEnemy.spawnedByRhombusBoss || sourceEnemy.type === 'rhombus_boss'));
                for (let i = 0; i < count; i++) {
                    const angle = (Math.PI * 2 * i) / count + Math.random() * 0.4; // slight randomization
                    const distance = minRadius + extraRadius + Math.random() * 30;
                    const x = cx + Math.cos(angle) * distance;
                    const y = cy + Math.sin(angle) * distance;
                    const enemy = new Enemy(x, y, 'triangle', ENEMY_TYPES['triangle']);
                    enemy.spawnShieldUntil = now + 1000;
                    if (fromRhombusBoss) {
                        enemy.spawnedByRhombusBoss = true;
                        enemy.spawnedByBossType = 'rhombus_boss';
                    }
                    this.enemies.push(enemy);
                }
                if (this.audio) this.audio.playSound('MinionSummon');
            }

            triggerKillerTriangleDeath(enemy, options = {}) {
                if (!enemy) return;
                const config = ENEMY_TYPES[enemy.type] || ENEMY_TYPES['killer_triangle'] || {};
                const radius = options.explosionRadius || enemy.explosionRadius || config.explosionRadius || 300;
                const damage = options.explosionDamage || enemy.explosionDamage || config.explosionDamage || 50;
                if (this.effects) {
                    if (typeof this.effects.createKillerTriangleDetonation === 'function') {
                        this.effects.createKillerTriangleDetonation(enemy.x, enemy.y, radius);
                    }
                    this.effects.createExplosion(enemy.x, enemy.y, enemy.type, enemy.radius);
                }
                if (typeof this.shakeCanvas === 'function') {
                    this.shakeCanvas(8, 280);
                }
                if (this.player) {
                    const dx = this.player.x - enemy.x;
                    const dy = this.player.y - enemy.y;
                    if ((dx * dx + dy * dy) <= radius * radius) {
                        this.player.takeDamage(damage, enemy.x, enemy.y, this.effects, this.audio);
                    }
                }
                const radiusSq = radius * radius;
                const now = Date.now();
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const target = this.enemies[i];
                    if (!target || target === enemy || target.health <= 0) continue;
                    const targetRadius = typeof target.radius === 'number' ? target.radius : 0;
                    if (Math.abs(target.x - enemy.x) > radius + targetRadius || Math.abs(target.y - enemy.y) > radius + targetRadius) continue;
                    const dxEnemy = target.x - enemy.x;
                    const dyEnemy = target.y - enemy.y;
                    if ((dxEnemy * dxEnemy + dyEnemy * dyEnemy) > radiusSq) continue;
                    if ((target.spawnShieldUntil && now < target.spawnShieldUntil) || ((target.type === 'rhombus' || target.type === 'rhombus_boss') && target.invulnerable)) continue;
                    const alive = target.takeDamage(damage, this.effects, this.score, this.ctx, this.audio, {
                        damageType: 'killer_triangle_explosion',
                        impactX: enemy.x,
                        impactY: enemy.y
                    });
                    if (!alive) {
                        this.handleEnemyKilled(target, {
                            cause: 'killer_triangle_explosion',
                            impactX: enemy.x,
                            impactY: enemy.y,
                            explosionRadius: radius,
                            explosionDamage: damage
                        });
                        const last = this.enemies.length - 1;
                        if (i <= last && this.enemies[i] === target) {
                            if (i !== last) {
                                this.enemies[i] = this.enemies[last];
                            }
                            this.enemies.pop();
                        } else {
                            const idx = this.enemies.indexOf(target);
                            if (idx !== -1) {
                                const lastIdx = this.enemies.length - 1;
                                if (idx !== lastIdx) {
                                    this.enemies[idx] = this.enemies[lastIdx];
                                }
                                this.enemies.pop();
                            }
                        }
                        if (this.inBossPhase && target.type && (ENEMY_TYPES[target.type]?.isBoss || ENEMY_TYPES[target.type]?.role === 'boss')) {
                            this.onBossDefeated();
                        }
                        const points = typeof target.points === 'number' ? target.points : 0;
                        this.score += points;
                        if (this.uiManager && typeof this.uiManager.showScoreAddition === 'function') {
                            this.uiManager.showScoreAddition(points);
                        }
                        this.enemiesKilled++;
                    }
                }
            }

            handleEnemyKilled(enemy, options = {}) {
                if (!enemy) return;
                if (enemy.type === 'killer_triangle') {
                    this.triggerKillerTriangleDeath(enemy, options);
                } else if (this.effects) {
                    this.effects.createExplosion(enemy.x, enemy.y, enemy.type, enemy.radius);
                }
                if (enemy.type === 'rhombus') {
                    this.spawnTrianglesAround(enemy.x, enemy.y, enemy);
                }
                this.maybeSpawnXpReward(enemy);
            }

            _applyEnemyExplosionDamage(x, y, radius, damage) {
                const player = this.player;
                if (!player || player.invulnerable) return;
                const limit = player.radius + radius;
                const dx = player.x - x;
                const dy = player.y - y;
                if (dx * dx + dy * dy <= limit * limit) {
                    player.takeDamage(damage, x, y, this.effects, this.audio);
                }
            }

            _handlePlayerExplosion(x, y, radius, damage, options = {}) {
                if (!Number.isFinite(x) || !Number.isFinite(y)) return;
                if (!Number.isFinite(radius) || radius <= 0) return;
                if (!Number.isFinite(damage) || damage <= 0) return;
                const type = options.type === 'mine' ? 'mine' : 'rocket';
                const applyBossDamage = options.applyBossDamage !== false;
                const includeTetris = options.includeTetris === true;
                const playEffects = options.playEffects !== false;
                const shakeIntensity = options.shakeIntensity != null
                    ? options.shakeIntensity
                    : (type === 'rocket' ? 7 : 6);
                const shakeDuration = options.shakeDuration != null
                    ? options.shakeDuration
                    : (type === 'rocket' ? 260 : 240);

                if (playEffects && this.effects && typeof this.effects.createRocketExplosionRing === 'function') {
                    this.effects.createRocketExplosionRing(x, y, radius);
                    if (this.audio && typeof this.audio.playSound === 'function') {
                        this.audio.playSound('RocketExplotion');
                    }
                    if (typeof this.shakeCanvas === 'function') {
                        this.shakeCanvas(shakeIntensity, shakeDuration);
                    }
                }

                const now = Date.now();
                for (let ei = this.enemies.length - 1; ei >= 0; ei--) {
                    const enemy = this.enemies[ei];
                    if (!enemy) continue;
                    const enemyRadius = typeof enemy.radius === 'number' ? enemy.radius : 0;
                    const combinedRadius = radius + enemyRadius;
                    const dx = enemy.x - x;
                    const dy = enemy.y - y;
                    if (Math.abs(dx) > combinedRadius || Math.abs(dy) > combinedRadius) continue;
                    if (dx * dx + dy * dy <= combinedRadius * combinedRadius) {
                        if ((enemy.spawnShieldUntil && now < enemy.spawnShieldUntil) ||
                            ((enemy.type === 'rhombus' || enemy.type === 'rhombus_boss') && enemy.invulnerable)) {
                            continue;
                        }
                        const damageType = type;
                        const alive = enemy.takeDamage(damage, this.effects, this.score, this.ctx, this.audio, {
                            damageType,
                            impactX: x,
                            impactY: y
                        });
                        if (!alive) {
                            this.handleEnemyKilled(enemy, { cause: damageType, impactX: x, impactY: y });
                        }
                    }
                }

                if (!applyBossDamage || !this.inBossPhase || !this.activeBoss) return;
                const boss = this.activeBoss;
                if (boss instanceof TetrisCrossBoss) {
                    if (!includeTetris || !this.tetrisManager || !Array.isArray(this.tetrisManager.activePieces)) return;
                    for (let p = this.tetrisManager.activePieces.length - 1; p >= 0; p--) {
                        const piece = this.tetrisManager.activePieces[p];
                        if (!piece || piece.dying || typeof piece.getCells !== 'function') continue;
                        const cells = piece.getCells();
                        for (let c = 0; c < cells.length; c++) {
                            const cell = cells[c];
                            const dx = cell.x - x;
                            const dy = cell.y - y;
                            if (dx * dx + dy * dy <= radius * radius) {
                                piece.hp -= damage;
                                piece.damageFlash = 12;
                                if (piece.hp <= 0) {
                                    if (typeof piece.startDeath === 'function') piece.startDeath(this.effects);
                                    break;
                                }
                            }
                        }
                    }
                    return;
                }
                if (typeof boss.handleAoeDamage === 'function') {
                    boss.handleAoeDamage(x, y, radius, damage, this.effects, this.audio);
                }
            }

            _detonatePlayerRocket(rocket, options = {}) {
                if (!rocket) return;
                this._handlePlayerExplosion(
                    rocket.x,
                    rocket.y,
                    rocket.aoeRadius,
                    rocket.damage,
                    Object.assign({ type: 'rocket', includeTetris: true }, options)
                );
            }

            _detonatePlayerMine(mine, options = {}) {
                if (!mine) return;
                this._handlePlayerExplosion(
                    mine.x,
                    mine.y,
                    mine.aoeRadius,
                    mine.damage,
                    Object.assign({ type: 'mine', includeTetris: false }, options)
                );
            }

            shouldSuppressXpDropForEnemy(enemy) {
                if (!enemy) return false;
                if (!(this.inBossPhase && this.activeBoss && this.activeBoss.type === 'rhombus_boss')) {
                    return false;
                }
                return !!enemy.spawnedByRhombusBoss;
            }

            maybeSpawnXpReward(enemy) {
                if (!enemy || !this.effects || typeof this.effects.createXPRing !== 'function') return;
                const config = ENEMY_TYPES[enemy.type] || {};
                const xp = config.xp || 0;
                if (xp <= 0) return;
                if (this.shouldSuppressXpDropForEnemy(enemy)) return;
                const baseRadius = (typeof enemy.radius === 'number') ? enemy.radius : 0;
                const size = Math.max(8, baseRadius * 0.25);
                this.effects.createXPRing(enemy.x, enemy.y, size, xp);
            }

            startWave(waveConfig) {
                // For grouped waves, wave numbers aren't provided; increment sequentially
                if (USE_WAVE_GROUPS) {
                    this.currentWave += 1;
                } else {
                    this.currentWave = waveConfig.wave;
                }
                this.waveStarted = true;
                if (this.initialSpawnDelayUntil) {
                    this.initialSpawnDelayUntil = null;
                }
                this.waveStartTime = Date.now();
                this.spawnedEnemies = 0;
                this.enemiesToSpawn = [];
                this.eliteSpawnSchedules = [];
                this.totalEliteToSpawn = 0;
                this.spawnedEliteEnemies = 0;
                this.inWavePause = false;
                const simultaneousSpawns = Math.max(1, waveConfig.simultaneousSpawns || 1);
                this.waveSimultaneousSpawns = simultaneousSpawns;
                
                const dashSquares = Math.max(0, waveConfig.enemies.dashSquares || 0);
                const baseCubes = Math.max(0, waveConfig.enemies.cubes || 0);
                const killerTriangles = Math.max(0, waveConfig.enemies.killerTriangles || 0);
                const superOctagons = Math.max(0, waveConfig.enemies.superOctagons || 0);
                const enemyCounts = {
                    square: Math.max(0, baseCubes - dashSquares),
                    dash_square: dashSquares,
                    triangle: Math.max(0, waveConfig.enemies.triangles || 0),
                    octagon: Math.max(0, waveConfig.enemies.octagons || 0),
                    rhombus: Math.max(0, waveConfig.enemies.rhombuses || 0)
                };
                for (const [type, count] of Object.entries(enemyCounts)) {
                    for (let i = 0; i < count; i++) {
                        this.enemiesToSpawn.push(type);
                    }
                }
                for (let i = this.enemiesToSpawn.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.enemiesToSpawn[i], this.enemiesToSpawn[j]] = [this.enemiesToSpawn[j], this.enemiesToSpawn[i]];
                }
                
                const timeScale = Math.max(0.001, getTimeScale());
                const eliteEntries = [];
                const explicitEliteTypes = new Set();
                const normalizeEliteEntry = entry => {
                    if (!entry) return null;
                    let rawType = entry.type ?? entry.enemy ?? entry.key ?? entry.name;
                    if (typeof rawType !== 'string') return null;
                    const trimmed = rawType.trim();
                    let typeKey = trimmed;
                    if (!ENEMY_TYPES[typeKey]) {
                        const aliasLookup = trimmed.replace(/[\s_-]+/g, '').toLowerCase();
                        const aliasMap = {
                            killertriangle: 'killer_triangle',
                            killertriangles: 'killer_triangle',
                            killer_triangle: 'killer_triangle',
                            superoctagon: 'super_octagon',
                            superoctagons: 'super_octagon',
                            super_octagon: 'super_octagon'
                        };
                        typeKey = aliasMap[aliasLookup] || aliasMap[trimmed.toLowerCase()] || typeKey;
                    }
                    if (!ENEMY_TYPES[typeKey]) return null;
                    const countSource = entry.count ?? entry.amount ?? entry.quantity ?? entry.total;
                    const countNumber = Number(countSource);
                    const count = Number.isFinite(countNumber) ? Math.max(0, Math.floor(countNumber)) : 0;
                    if (count <= 0) return null;
                    const initialDelayValue = Number(entry.initialDelayMs ?? entry.firstSpawnDelayMs ?? entry.spawnDelayMs ?? entry.delayMs ?? 0);
                    const safeInitialDelay = Number.isFinite(initialDelayValue) ? Math.max(0, initialDelayValue) : 0;
                    const repeatDelaySource = entry.repeatDelayMs ?? entry.spawnIntervalMs ?? entry.intervalMs;
                    let repeatDelayValue = Number(repeatDelaySource);
                    if (!Number.isFinite(repeatDelayValue)) {
                        repeatDelayValue = count > 1 ? safeInitialDelay : safeInitialDelay;
                    }
                    const safeRepeatDelay = Math.max(0, repeatDelayValue);
                    return {
                        type: typeKey,
                        count,
                        firstDelayRealMs: safeInitialDelay / timeScale,
                        intervalRealMs: safeRepeatDelay / timeScale
                    };
                };
                const configElite = Array.isArray(waveConfig.eliteSpawns)
                    ? waveConfig.eliteSpawns
                    : (Array.isArray(waveConfig.elites) ? waveConfig.elites : null);
                if (configElite) {
                    for (const entry of configElite) {
                        const normalized = normalizeEliteEntry(entry);
                        if (normalized) {
                            eliteEntries.push(normalized);
                            explicitEliteTypes.add(normalized.type);
                        }
                    }
                }
                if (killerTriangles > 0 && !explicitEliteTypes.has('killer_triangle')) {
                    const normalized = normalizeEliteEntry({ type: 'killer_triangle', count: killerTriangles, initialDelayMs: 0, repeatDelayMs: 0 });
                    if (normalized) {
                        eliteEntries.push(normalized);
                    }
                }
                if (superOctagons > 0 && !explicitEliteTypes.has('super_octagon')) {
                    const normalized = normalizeEliteEntry({ type: 'super_octagon', count: superOctagons, initialDelayMs: 0, repeatDelayMs: 0 });
                    if (normalized) {
                        eliteEntries.push(normalized);
                    }
                }
                this.eliteSpawnSchedules = eliteEntries.map(entry => ({
                    type: entry.type,
                    count: entry.count,
                    spawned: 0,
                    nextSpawnAt: this.waveStartTime + entry.firstDelayRealMs,
                    intervalRealMs: entry.intervalRealMs
                }));
                this.totalEliteToSpawn = this.eliteSpawnSchedules.reduce((sum, schedule) => sum + schedule.count, 0);
                
                const totalEnemies = this.enemiesToSpawn.length;
                if (totalEnemies > 0) {
                    const spawnDuration = Math.max(0, waveConfig.spawnTime || 0);
                    const spawnBatches = Math.max(1, Math.ceil(totalEnemies / simultaneousSpawns));
                    this.waveSpawnInterval = (spawnDuration / spawnBatches) / Math.max(0.001, getTimeScale());
                } else {
                    this.waveSpawnInterval = 0;
                }
            }

            update(timestamp) {
                if (this.inLobby) return;  // Don't update game logic in lobby
                if (this.gameOver || this.paused) return;
                if (this.upgradePause) return;
                
                  const now = Date.now();
                  const gameTime = this.getEffectiveElapsedTime(now);
                  if (this.gridBlink && this.gridBlink.activeUntil && now >= this.gridBlink.activeUntil) {
                      this.gridBlink.activeUntil = 0;
                      this.gridBlink.intensity = 0;
                      this.gridBlink.startTime = 0;
                  }
                if (!this.controlsInfoAutoHideTriggered && gameTime >= this.controlsInfoAutoHideDelay) {
                    if (this.uiManager && this.uiManager.hideControlsInfo) {
                        this.uiManager.hideControlsInfo();
                    }
                    this.controlsInfoAutoHideTriggered = true;
                }
                
                // Boss phase timing: after warning ends, spawn boss
                if (this.inBossPhase) {
                    if (!this.activeBoss && now >= this.bossWarningEndTime) {
                        this.spawnBoss();
                    }
                }
                
                // Handle wave pause - only affects wave spawning, not gameplay
                if (this.inWavePause) {
                    if (now >= this.wavePauseEndTime) {
                        this.inWavePause = false;
                    }
                    // Continue with all normal gameplay during wave pause
                }
                
                // Only check for next wave if not in wave pause or boss phase
                const initialDelayPending = this.initialSpawnDelayUntil && now < this.initialSpawnDelayUntil;
                if (!initialDelayPending && !this.inWavePause && !this.inBossPhase) {
                    if (USE_WAVE_GROUPS) {
                        if (!this.waveStarted) {
                            const nextGrouped = this.getNextGroupedWave();
                            if (nextGrouped) {
                                this.startWave(nextGrouped);
                            }
                        }
                    } else {
                        const nextWave = WAVE_CONFIG.find(w => w.timer <= gameTime && w.wave > this.currentWave);
                        if (nextWave && !this.waveStarted) {
                            this.startWave(nextWave);
                        }
                    }
                }
                if (this.waveStarted && !this.inBossPhase && this.enemiesToSpawn.length > 0) {
                    const waveElapsed = this.waveStartTime ? (now - this.waveStartTime) : 0;
                    const simultaneousSpawns = Math.max(1, this.waveSimultaneousSpawns || 1);
                    while (this.spawnedEnemies < this.enemiesToSpawn.length) {
                        const batchesSpawned = Math.floor(this.spawnedEnemies / simultaneousSpawns);
                        const nextSpawnOffset = this.waveSpawnInterval * batchesSpawned;
                        if (waveElapsed + 1e-6 < nextSpawnOffset) break;
                        const remaining = this.enemiesToSpawn.length - this.spawnedEnemies;
                        const spawnCount = Math.min(simultaneousSpawns, remaining);
                        for (let i = 0; i < spawnCount; i++) {
                            this.spawnEnemy(this.enemiesToSpawn[this.spawnedEnemies]);
                            this.spawnedEnemies++;
                        }
                    }
                }
                
                if (this.waveStarted && !this.inBossPhase && Array.isArray(this.eliteSpawnSchedules) && this.eliteSpawnSchedules.length > 0) {
                    for (const schedule of this.eliteSpawnSchedules) {
                        if (!schedule) continue;
                        while (schedule.spawned < schedule.count && now + 1e-6 >= schedule.nextSpawnAt) {
                            this.spawnEnemy(schedule.type);
                            schedule.spawned += 1;
                            this.spawnedEliteEnemies += 1;
                            if (schedule.spawned < schedule.count) {
                                const interval = Number.isFinite(schedule.intervalRealMs) ? schedule.intervalRealMs : 0;
                                const clampedInterval = Math.max(0, interval);
                                schedule.nextSpawnAt += clampedInterval;
                                if (clampedInterval === 0) {
                                    schedule.nextSpawnAt = now;
                                }
                            } else {
                                schedule.nextSpawnAt = Infinity;
                            }
                        }
                    }
                }
                
                const allRegularSpawned = this.spawnedEnemies >= this.enemiesToSpawn.length;
                const allElitesSpawned = this.spawnedEliteEnemies >= this.totalEliteToSpawn;
                if (!this.inBossPhase && this.waveStarted && allRegularSpawned && allElitesSpawned && this.enemies.length === 0) {
                    // Wave completed, start pause before next wave
                    this.waveStarted = false;
                    this.waveSpawnInterval = 0;
                    this.eliteSpawnSchedules = [];
                    this.totalEliteToSpawn = 0;
                    this.spawnedEliteEnemies = 0;
                    this.inWavePause = true;
                    this.wavePauseEndTime = Date.now() + Math.round(3000 / Math.max(0.001, getTimeScale())); // 3 second pause
                }
                
                // Continue all normal game mechanics regardless of wave pause
                this.player.move(this.input.keys, this.canvas);
                this.player.update(this.input, this.effects, this.canvas, this.audio);

                // Update Tetris Cross boss and its pieces if active
                if (this.inBossPhase && this.activeBoss && this.activeBoss instanceof TetrisCrossBoss) {
                    this.activeBoss.update();
                    this.tetrisManager.update();
                } else if (this.inBossPhase && this.activeBoss && this.activeBoss instanceof VectorSnakeBoss) {
                    this.activeBoss.update();
                } else if (this.inBossPhase && this.activeBoss && this.activeBoss instanceof PingAndPongBoss) {
                    this.activeBoss.update();
                } else if (this.inBossPhase && this.activeBoss && this.activeBoss instanceof PlayerTwoBoss) {
                    this.activeBoss.update();
                }
                
                // Update background parallax based on player movement
                this.updateBackgroundParallax();
                
                if (this.input.mouse.down) this.shoot();
                // Update rockets
                {
                    const pendingBossRocketExplosions = [];
                    let write = 0;
                    for (let read = 0; read < this.rockets.length; read++) {
                        const r = this.rockets[read];
                        if (!r) continue;
                        if (r.update(this.canvas, this.effects)) {
                            let intercepted = false;
                            if (this.inBossPhase && this.activeBoss && this.activeBoss instanceof PingAndPongBoss) {
                                const intercept = this.activeBoss.interceptPlayerRocket(r, this.effects, this.audio);
                                if (intercept && intercept.consumed) {
                                    pendingBossRocketExplosions.push(intercept);
                                    intercepted = true;
                                }
                            }
                            if (!intercepted) {
                                if (this.inBossPhase && this.activeBoss && this.activeBoss instanceof PlayerTwoBoss) {
                                    const boss = this.activeBoss;
                                    const bossRadius = typeof boss.radius === 'number' ? boss.radius : 0;
                                    const combinedRadius = (r.radius || 0) + bossRadius;
                                    const dxBoss = r.x - boss.x;
                                    const dyBoss = r.y - boss.y;
                                    if (dxBoss * dxBoss + dyBoss * dyBoss <= combinedRadius * combinedRadius) {
                                        this._detonatePlayerRocket(r);
                                        continue;
                                    }
                                }
                                this.rockets[write++] = r;
                            }
                        } else {
                            this._detonatePlayerRocket(r, { playEffects: true, shakeIntensity: 6, shakeDuration: 250 });
                        }
                    }
                    this.rockets.length = write;
                    if (pendingBossRocketExplosions.length > 0) {
                        for (let i = 0; i < pendingBossRocketExplosions.length; i++) {
                            const explosion = pendingBossRocketExplosions[i];
                            if (!explosion) continue;
                            const ex = explosion.x;
                            const ey = explosion.y;
                            const aoe = explosion.radius;
                            const damage = explosion.damage;
                            if (!Number.isFinite(ex) || !Number.isFinite(ey) || !Number.isFinite(aoe) || aoe <= 0) continue;
                            this._handlePlayerExplosion(ex, ey, aoe, damage, {
                                type: 'rocket',
                                includeTetris: false,
                                shakeIntensity: 6,
                                shakeDuration: 250,
                                applyBossDamage: explosion.applyDamageToBoss === undefined ? true : !!explosion.applyDamageToBoss
                            });
                        }
                    }
                }
                  // Update enemy rockets
                  {
                      let write = 0;
                      for (let read = 0; read < this.enemyRockets.length; read++) {
                          const rocket = this.enemyRockets[read];
                          if (!rocket) continue;
                          if (rocket.update(this.canvas, this.effects, this.player)) {
                              this.enemyRockets[write++] = rocket;
                          } else {
                              const explosionX = rocket.x;
                              const explosionY = rocket.y;
                              const explosionRadius = rocket.aoeRadius;
                              if (this.effects && this.effects.createEnemyRocketExplosionRing) {
                                  this.effects.createEnemyRocketExplosionRing(explosionX, explosionY, explosionRadius);
                              }
                              if (this.audio) this.audio.playSound('RocketExplotion');
                              if (this.shakeCanvas) this.shakeCanvas(5, 220);
                              this._applyEnemyExplosionDamage(explosionX, explosionY, explosionRadius, rocket.damage);
                          }
                      }
                      this.enemyRockets.length = write;
                  }
                // Update mines
                {
                    const pendingBossMineExplosions = [];
                    let write = 0;
                    for (let read = 0; read < this.mines.length; read++) {
                        const m = this.mines[read];
                        if (!m) continue;
                        if (m.update(this.canvas, this.effects)) {
                            let intercepted = false;
                            if (this.inBossPhase && this.activeBoss && this.activeBoss instanceof PingAndPongBoss) {
                                const intercept = this.activeBoss.interceptPlayerMine(m, this.effects, this.audio);
                                if (intercept && intercept.consumed) {
                                    pendingBossMineExplosions.push(intercept);
                                    intercepted = true;
                                }
                            }
                            if (!intercepted) {
                                if (this.inBossPhase && this.activeBoss && this.activeBoss instanceof PlayerTwoBoss) {
                                    const boss = this.activeBoss;
                                    const bossRadius = typeof boss.radius === 'number' ? boss.radius : 0;
                                    const combinedRadius = (m.radius || 0) + bossRadius;
                                    const dxBoss = m.x - boss.x;
                                    const dyBoss = m.y - boss.y;
                                    if (dxBoss * dxBoss + dyBoss * dyBoss <= combinedRadius * combinedRadius) {
                                        this._detonatePlayerMine(m, { shakeIntensity: 7, shakeDuration: 240 });
                                        continue;
                                    }
                                }
                                this.mines[write++] = m;
                            }
                        } else {
                            this._detonatePlayerMine(m, { playEffects: true, shakeIntensity: 6, shakeDuration: 240 });
                        }
                    }
                    this.mines.length = write;
                    if (pendingBossMineExplosions.length > 0) {
                        for (let i = 0; i < pendingBossMineExplosions.length; i++) {
                            const explosion = pendingBossMineExplosions[i];
                            if (!explosion) continue;
                            const ex = explosion.x;
                            const ey = explosion.y;
                            const aoe = explosion.radius;
                            const damage = explosion.damage;
                            if (!Number.isFinite(ex) || !Number.isFinite(ey) || !Number.isFinite(aoe) || aoe <= 0) continue;
                            this._handlePlayerExplosion(ex, ey, aoe, damage, {
                                type: 'mine',
                                includeTetris: false,
                                shakeIntensity: 6,
                                shakeDuration: 240,
                                applyBossDamage: explosion.applyDamageToBoss === undefined ? true : !!explosion.applyDamageToBoss
                            });
                        }
                    }
                }
                  // Update enemy mines
                  {
                      let write = 0;
                      for (let read = 0; read < this.enemyMines.length; read++) {
                          const mine = this.enemyMines[read];
                          if (!mine) continue;
                          if (mine.update(this.canvas, this.effects, this.player)) {
                              this.enemyMines[write++] = mine;
                          } else {
                              const explosionX = mine.x;
                              const explosionY = mine.y;
                              const explosionRadius = mine.aoeRadius;
                              if (this.effects && this.effects.createEnemyRocketExplosionRing) {
                                  this.effects.createEnemyRocketExplosionRing(explosionX, explosionY, explosionRadius);
                              }
                              if (this.audio) this.audio.playSound('RocketExplotion');
                              if (this.shakeCanvas) this.shakeCanvas(5, 200);
                              this._applyEnemyExplosionDamage(explosionX, explosionY, explosionRadius, mine.damage);
                          }
                      }
                      this.enemyMines.length = write;
                  }
                // In-place compaction for bullets
                {
                    let write = 0;
                    for (let read = 0; read < this.bullets.length; read++) {
                        const b = this.bullets[read];
                        if (!b._dead && b.update(this.canvas, this.effects)) {
                            this.bullets[write++] = b;
                        }
                    }
                    this.bullets.length = write;
                }
                // In-place compaction for enemy bullets
                {
                    let write = 0;
                    for (let read = 0; read < this.enemyBullets.length; read++) {
                        const eb = this.enemyBullets[read];
                        if (eb.update(this.canvas, this.effects)) {
                            this.enemyBullets[write++] = eb;
                        }
                    }
                    this.enemyBullets.length = write;
                }
                
                // Build spatial hash for bullets this frame
                const bulletHash = new SpatialHash(80);
                for (let bi = 0; bi < this.bullets.length; bi++) {
                    const b = this.bullets[bi];
                    const r = b.radius;
                    bulletHash.insert(bi, b.x - r, b.y - r, b.x + r, b.y + r);
                }
                // Rockets collide by AoE when touching enemies or field bounds (handled above on removal).

                // Check rocket direct collision: if rocket overlaps any enemy, explode immediately
                outerRocket: for (let ri = this.rockets.length - 1; ri >= 0; ri--) {
                    const r = this.rockets[ri];
                    if (!r) continue;
                    for (let ei = this.enemies.length - 1; ei >= 0; ei--) {
                        const enemy = this.enemies[ei];
                        if (!enemy) continue;
                        const dx = r.x - enemy.x, dy = r.y - enemy.y;
                        const rr = r.radius + enemy.radius;
                        if (dx*dx + dy*dy <= rr*rr) {
                            // Remove rocket
                            const exploded = this.rockets.splice(ri, 1)[0];
                            if (exploded && this.effects && this.effects.createRocketExplosionRing) {
                                this.effects.createRocketExplosionRing(exploded.x, exploded.y, exploded.aoeRadius);
                                this.audio.playSound('RocketExplotion');
                                if (this.shakeCanvas) this.shakeCanvas(7, 260);
                            }
                            // AoE damage
                            const ex = r.x, ey = r.y, aoe = exploded.aoeRadius;
                            for (let ej = this.enemies.length - 1; ej >= 0; ej--) {
                                const en = this.enemies[ej];
                                if (!en) continue;
                                const enemyRadius = typeof en.radius === 'number' ? en.radius : 0;
                                const combinedRadius = aoe + enemyRadius;
                                const ddx = en.x - ex, ddy = en.y - ey;
                                if (Math.abs(ddx) > combinedRadius || Math.abs(ddy) > combinedRadius) continue;
                                if (ddx*ddx + ddy*ddy <= combinedRadius * combinedRadius) {
                                    if ((en.spawnShieldUntil && Date.now() < en.spawnShieldUntil) || ((en.type === 'rhombus' || en.type === 'rhombus_boss') && en.invulnerable)) continue;
                                  if (!en.takeDamage(exploded.damage, this.effects, this.score, this.ctx, this.audio, {
                                      damageType: 'rocket',
                                      impactX: ex,
                                      impactY: ey
                                  })) {
                                      this.handleEnemyKilled(en, { cause: 'rocket', impactX: ex, impactY: ey });
                                      // swap-remove enemy
                                      const last = this.enemies.length - 1;
                                      this.enemies[ej] = this.enemies[last];
                                      this.enemies.pop();
                                      if (this.inBossPhase && en.type && (ENEMY_TYPES[en.type]?.isBoss || ENEMY_TYPES[en.type]?.role === 'boss')) {
                                          this.onBossDefeated();
                                      }
                                      this.score += en.points;
                                      this.enemiesKilled++;
                                      this.uiManager.showScoreAddition(en.points);
                                  }
                                }
                            }
                            // AoE onto Tetris Cross boss pieces
                              if (this.inBossPhase && this.activeBoss && this.activeBoss instanceof TetrisCrossBoss) {
                                for (let p = this.tetrisManager.activePieces.length - 1; p >= 0; p--) {
                                    const piece = this.tetrisManager.activePieces[p];
                                    if (!piece || piece.dying) continue;
                                    const cells = piece.getCells();
                                    for (let c = 0; c < cells.length; c++) {
                                        const cell = cells[c];
                                        const ddx = cell.x - ex, ddy = cell.y - ey;
                                        if (ddx*ddx + ddy*ddy <= aoe * aoe) {
                                            piece.hp -= exploded.damage;
                                            piece.damageFlash = 12;
                                            if (piece.hp <= 0) { piece.startDeath(this.effects); break; }
                                        }
                                    }
                                }
                                } else if (this.inBossPhase && this.activeBoss && this.activeBoss instanceof PingAndPongBoss) {
                                    this.activeBoss.handleAoeDamage(ex, ey, exploded.aoeRadius, exploded.damage, this.effects, this.audio);
                                } else if (this.inBossPhase && this.activeBoss && this.activeBoss instanceof VectorSnakeBoss) {
                                  this.activeBoss.handleAoeDamage(ex, ey, exploded.aoeRadius, exploded.damage, this.effects, this.audio);
                            }
                            continue outerRocket;
                        }
                    }
                      if (this.inBossPhase && this.activeBoss && this.activeBoss instanceof PlayerTwoBoss) {
                          const boss = this.activeBoss;
                          const bossRadius = typeof boss.radius === 'number' ? boss.radius : 0;
                          const combinedRadius = (r.radius || 0) + bossRadius;
                          const dxBoss = r.x - boss.x;
                          const dyBoss = r.y - boss.y;
                          if (dxBoss * dxBoss + dyBoss * dyBoss <= combinedRadius * combinedRadius) {
                              const exploded = this.rockets.splice(ri, 1)[0] || r;
                              this._detonatePlayerRocket(exploded);
                              continue outerRocket;
                          }
                      }
                      if (this.inBossPhase && this.activeBoss && this.activeBoss instanceof VectorSnakeBoss) {
                          const segments = Array.isArray(this.activeBoss.segments) ? this.activeBoss.segments : [];
                          for (let si = segments.length - 1; si >= 0; si--) {
                              const seg = segments[si];
                              if (!seg) continue;
                              const dx = r.x - seg.x;
                              const dy = r.y - seg.y;
                              const rr = (r.radius || 0) + (seg.radius || 0);
                              if (dx * dx + dy * dy <= rr * rr) {
                                  const exploded = this.rockets.splice(ri, 1)[0];
                                  if (exploded && this.effects && this.effects.createRocketExplosionRing) {
                                      this.effects.createRocketExplosionRing(exploded.x, exploded.y, exploded.aoeRadius);
                                      this.audio.playSound('RocketExplotion');
                                      if (this.shakeCanvas) this.shakeCanvas(7, 260);
                                  }
                                    const ex = exploded ? exploded.x : r.x;
                                    const ey = exploded ? exploded.y : r.y;
                                    const aoe = exploded ? exploded.aoeRadius : r.aoeRadius;
                                    for (let ej = this.enemies.length - 1; ej >= 0; ej--) {
                                        const en = this.enemies[ej];
                                        if (!en) continue;
                                        const enemyRadius = typeof en.radius === 'number' ? en.radius : 0;
                                        const combinedRadius = aoe + enemyRadius;
                                        const ddx = en.x - ex;
                                        const ddy = en.y - ey;
                                        if (Math.abs(ddx) > combinedRadius || Math.abs(ddy) > combinedRadius) continue;
                                        if (ddx * ddx + ddy * ddy <= combinedRadius * combinedRadius) {
                                          if ((en.spawnShieldUntil && Date.now() < en.spawnShieldUntil) || ((en.type === 'rhombus' || en.type === 'rhombus_boss') && en.invulnerable)) continue;
                                        if (!en.takeDamage(exploded.damage, this.effects, this.score, this.ctx, this.audio, {
                                            damageType: 'rocket',
                                            impactX: ex,
                                            impactY: ey
                                        })) {
                                            this.handleEnemyKilled(en, { cause: 'rocket', impactX: ex, impactY: ey });
                                            const last = this.enemies.length - 1;
                                            this.enemies[ej] = this.enemies[last];
                                            this.enemies.pop();
                                            if (this.inBossPhase && en.type && (ENEMY_TYPES[en.type]?.isBoss || ENEMY_TYPES[en.type]?.role === 'boss')) {
                                                this.onBossDefeated();
                                            }
                                            this.score += en.points;
                                            this.enemiesKilled++;
                                            this.uiManager.showScoreAddition(en.points);
                                        }
                                      }
                                  }
                                    if (this.activeBoss && this.activeBoss instanceof PingAndPongBoss) {
                                        this.activeBoss.handleAoeDamage(ex, ey, aoe, exploded.damage, this.effects, this.audio);
                                    } else if (this.activeBoss && this.activeBoss instanceof VectorSnakeBoss) {
                                      this.activeBoss.handleAoeDamage(ex, ey, aoe, exploded.damage, this.effects, this.audio);
                                  }
                                  continue outerRocket;
                              }
                          }
                      }
                }

                // Check mine direct collision: if mine overlaps any enemy, explode immediately
                outerMine: for (let mi = this.mines.length - 1; mi >= 0; mi--) {
                    const m = this.mines[mi];
                    if (!m) continue;
                    for (let ei = this.enemies.length - 1; ei >= 0; ei--) {
                        const enemy = this.enemies[ei];
                        if (!enemy) continue;
                        const dx = m.x - enemy.x, dy = m.y - enemy.y;
                        const rr = m.radius + enemy.radius;
                        if (dx*dx + dy*dy <= rr*rr) {
                            // Remove mine
                            const exploded = this.mines.splice(mi, 1)[0];
                            if (exploded && this.effects && this.effects.createRocketExplosionRing) {
                                this.effects.createRocketExplosionRing(exploded.x, exploded.y, exploded.aoeRadius);
                                this.audio.playSound('RocketExplotion');
                                if (this.shakeCanvas) this.shakeCanvas(7, 260);
                            }
                            // AoE damage
                            const ex = m.x, ey = m.y, aoe = exploded.aoeRadius;
                            for (let ej = this.enemies.length - 1; ej >= 0; ej--) {
                                const en = this.enemies[ej];
                                if (!en) continue;
                                const enemyRadius = typeof en.radius === 'number' ? en.radius : 0;
                                const combinedRadius = aoe + enemyRadius;
                                const ddx = en.x - ex, ddy = en.y - ey;
                                if (Math.abs(ddx) > combinedRadius || Math.abs(ddy) > combinedRadius) continue;
                                if (ddx*ddx + ddy*ddy <= combinedRadius * combinedRadius) {
                                    if ((en.spawnShieldUntil && Date.now() < en.spawnShieldUntil) || ((en.type === 'rhombus' || en.type === 'rhombus_boss') && en.invulnerable)) continue;
                                      if (!en.takeDamage(exploded.damage, this.effects, this.score, this.ctx, this.audio, {
                                          damageType: 'mine',
                                          impactX: ex,
                                          impactY: ey
                                      })) {
                                          this.handleEnemyKilled(en, { cause: 'mine', impactX: ex, impactY: ey });
                                          // swap-remove enemy
                                          const last = this.enemies.length - 1;
                                          this.enemies[ej] = this.enemies[last];
                                          this.enemies.pop();
                                          if (this.inBossPhase && en.type && (ENEMY_TYPES[en.type]?.isBoss || ENEMY_TYPES[en.type]?.role === 'boss')) {
                                              this.onBossDefeated();
                                          }
                                          this.score += en.points;
                                          this.enemiesKilled++;
                                          this.uiManager.showScoreAddition(en.points);
                                      }
                                }
                            }
                                if (this.inBossPhase && this.activeBoss && this.activeBoss instanceof PingAndPongBoss) {
                                    this.activeBoss.handleAoeDamage(ex, ey, exploded.aoeRadius, exploded.damage, this.effects, this.audio);
                                } else if (this.inBossPhase && this.activeBoss && this.activeBoss instanceof VectorSnakeBoss) {
                                  this.activeBoss.handleAoeDamage(ex, ey, exploded.aoeRadius, exploded.damage, this.effects, this.audio);
                              }
                            continue outerMine;
                        }
                    }
                      if (this.inBossPhase && this.activeBoss && this.activeBoss instanceof PlayerTwoBoss) {
                          const boss = this.activeBoss;
                          const bossRadius = typeof boss.radius === 'number' ? boss.radius : 0;
                          const combinedRadius = (m.radius || 0) + bossRadius;
                          const dxBoss = m.x - boss.x;
                          const dyBoss = m.y - boss.y;
                          if (dxBoss * dxBoss + dyBoss * dyBoss <= combinedRadius * combinedRadius) {
                              const exploded = this.mines.splice(mi, 1)[0] || m;
                              this._detonatePlayerMine(exploded, { shakeIntensity: 7, shakeDuration: 240 });
                              continue outerMine;
                          }
                      }
                      if (this.inBossPhase && this.activeBoss && this.activeBoss instanceof VectorSnakeBoss) {
                          const segments = Array.isArray(this.activeBoss.segments) ? this.activeBoss.segments : [];
                          for (let si = segments.length - 1; si >= 0; si--) {
                              const seg = segments[si];
                              if (!seg) continue;
                              const dx = m.x - seg.x;
                              const dy = m.y - seg.y;
                              const rr = (m.radius || 0) + (seg.radius || 0);
                              if (dx * dx + dy * dy <= rr * rr) {
                                  const exploded = this.mines.splice(mi, 1)[0];
                                  if (exploded && this.effects && this.effects.createRocketExplosionRing) {
                                      this.effects.createRocketExplosionRing(exploded.x, exploded.y, exploded.aoeRadius);
                                      this.audio.playSound('RocketExplotion');
                                      if (this.shakeCanvas) this.shakeCanvas(7, 260);
                                  }
                                    const ex = exploded ? exploded.x : m.x;
                                    const ey = exploded ? exploded.y : m.y;
                                    const aoe = exploded ? exploded.aoeRadius : m.aoeRadius;
                                    for (let ej = this.enemies.length - 1; ej >= 0; ej--) {
                                        const en = this.enemies[ej];
                                        if (!en) continue;
                                        const enemyRadius = typeof en.radius === 'number' ? en.radius : 0;
                                        const combinedRadius = aoe + enemyRadius;
                                        const ddx = en.x - ex;
                                        const ddy = en.y - ey;
                                        if (Math.abs(ddx) > combinedRadius || Math.abs(ddy) > combinedRadius) continue;
                                        if (ddx * ddx + ddy * ddy <= combinedRadius * combinedRadius) {
                                          if ((en.spawnShieldUntil && Date.now() < en.spawnShieldUntil) || ((en.type === 'rhombus' || en.type === 'rhombus_boss') && en.invulnerable)) continue;
                                        if (!en.takeDamage(exploded.damage, this.effects, this.score, this.ctx, this.audio, {
                                            damageType: 'mine',
                                            impactX: ex,
                                            impactY: ey
                                        })) {
                                            this.handleEnemyKilled(en, { cause: 'mine', impactX: ex, impactY: ey });
                                            const last = this.enemies.length - 1;
                                            this.enemies[ej] = this.enemies[last];
                                            this.enemies.pop();
                                            if (this.inBossPhase && en.type && (ENEMY_TYPES[en.type]?.isBoss || ENEMY_TYPES[en.type]?.role === 'boss')) {
                                                this.onBossDefeated();
                                            }
                                            this.score += en.points;
                                            this.enemiesKilled++;
                                            this.uiManager.showScoreAddition(en.points);
                                        }
                                      }
                                  }
                                    if (this.inBossPhase && this.activeBoss && this.activeBoss instanceof PingAndPongBoss) {
                                        this.activeBoss.handleAoeDamage(ex, ey, aoe, exploded.damage, this.effects, this.audio);
                                    } else if (this.inBossPhase && this.activeBoss && this.activeBoss instanceof VectorSnakeBoss) {
                                      this.activeBoss.handleAoeDamage(ex, ey, aoe, exploded.damage, this.effects, this.audio);
                                  }
                                  continue outerMine;
                              }
                          }
                      }
                }

                // Build spatial hash for enemies this frame (kept for other broad-phase uses)
                const enemyHash = new SpatialHash(80);
                for (let ei = 0; ei < this.enemies.length; ei++) {
                    const e = this.enemies[ei];
                    enemyHash.insert(e, e.x - e.radius, e.y - e.radius, e.x + e.radius, e.y + e.radius);
                }

				for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];
                    const dist = enemy.update(this.player, this.canvas, this.effects, this.enemyBullets, this.audio);
					if (!this.player.isDashing && dist < enemy.radius + this.player.radius) {
						const cfg = ENEMY_TYPES[enemy.type] || {};
						const isBoss = enemy.isBoss || cfg.isBoss || cfg.role === 'boss';
						// Bosses are not damaged/removed by collisions; they only damage the player
						if (isBoss) {
							this.player.takeDamage(enemy.damage, (this.player.x + enemy.x) / 2, (this.player.y + enemy.y) / 2, this.effects, this.audio);
						} else {
							this.handleEnemyKilled(enemy, { cause: 'collision' });
							this.player.takeDamage(enemy.damage, (this.player.x + enemy.x) / 2, (this.player.y + enemy.y) / 2, this.effects, this.audio);
							// swap-remove enemy
							const last = this.enemies.length - 1;
							this.enemies[i] = this.enemies[last];
							this.enemies.pop();
							if (this.inBossPhase && enemy.type && (ENEMY_TYPES[enemy.type]?.isBoss || ENEMY_TYPES[enemy.type]?.role === 'boss')) {
								this.onBossDefeated();
							}
							this.enemiesKilled++;
							continue;
						}
					}
                    if (!this.player.isDashing) {
                        // Query bullets near this enemy using spatial hash
                        const pad = 6; // bullet radius cushion
                        const nearIdx = bulletHash.queryAABB(enemy.x - enemy.radius - pad, enemy.y - enemy.radius - pad, enemy.x + enemy.radius + pad, enemy.y + enemy.radius + pad);
                        for (let k = 0; k < nearIdx.length; k++) {
                            const j = nearIdx[k];
                            const bullet = this.bullets[j];
                            if (!bullet || bullet._dead) continue;
                            const dx = bullet.x - enemy.x;
                            const dy = bullet.y - enemy.y;
                            const r = bullet.radius + enemy.radius;
                            if (dx*dx + dy*dy < r*r) {
							if ((enemy.spawnShieldUntil && Date.now() < enemy.spawnShieldUntil) || ((enemy.type === 'rhombus' || enemy.type === 'rhombus_boss') && enemy.invulnerable)) continue;
                                bullet._dead = true;
                                if (!enemy.takeDamage(bullet.damage, this.effects, this.score, this.ctx, this.audio, {
                                    damageType: 'bullet',
                                    impactX: bullet.x,
                                    impactY: bullet.y
                                })) {
                                    this.handleEnemyKilled(enemy, { cause: 'bullet', impactX: bullet.x, impactY: bullet.y });
                                    // swap-remove enemy
                                    const last = this.enemies.length - 1;
                                    this.enemies[i] = this.enemies[last];
                                    this.enemies.pop();
                                    if (this.inBossPhase && enemy.type && (ENEMY_TYPES[enemy.type]?.isBoss || ENEMY_TYPES[enemy.type]?.role === 'boss')) {
                                        this.onBossDefeated();
                                    }
                                    this.score += enemy.points;
                                    this.enemiesKilled++;
                                    this.uiManager.showScoreAddition(enemy.points);
                                }
                                break;
                            }
                        }
                        for (let j = this.effects.effects.length - 1; j >= 0; j--) {
                            const effect = this.effects.effects[j];
                            if (effect.type === 'railgunBeam') {
                                const minX = Math.min(effect.x, effect.endX) - enemy.radius;
                                const maxX = Math.max(effect.x, effect.endX) + enemy.radius;
                                const minY = Math.min(effect.y, effect.endY) - enemy.radius;
                                const maxY = Math.max(effect.y, effect.endY) + enemy.radius;
                                if (enemy.x < minX || enemy.x > maxX || enemy.y < minY || enemy.y > maxY) continue;
                                if (!effect.intersectsEnemy(enemy)) continue;
							if ((enemy.spawnShieldUntil && Date.now() < enemy.spawnShieldUntil) || ((enemy.type === 'rhombus' || enemy.type === 'rhombus_boss') && enemy.invulnerable)) continue;
                                if (!enemy.takeDamage(effect.damage, this.effects, this.score, this.ctx, this.audio, {
                                    damageType: 'railgun',
                                    impactX: enemy.x,
                                    impactY: enemy.y,
                                    ignoreShield: !!effect._isMaxCharge
                                })) {
                                    this.handleEnemyKilled(enemy, { cause: 'railgun', impactX: enemy.x, impactY: enemy.y });
                                    // swap-remove enemy
                                    const last = this.enemies.length - 1;
                                    this.enemies[i] = this.enemies[last];
                                    this.enemies.pop();
                                    if (this.inBossPhase && enemy.type && (ENEMY_TYPES[enemy.type]?.isBoss || ENEMY_TYPES[enemy.type]?.role === 'boss')) {
                                        this.onBossDefeated();
                                    }
                                    this.score += enemy.points;
                                    this.enemiesKilled++;
                                    this.uiManager.showScoreAddition(enemy.points);
                                }
                            }
                        }
                    }
                }

                if (this.inBossPhase && this.activeBoss && this.activeBoss instanceof PingAndPongBoss) {
                    for (let j = this.bullets.length - 1; j >= 0; j--) {
                        const b = this.bullets[j];
                        if (!b || b._dead) continue;
                        if (this.activeBoss.handlePlayerBullet(b, this.effects, this.audio)) {
                            b._dead = true;
                        }
                    }
                    for (let j = this.effects.effects.length - 1; j >= 0; j--) {
                        const effect = this.effects.effects[j];
                        if (effect.type !== 'railgunBeam') continue;
                        this.activeBoss.handleRailgunBeam(effect, this.effects, this.audio);
                    }
                }

                if (this.inBossPhase && this.activeBoss && this.activeBoss instanceof PlayerTwoBoss) {
                    for (let j = this.bullets.length - 1; j >= 0; j--) {
                        const b = this.bullets[j];
                        if (!b || b._dead) continue;
                        if (this.activeBoss.handlePlayerBullet(b, this.effects, this.audio)) {
                            b._dead = true;
                        }
                    }
                    for (let j = this.effects.effects.length - 1; j >= 0; j--) {
                        const effect = this.effects.effects[j];
                        if (effect.type !== 'railgunBeam') continue;
                        this.activeBoss.handleRailgunBeam(effect, this.effects, this.audio);
                    }
                }

                if (this.inBossPhase && this.activeBoss && this.activeBoss instanceof VectorSnakeBoss) {
                    for (let j = this.bullets.length - 1; j >= 0; j--) {
                        const b = this.bullets[j];
                        if (!b || b._dead) continue;
                        if (this.activeBoss.handlePlayerBullet(b, this.effects, this.audio)) {
                            b._dead = true;
                        }
                    }
                    for (let j = this.effects.effects.length - 1; j >= 0; j--) {
                        const effect = this.effects.effects[j];
                        if (effect.type !== 'railgunBeam') continue;
                        this.activeBoss.handleRailgunBeam(effect, this.effects, this.audio);
                    }
                }

                // Bullet collisions with tetromino pieces
                if (this.inBossPhase && this.activeBoss && this.activeBoss instanceof TetrisCrossBoss) {
                    const cellHash = new SpatialHash(TETRIS_SETTINGS.cellSize || 40);
                    for (let p = 0; p < this.tetrisManager.activePieces.length; p++) {
                        const piece = this.tetrisManager.activePieces[p];
                        if (!piece || piece.dying) continue;
                        const cells = piece.getCells();
                        for (let c = 0; c < cells.length; c++) {
                            const cell = cells[c];
                            const r = cell.r;
                            cellHash.insert({ piece, cell }, cell.x - r, cell.y - r, cell.x + r, cell.y + r);
                        }
                    }
                    outerBullet: for (let j = this.bullets.length - 1; j >= 0; j--) {
                        const b = this.bullets[j];
                        if (!b || b._dead) continue;
                        const distToBoss = Math.hypot(b.x - this.activeBoss.x, b.y - this.activeBoss.y);
                        if (distToBoss <= 63 + b.radius) {
                            this.effects.createBulletExplosion(b.x, b.y, '#00ffff');
                            b._dead = true;
                            continue;
                        }
                        const nearby = cellHash.queryAABB(b.x - 20, b.y - 20, b.x + 20, b.y + 20);
                        for (let idx = 0; idx < nearby.length; idx++) {
                            const { piece, cell } = nearby[idx];
                            const dx = b.x - cell.x, dy = b.y - cell.y;
                            if (dx*dx + dy*dy < (b.radius + cell.r) * (b.radius + cell.r)) {
                                b._dead = true;
                                piece.hp -= b.damage;
                                this.effects.createHitEffect(cell.x, cell.y);
                                piece.damageFlash = 12;
                                if (piece.hp <= 0) {
                                    piece.startDeath(this.effects);
                                }
                                continue outerBullet;
                            }
                        }
                    }

                    // Railgun beam collisions with tetromino pieces
                    for (let j = this.effects.effects.length - 1; j >= 0; j--) {
                        const effect = this.effects.effects[j];
                        if (effect.type !== 'railgunBeam') continue;
                        for (let p = this.tetrisManager.activePieces.length - 1; p >= 0; p--) {
                            const piece = this.tetrisManager.activePieces[p];
                            if (!piece || piece.dying) continue;
                            const cells = piece.getCells();
                            if (effect.intersectsCircle(piece.x, piece.y, 0, piece.id)) {
                                piece.hp -= effect.damage;
                                piece.damageFlash = 12;
                                if (piece.hp <= 0) {
                                    piece.startDeath(this.effects);
                                }
                            } else {
                                for (let c = 0; c < cells.length; c++) {
                                    const cell = cells[c];
                                    if (effect.intersectsCircle(cell.x, cell.y, cell.r, piece.id)) {
                                        piece.hp -= effect.damage;
                                        piece.damageFlash = 12;
                                        if (piece.hp <= 0) {
                                            piece.startDeath(this.effects);
                                        }
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }

                // Player collisions with tetromino pieces and stack (boss phase)
                if (this.inBossPhase && this.activeBoss && this.activeBoss instanceof TetrisCrossBoss && !this.player.isDashing) {
                    const cellHash = new SpatialHash(TETRIS_SETTINGS.cellSize || 40);
                    for (let p = 0; p < this.tetrisManager.activePieces.length; p++) {
                        const piece = this.tetrisManager.activePieces[p];
                        if (!piece || piece.dying) continue;
                        const cells = piece.getCells();
                        for (let c = 0; c < cells.length; c++) {
                            const cell = cells[c];
                            const r = cell.r;
                            cellHash.insert({ piece, cell }, cell.x - r, cell.y - r, cell.x + r, cell.y + r);
                        }
                    }
                    // Include stacked cells too
                    for (let s = 0; s < this.tetrisManager.stack.length; s++) {
                        const cell = this.tetrisManager.stack[s];
                        const r = cell.r;
                        cellHash.insert({ piece: null, cell }, cell.x - r, cell.y - r, cell.x + r, cell.y + r);
                    }
                    const px = this.player.x, py = this.player.y, pr = this.player.radius;
                    const nearby = cellHash.queryAABB(px - pr, py - pr, px + pr, py + pr);
                    for (let i = 0; i < nearby.length; i++) {
                        const { cell } = nearby[i];
                        const dx = px - cell.x, dy = py - cell.y;
                        if (dx*dx + dy*dy <= (pr + cell.r) * (pr + cell.r)) {
                            this.player.takeDamage(TETRIS_SETTINGS.playerCollisionDamage || 25, (px + cell.x) / 2, (py + cell.y) / 2, this.effects, this.audio);
                            break;
                        }
                    }
                }

                if (this.inBossPhase && this.activeBoss && this.activeBoss instanceof PingAndPongBoss) {
                    this.activeBoss.checkPlayerCollision(this.player, this.effects, this.audio);
                }

                if (this.inBossPhase && this.activeBoss && this.activeBoss instanceof PlayerTwoBoss) {
                    this.activeBoss.checkPlayerCollision(this.player, this.effects, this.audio);
                }

                if (this.inBossPhase && this.activeBoss && this.activeBoss instanceof VectorSnakeBoss && !this.player.isDashing) {
                    this.activeBoss.checkPlayerCollision(this.player, this.effects, this.audio);
                }

                // Railgun interaction with Tetris Cross boss (full charge only)
                if (this.inBossPhase && this.activeBoss && this.activeBoss instanceof TetrisCrossBoss) {
					// Player circle collision with Tetris boss should only damage player, not boss
					if (!this.player.isDashing) {
						const distToBoss = Math.hypot(this.player.x - this.activeBoss.x, this.player.y - this.activeBoss.y);
						if (distToBoss < 63 + this.player.radius) {
							this.player.takeDamage(TETRIS_SETTINGS.playerCollisionDamage || 25, (this.player.x + this.activeBoss.x) / 2, (this.player.y + this.activeBoss.y) / 2, this.effects, this.audio);
						}
					}
                    for (let j = this.effects.effects.length - 1; j >= 0; j--) {
                        const effect = this.effects.effects[j];
                        if (effect.type !== 'railgunBeam') continue;
                        const hit = effect.intersectsCircle(this.activeBoss.x, this.activeBoss.y, 63, null);
                        if (hit) {
                            this.activeBoss._beamHitSet = this.activeBoss._beamHitSet || new WeakSet();
                            if (this.activeBoss._beamHitSet.has(effect)) continue;
                            this.activeBoss._beamHitSet.add(effect);
                            const alive = this.activeBoss.takeRailgunDamage(effect.damage, effect.charge >= 1);
                            if (!alive) {
                                this.onBossDefeated();
                            }
                        }
                    }
                }

                if (!this.player.isDashing) {
                    for (let i = this.enemyBullets.length - 1; i >= 0; i--) {
                        const bullet = this.enemyBullets[i];
                        const dist = Math.sqrt((bullet.x - this.player.x) ** 2 + (bullet.y - this.player.y) ** 2);
                        if (dist < bullet.radius + this.player.radius) {
                            this.player.takeDamage(bullet.damage, bullet.x, bullet.y, this.effects, this.audio);
                            const last = this.enemyBullets.length - 1;
                            this.enemyBullets[i] = this.enemyBullets[last];
                            this.enemyBullets.pop();
                        }
                    }
                }
                
                // Post-collision compaction for bullets (remove any marked as dead)
                {
                    let write = 0;
                    for (let read = 0; read < this.bullets.length; read++) {
                        const b = this.bullets[read];
                        if (b && !b._dead) this.bullets[write++] = b;
                    }
                    this.bullets.length = write;
                }
                this.effects.update(this.player.x, this.player.y);
                
                // If custom boss died outside of loop, close phase
                if (this.inBossPhase && this.activeBoss && this.activeBoss instanceof TetrisCrossBoss && !this.activeBoss.active) {
                    this.onBossDefeated();
                } else if (this.inBossPhase && this.activeBoss && this.activeBoss instanceof PingAndPongBoss && this.activeBoss.isDefeated()) {
                    this.onBossDefeated();
                } else if (this.inBossPhase && this.activeBoss && this.activeBoss instanceof PlayerTwoBoss && this.activeBoss.isDefeated()) {
                    this.onBossDefeated();
                } else if (this.inBossPhase && this.activeBoss && this.activeBoss instanceof VectorSnakeBoss && this.activeBoss.isDefeated()) {
                    this.onBossDefeated();
                }

                if (this.player.health <= 0 && !this.gameOver) {
                    this.gameOver = true;
                    this.gameOverTime = Date.now();
                    this.input.clear();
                    this.audio.stopGameMusic();
                    this.audio.stopLobbyMusic();
                    if (this.gameOverRain) {
                        this.gameOverRain.reset();
                    }
                    this.updateBestStatsIfNeeded(this.score, this.currentWave);
                    this.updateBestStatsLabel();
                    this.player.stopRailgunCharge(this.audio);
                    this.audio.playSound('gameOver');
                    this.scheduleGameOverVoiceLine();
                    this.uiManager.hideUI(); // Hide UI when game over
                }

                // Collect XP rings
                for (let k = this.effects.effects.length - 1; k >= 0; k--) {
                    const eff = this.effects.effects[k];
                    if (eff.type === 'xpRing') {
                        const distToPlayer = Math.hypot(eff.x - this.player.x, eff.y - this.player.y);
                        const preExpireDuration = 120;
                        const preExpireScale = (eff.life > 0 && eff.life < preExpireDuration)
                            ? (1 - 0.2 * (1 - (eff.life / preExpireDuration)))
                            : 1;
                        const visibleScale = eff.life > 0 ? preExpireScale : Math.max(0, 1 - eff.fadeOut);
                        const renderSize = eff.size * visibleScale;
                        if (distToPlayer < renderSize + this.player.radius && (eff.life > 0 || eff.fadeOut < 1)) {
                            const add = eff.xpAmount || 0;
                            this.playerXp += add;
                            while (this.playerXp >= this.playerXpRequired) {
                                this.playerXp -= this.playerXpRequired;
                                this.playerLevel += 1;
                                if (this.audio) this.audio.playSound('Level_UP');
                                this.playerXpRequired = getRequiredXpForLevel(this.playerLevel);
                                this.triggerLevelUpSelection();
                            }
                            if (this.audio) this.audio.playSound('XP_collect');
                            this.effects.createXPCollectEffect(eff.x, eff.y);
                            this.uiManager.showXPGainOverlay(add, this.playerXpRequired);
                            this.uiManager.updateXPBar(this.playerXp, this.playerXpRequired, this.playerLevel);
                            this.effects.effects.splice(k, 1);
                        }
                    }
                }
            }

            draw() {
                this.ctx.fillStyle = '#000000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                if (this.inLobby) {
                    // Draw falling numbers background and radial lines in lobby (below UI)
                    this.fallingNumbers.draw(this.ctx);
                    // Radial lines: red, rotating slowly around logo center
                    const cx = this.lobbyRadialCenterX, cy = this.lobbyRadialCenterY;
                    const time = Date.now();
                    const angle = (time % 120000) / 120000 * Math.PI * 2; // slower rotation: 120s per full turn
                    const cosA = Math.cos(angle), sinA = Math.sin(angle);
                    const dirs = this.lobbyRadial.baseDirs;
                    const innerR = this.lobbyRadial.innerR, outerR = this.lobbyRadialOuterR;
                    this.ctx.save();
                    this.ctx.translate(cx, cy);
                    this.ctx.strokeStyle = 'rgba(255, 0, 0, 0.25)';
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath();
                    for (let i = 0; i < dirs.length; i++) {
                        const bx = dirs[i].x, by = dirs[i].y;
                        const rx = bx * cosA - by * sinA;
                        const ry = bx * sinA + by * cosA;
                        this.ctx.moveTo(rx * innerR, ry * innerR);
                        this.ctx.lineTo(rx * outerR, ry * outerR);
                    }
                    this.ctx.stroke();
                    this.ctx.restore();
                    return;
                }
                
                this.backgroundBinary.draw(this.ctx);
                this.drawInfiniteGrid();

                // Tetris stack and falling pieces (under everything else except background)
                if (this.inBossPhase && this.activeBoss && this.activeBoss instanceof TetrisCrossBoss) {
                    this.tetrisManager.draw(this.ctx);
                }
                
                this.ctx.beginPath();
                this.ctx.moveTo(this.player.x, this.player.y);
                this.ctx.lineTo(this.input.mouse.x, this.input.mouse.y);
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                this.ctx.lineWidth = 1;
                this.ctx.stroke();
                // draw rocket direction hint when middle is down
                if (this.input.mouse.middleDown) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.player.x, this.player.y);
                    this.ctx.lineTo(this.input.mouse.x, this.input.mouse.y);
                    this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.4)';
                    this.ctx.lineWidth = 3;
                    this.ctx.stroke();
                }
				this.enemyBullets.forEach(bullet => bullet.draw(this.ctx));
				// Draw boss above enemies for emphasis (works for any boss type)
				if (this.inBossPhase && this.activeBoss && !(this.activeBoss instanceof TetrisCrossBoss)) {
					const bossRef = this.activeBoss;
					this.enemies.forEach(enemy => { if (enemy !== bossRef) enemy.draw(this.ctx); });
					bossRef.draw(this.ctx);
				} else {
					this.enemies.forEach(enemy => enemy.draw(this.ctx));
					// Draw Tetris Cross boss above enemies and bullets for emphasis
					if (this.inBossPhase && this.activeBoss && this.activeBoss instanceof TetrisCrossBoss) {
						this.activeBoss.draw(this.ctx);
					}
				}
                this.effects.draw(this.ctx, this.score, this.player.x, this.player.y, this.bullets);
                // Draw rockets above effects but before player
                  for (let i = 0; i < this.rockets.length; i++) {
                      const r = this.rockets[i];
                      if (r) r.draw(this.ctx);
                  }
                  for (let i = 0; i < this.enemyRockets.length; i++) {
                      const er = this.enemyRockets[i];
                      if (er) er.draw(this.ctx);
                  }
                  // Draw mines above effects but before player
                  if (this.mines) {
                      for (let i = 0; i < this.mines.length; i++) {
                          const m = this.mines[i];
                          if (m) m.draw(this.ctx);
                      }
                  }
                  if (this.enemyMines) {
                      for (let i = 0; i < this.enemyMines.length; i++) {
                          const em = this.enemyMines[i];
                          if (em) em.draw(this.ctx);
                      }
                  }
                this.player.draw(this.ctx);
                
                // Draw custom crosshair
                this.drawCrosshair();
                
                if (this.paused) {
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = '48px Roboto';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('PAUSED', this.canvas.width / 2, this.canvas.height / 2 - 20);
                    
                    // Fast blinking continue text with fade (90 frames = 1.5 seconds at 60fps)
                    const blinkCycle = this.pauseBlinkFrame % 90;
                    let opacity;
                    
                    if (blinkCycle < 90) {
                        // Fade in during first half
                        opacity = blinkCycle / 90;
                    } else {
                        // Fade out during second half
                        opacity = (180 - blinkCycle) / 90;
                    }
                    
                    this.ctx.save();
                    this.ctx.globalAlpha = opacity;
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = '20px Roboto';
                    this.ctx.fillText('Press ESC to continue', this.canvas.width / 2, this.canvas.height / 2 + 30);
                    this.ctx.restore();
                }
                if (this.gameOver) {
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    if (this.gameOverRain) {
                        this.gameOverRain.draw(this.ctx);
                    }
                    this.ctx.fillStyle = '#ff4444';
                    this.ctx.font = '48px Roboto';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('BREACH FAILED', this.canvas.width / 2, this.canvas.height / 2 - 60);
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = '28px Roboto';
                                        // Center the stats block vertically with equal spacing
                    const centerX = this.canvas.width / 2;
                    const lineHeight = 40;
                    const gameOverY = this.canvas.height / 2 - 60;
                    const minTopY = gameOverY + 50;
                    const idealTopY = this.canvas.height / 2 - 2 * lineHeight;
                    const statsStartY = Math.max(minTopY, idealTopY);

                    const survivalTimeText = `Survival Time: ${this.formatTime(this.getEffectiveElapsedTime(this.gameOverTime))}`;
                    const finalScoreText = `Final Score: ${this.score}`;
                    const survivedWavesText = `Survived Waves: ${this.currentWave}`;
                    const bestScoreText = `Best Score: ${this.bestScore}`;
                    const bestWaveText = `Best Wave: ${this.maxWave}`;

                    this.ctx.fillText(survivalTimeText, centerX, statsStartY + 0 * lineHeight);
                    this.ctx.fillText(finalScoreText, centerX, statsStartY + 1 * lineHeight);
                    this.ctx.fillText(survivedWavesText, centerX, statsStartY + 2 * lineHeight);
                    this.ctx.fillText(bestScoreText, centerX, statsStartY + 3 * lineHeight);
                    this.ctx.fillText(bestWaveText, centerX, statsStartY + 4 * lineHeight);

                    if (this.isNewBestScore) {
                        const w = this.ctx.measureText(bestScoreText).width;
                        this.ctx.save();
                        this.ctx.textAlign = 'left';
                        this.ctx.fillStyle = '#00ff00';
                        this.ctx.font = 'bold 24px Roboto';
                        this.ctx.fillText('NEW!', centerX + w / 2 + 16, statsStartY + 3 * lineHeight);
                        this.ctx.restore();
                    }
                    if (this.isNewMaxWave) {
                        const w2 = this.ctx.measureText(bestWaveText).width;
                        this.ctx.save();
                        this.ctx.textAlign = 'left';
                        this.ctx.fillStyle = '#00ff00';
                        this.ctx.font = 'bold 24px Roboto';
                        this.ctx.fillText('NEW!', centerX + w2 / 2 + 16, statsStartY + 4 * lineHeight);
                        this.ctx.restore();
                    }

                    
                    // Fast blinking restart text with fade (slowed 2x: 180 frames = 3 seconds at 60fps)
                    const blinkCycle = this.gameOverBlinkFrame % 180;
                    let opacity;
                    
                    if (blinkCycle < 90) {
                        // Fade in during first half
                        opacity = blinkCycle / 90;
                    } else {
                        // Fade out during second half
                        opacity = (180 - blinkCycle) / 90;
                    }
                    
                    this.ctx.save();
                    this.ctx.globalAlpha = opacity;
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = '20px Roboto';
                    this.ctx.fillText('Press SPACE to restart', this.canvas.width / 2, this.canvas.height / 2 + 200);
                    this.ctx.fillText('Press ESC to return to lobby', this.canvas.width / 2, this.canvas.height / 2 + 230);
                    this.ctx.restore();
                }
            }

            getEffectiveElapsedTime(nowOverride) {
                if (this.inLobby) return 0;

                let reference;
                if (this.gameOver && this.gameOverTime) {
                    reference = this.gameOverTime;
                } else if (this.paused && this.pauseTime) {
                    reference = this.pauseTime;
                } else if (typeof nowOverride === 'number') {
                    reference = nowOverride;
                } else {
                    reference = Date.now();
                }

                let elapsed = reference - this.startTime;
                if (!Number.isFinite(elapsed) || elapsed < 0) {
                    elapsed = 0;
                }

                let excluded = this.totalBossTimeExcluded || 0;
                if (this.inBossPhase && this.bossTimerPauseStart) {
                    const bossElapsed = reference - this.bossTimerPauseStart;
                    if (Number.isFinite(bossElapsed) && bossElapsed > 0) {
                        excluded += bossElapsed;
                    }
                }

                const effective = elapsed - excluded;
                return effective > 0 ? effective : 0;
            }

            formatTime(ms) {
                const seconds = Math.floor(ms / 1000);
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
            
            drawCrosshair() {
                if (this.inLobby || this.gameOver) return;
                
                const crosshairSize = 20;
                const centerX = this.input.mouse.x;
                const centerY = this.input.mouse.y;
                const gap = 4; // Gap between center && crosshair lines
                const thickness = 2;
                
                // Orange when railgun is fully charged (100%), cyan otherwise
                const isMax = this.player && this.player.railgunCharge === 1;
                this.ctx.strokeStyle = isMax ? '#ffa500' : '#00ffff';
                this.ctx.lineWidth = thickness;
                this.ctx.lineCap = 'round';
                
                // Draw crosshair lines
                this.ctx.beginPath();
                
                // Horizontal line (left)
                this.ctx.moveTo(centerX - crosshairSize/2, centerY);
                this.ctx.lineTo(centerX - gap, centerY);
                
                // Horizontal line (right)
                this.ctx.moveTo(centerX + gap, centerY);
                this.ctx.lineTo(centerX + crosshairSize/2, centerY);
                
                // Vertical line (top)
                this.ctx.moveTo(centerX, centerY - crosshairSize/2);
                this.ctx.lineTo(centerX, centerY - gap);
                
                // Vertical line (bottom)
                this.ctx.moveTo(centerX, centerY + gap);
                this.ctx.lineTo(centerX, centerY + crosshairSize/2);
                
                this.ctx.stroke();
                
                // Draw center dot
                this.ctx.fillStyle = '#00ffff';
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, 1, 0, Math.PI * 2);
                this.ctx.fill();
            }

            loop(timestamp) {
                // Always update falling numbers in lobby
                if (this.inLobby) {
                    this.fallingNumbers.update();
                } else {
                    this.backgroundBinary.update();
                    if (this.gameOver && this.gameOverRain) {
                        this.gameOverRain.update();
                    }
                }
                
                  const gameTime = this.getEffectiveElapsedTime();
                
                if (!this.paused && !this.gameOver && !this.inLobby) {
                    this.update(timestamp);
                }
                
                this.draw();
                
                // Update game over blink animation
                if (this.gameOver) {
                    this.gameOverBlinkFrame += getTimeScale();
                }
                
                // Update pause blink animation
                if (this.paused) {
                    this.pauseBlinkFrame += getTimeScale();
                }
                
                // Update next wave/boss timer display
                if (this.inBossPhase) {
                    if (!this.activeBoss) {
                          const bossLabel = this.pendingBossDisplayName || getBossDisplayName(this.pendingBossKey);
                          this.uiManager.showBossWarning(bossLabel, this.pendingBossKey);
                    } else {
                        this.uiManager.hideBossWarning();
                    }
                 } else if (this.inWavePause) {
                     const pauseActive = (this.paused || this.upgradePause) && Number.isFinite(this.pauseTime) && this.pauseTime > 0;
                     const nowReference = pauseActive ? this.pauseTime : Date.now();
                     const endTime = Number.isFinite(this.wavePauseEndTime) ? this.wavePauseEndTime : nowReference;
                     const remainingTime = Math.max(0, endTime - nowReference);
                     const seconds = Math.ceil(remainingTime / 1000);
                     this.uiManager.showNextWaveTimer(seconds);
                } else {
                    this.uiManager.hideNextWaveTimer();
                    if (this.uiManager && this.uiManager.hideBossWarning) this.uiManager.hideBossWarning();
                }
                
                // FPS calculation and label update
                if (this._lastFpsTime) {
                    const dt = (timestamp - this._lastFpsTime) / 1000;
                    if (dt > 0) {
                        const inst = 1 / dt;
                        // Rolling window average
                        this._fpsSamples.push(inst);
                        this._fpsSum += inst;
                        if (this._fpsSamples.length > this._fpsWindow) {
                            this._fpsSum -= this._fpsSamples.shift();
                        }
                        this._fps = this._fpsSum / Math.max(1, this._fpsSamples.length);
                    }
                }
                this._lastFpsTime = timestamp || performance.now();
                if (this.uiManager && this.uiManager.updateFPS) {
                    this.uiManager.updateFPS(this._fps);
                }
                
                // Only update UI if not in lobby
                if (!this.inLobby) {
                    this.uiManager.updateStats(this.score, this.enemiesKilled, this.formatTime(gameTime), this.currentWave);
                    // Keep XP bar in sync
                    this.uiManager.updateXPBar(this.playerXp, this.playerXpRequired, this.playerLevel);
                }
                
                requestAnimationFrame(t => this.loop(t));
            }

            start() {
                requestAnimationFrame(t => this.loop(t));
            }

            prepareWaveGroups() {
                // Shuffle waves inside each group; reset group indices
                this.waveGroupsPrepared = WAVE_GROUPS.map(group => shuffleArray(group));
                this.currentGroupIndex = 0;
                this.currentGroupQueue = this.waveGroupsPrepared.length > 0 ? this.waveGroupsPrepared[0].slice() : [];
                this.currentWave = 0;
            }

            getNextGroupedWave() {
                // If no groups or finished all groups
                if (!this.waveGroupsPrepared || this.currentGroupIndex >= this.waveGroupsPrepared.length) {
                    return null;
                }
                // If current group exhausted, advance to next group
                if (this.currentGroupQueue.length === 0) {
                    // Before advancing to the next group, trigger a boss phase
                    this.triggerBossPhase();
                    return null;
                }
                // Pop next wave from current group's randomized queue
                const wave = this.currentGroupQueue.shift();
                return wave || null;
            }

            resumeAfterUpgrade() {
                this.upgradePause = false;
                this.upgradeOverlayHiddenByPause = false;
                if (this.paused) {
                    this.paused = false;
                }
                if (typeof this.exitPause === 'function') {
                    this.exitPause({ playSound: false });
                } else {
                    if (this.audio && typeof this.audio.resumeMusic === 'function') {
                        this.audio.resumeMusic();
                    }
                    const quitButton = document.getElementById('quitButton');
                    if (quitButton) {
                        quitButton.classList.remove('visible');
                    }
                    this.pauseTime = 0;
                }
            }

            triggerLevelUpSelection() {
                if (this.gameOver) {
                    return;
                }
                // Pause game && show upgrade UI
                this.paused = true;
                this.upgradePause = true;
                this.upgradeOverlayHiddenByPause = false;
                this.pauseTime = Date.now();
                this.input.clear();
                const options = this.upgradeManager.getRandomOptions(this.playerLevel, 3);
				// If nothing to show, grant +25 HP and skip selection
				if (!options || options.length === 0) {
					if (this.player && this.player.health > 0) {
						this.player.health = Math.min(this.player.maxHealth, this.player.health + 25);
					}
					this.resumeAfterUpgrade();
					return;
				}
                this.upgradeManager.renderOptions(options);
            }
            
            // ---- Persistent Best Stats ----
            loadBestStats() {
                try {
                    const saved = JSON.parse(localStorage.getItem('geometry_rush_best') || '{}');
                    this.bestScore = Number.isFinite(saved.bestScore) ? saved.bestScore : 0;
                    this.maxWave = Number.isFinite(saved.maxWave) ? saved.maxWave : 0;
                } catch (e) {
                    this.bestScore = 0;
                    this.maxWave = 0;
                }
            }

            saveBestStats() {
                try {
                    localStorage.setItem('geometry_rush_best', JSON.stringify({ bestScore: this.bestScore, maxWave: this.maxWave }));
                } catch (e) {
                    // ignore storage errors
                }
            }

            updateBestStatsIfNeeded(score, wave) {
                let updated = false;
                if (typeof score === 'number' && score > this.bestScore) {
                    this.bestScore = score;
                    this.isNewBestScore = true;
                    updated = true;
                }
                if (typeof wave === 'number' && wave > this.maxWave) {
                    this.maxWave = wave;
                    this.isNewMaxWave = true;
                    updated = true;
                }
                if (updated) this.saveBestStats();
            }

            updateBestStatsLabel() {
                const el = document.getElementById('bestStats');
                if (!el) return;
                el.textContent = `Best Score: ${this.bestScore} / Max Wave: ${this.maxWave}`;
            }
        }

        // Upgrade Manager
        class UpgradeManager {
            constructor(game) {
                this.game = game;
                const baseUpgrades = Array.isArray(window.PLAYER_UPGRADES) ? window.PLAYER_UPGRADES : [];
                if (!Array.isArray(window.PLAYER_UPGRADES)) {
                    console.warn('PLAYER_UPGRADES is not defined; UpgradeManager will have no upgrades configured.');
                }
                this.upgrades = baseUpgrades.map((config) => {
                    const { apply, ...rest } = config;
                    return {
                        ...rest,
                        apply: () => {
                            if (typeof apply === 'function') {
                                apply(this.game);
                            }
                        }
                    };
                });
                this.taken = new Set();
                this.currentOptions = [];
                this.keyHandler = null;
                this.selectionLocked = false;
                this.iconCache = (typeof window !== 'undefined' && window.UPGRADE_ICON_CACHE) ? window.UPGRADE_ICON_CACHE : Object.create(null);
            }

            getRandomOptions(maxLevel, count = 3) {
                const pool = this.upgrades.filter(u => u.level <= maxLevel && !this.taken.has(u.key));
                const shuffled = shuffleArray(pool);
                if (shuffled.length <= count) return shuffled;

                const selected = [];
                const usedCategories = new Set();
                for (const upgrade of shuffled) {
                    const category = upgrade.category || upgrade.key;
                    if (!usedCategories.has(category)) {
                        selected.push(upgrade);
                        usedCategories.add(category);
                        if (selected.length === count) break;
                    }
                }

                if (selected.length < count) {
                    for (const upgrade of shuffled) {
                        if (selected.includes(upgrade)) continue;
                        selected.push(upgrade);
                        if (selected.length === count) break;
                    }
                }

                return selected;
            }

            renderOptions(options) {
                const overlay = document.getElementById('upgradeOverlay');
                const container = document.getElementById('upgradeContainer');
                container.innerHTML = '';
                this.currentOptions = options.slice();
                this.selectionLocked = false;
                // Centering: container is flex and will center 1, 2, or 3 cards
                options.forEach((opt, idx) => {
                    const card = document.createElement('div');
                    card.className = 'upgrade-card';
                    card.dataset.key = opt.key;
                    const badge = document.createElement('div');
                    badge.className = 'upgrade-key-badge';
                    badge.textContent = String(idx + 1);
                    const img = document.createElement('img');
                    const cachedIcon = this.iconCache && this.iconCache[opt.image];
                    if (cachedIcon && cachedIcon.src) {
                        img.src = cachedIcon.src;
                    } else {
                        img.src = opt.image;
                    }
                    img.alt = opt.title;
                    const title = document.createElement('div');
                    title.className = 'upgrade-title';
                    title.textContent = opt.title;
                    const desc = document.createElement('div');
                    desc.className = 'upgrade-desc';
                    desc.textContent = opt.desc;
                    const btn = document.createElement('button');
                    btn.className = 'upgrade-select-btn';
                    btn.textContent = 'Select';
                    btn.onclick = () => this.selectUpgrade(opt);
                    card.appendChild(badge);
                    card.appendChild(img);
                    card.appendChild(title);
                    card.appendChild(desc);
                    card.appendChild(btn);
                    container.appendChild(card);
                });
                overlay.classList.add('visible');

                // Setup key shortcuts 1/2/3
                if (this.keyHandler) {
                    document.removeEventListener('keydown', this.keyHandler);
                }
                this.keyHandler = (e) => {
                    const ov = document.getElementById('upgradeOverlay');
                    if (!ov || !ov.classList.contains('visible')) return;
                    const code = e.code;
                    let index = -1;
                    if (code === 'Digit1' || code === 'Numpad1' || e.key === '1') index = 0;
                    else if (code === 'Digit2' || code === 'Numpad2' || e.key === '2') index = 1;
                    else if (code === 'Digit3' || code === 'Numpad3' || e.key === '3') index = 2;
                    if (index >= 0 && index < this.currentOptions.length) {
                        e.preventDefault();
                        this.selectUpgrade(this.currentOptions[index]);
                    }
                };
                document.addEventListener('keydown', this.keyHandler);
            }

            selectUpgrade(opt) {
                if (!opt || this.selectionLocked) return;
                this.selectionLocked = true;
                this.taken.add(opt.key);
                // Visual selection effect: fade out other cards, highlight selected slightly longer
                const container = document.getElementById('upgradeContainer');
                const cards = Array.from(container.querySelectorAll('.upgrade-card'));
                const selectedCard = cards.find(c => c.dataset.key === opt.key);
                if (selectedCard) {
                    cards.forEach(c => {
                        if (c !== selectedCard) c.classList.add('dimmed');
                    });
                    selectedCard.classList.add('selected');
                }
                // Apply upgrade
                opt.apply();
                if (this.game && this.game.audio) {
                    this.game.audio.playSound('UpgradeSelected');
                }
                // Close overlay && resume after a short delay to show the selection
                setTimeout(() => {
                    document.getElementById('upgradeOverlay').classList.remove('visible');
                    if (this.keyHandler) {
                        document.removeEventListener('keydown', this.keyHandler);
                        this.keyHandler = null;
                    }
                    this.currentOptions = [];
                    this.selectionLocked = false;
                    this.game.resumeAfterUpgrade();
                }, 350);
            }

            reset() {
                this.taken.clear();
                if (this.keyHandler) {
                    document.removeEventListener('keydown', this.keyHandler);
                    this.keyHandler = null;
                }
                this.currentOptions = [];
                this.selectionLocked = false;
            }
        }

        // Initialize && start the game
        const game = new Game();
        game.start();

    </script>
</body>
</html>
